
ucosII_hello_world.elf:     file format elf32-microblaze


Disassembly of section .vectors.reset:

10000000 <_start>:
10000000:	b0001000 	imm	4096
10000004:	b8080050 	brai	80	// 10000050 <_start1>

Disassembly of section .vectors.sw_exception:

10000008 <_vector_sw_exception>:
10000008:	b0001000 	imm	4096
1000000c:	b80883a4 	brai	-31836	// 100083a4 <_exception_handler>

Disassembly of section .vectors.interrupt:

10000010 <_vector_interrupt>:
10000010:	b0001000 	imm	4096
10000014:	b8088258 	brai	-32168	// 10008258 <OS_CPU_ISR>

Disassembly of section .vectors.hw_exception:

10000020 <_vector_hw_exception>:
10000020:	b0001000 	imm	4096
10000024:	b80883ac 	brai	-31828	// 100083ac <_hw_exception_handler>

Disassembly of section .text:

10000050 <_start1>:
10000050:	b0001000 	imm	4096
10000054:	31a08d38 	addik	r13, r0, -29384	// 10008d38 <_SDA_BASE_>
10000058:	b0001000 	imm	4096
1000005c:	30408c20 	addik	r2, r0, -29664	// 10008c20 <_SDA2_BASE_>
10000060:	b0001000 	imm	4096
10000064:	3020e398 	addik	r1, r0, -7272
10000068:	b9f40130 	brlid	r15, 304	// 10000198 <_crtinit>
1000006c:	80000000 	or	r0, r0, r0
10000070:	b0000000 	imm	0
10000074:	b9f48350 	brlid	r15, -31920	// 100083c4 <exit>
10000078:	30a30000 	addik	r5, r3, 0

1000007c <_exit>:
1000007c:	b8000000 	bri	0	// 1000007c <_exit>

10000080 <__do_global_dtors_aux>:
10000080:	b0001000 	imm	4096
10000084:	e0608d38 	lbui	r3, r0, -29384	// 10008d38 <_SDA_BASE_>
10000088:	3021ffdc 	addik	r1, r1, -36
1000008c:	f9e10000 	swi	r15, r1, 0
10000090:	fa61001c 	swi	r19, r1, 28
10000094:	be23008c 	bneid	r3, 140		// 10000120
10000098:	fac10020 	swi	r22, r1, 32
1000009c:	b0001000 	imm	4096
100000a0:	32c08d28 	addik	r22, r0, -29400	// 10008d28 <__CTOR_END__>
100000a4:	b0001000 	imm	4096
100000a8:	32608d2c 	addik	r19, r0, -29396	// 10008d2c <__DTOR_END__>
100000ac:	b0001000 	imm	4096
100000b0:	e8608d3c 	lwi	r3, r0, -29380	// 10008d3c <dtor_idx.2340>
100000b4:	16769800 	rsubk	r19, r22, r19
100000b8:	66730202 	bsrai	r19, r19, 2
100000bc:	3273ffff 	addik	r19, r19, -1
100000c0:	14931803 	cmpu	r4, r19, r3
100000c4:	bea40034 	bgeid	r4, 52		// 100000f8
100000c8:	30630001 	addik	r3, r3, 1
100000cc:	64830402 	bslli	r4, r3, 2
100000d0:	c884b000 	lw	r4, r4, r22
100000d4:	b0001000 	imm	4096
100000d8:	f8608d3c 	swi	r3, r0, -29380	// 10008d3c <dtor_idx.2340>
100000dc:	99fc2000 	brald	r15, r4
100000e0:	80000000 	or	r0, r0, r0
100000e4:	b0001000 	imm	4096
100000e8:	e8608d3c 	lwi	r3, r0, -29380	// 10008d3c <dtor_idx.2340>
100000ec:	14931803 	cmpu	r4, r19, r3
100000f0:	be44ffdc 	bltid	r4, -36		// 100000cc
100000f4:	30630001 	addik	r3, r3, 1
100000f8:	b0000000 	imm	0
100000fc:	30600000 	addik	r3, r0, 0
10000100:	bc030014 	beqi	r3, 20		// 10000114
10000104:	b0001000 	imm	4096
10000108:	30a08d30 	addik	r5, r0, -29392	// 10008d30 <__EH_FRAME_BEGIN__>
1000010c:	99fc1800 	brald	r15, r3
10000110:	80000000 	or	r0, r0, r0
10000114:	30600001 	addik	r3, r0, 1
10000118:	b0001000 	imm	4096
1000011c:	f0608d38 	sbi	r3, r0, -29384	// 10008d38 <_SDA_BASE_>
10000120:	e9e10000 	lwi	r15, r1, 0
10000124:	ea61001c 	lwi	r19, r1, 28
10000128:	eac10020 	lwi	r22, r1, 32
1000012c:	b60f0008 	rtsd	r15, 8
10000130:	30210024 	addik	r1, r1, 36

10000134 <frame_dummy>:
10000134:	b0000000 	imm	0
10000138:	30600000 	addik	r3, r0, 0
1000013c:	3021ffe4 	addik	r1, r1, -28
10000140:	be030020 	beqid	r3, 32		// 10000160
10000144:	f9e10000 	swi	r15, r1, 0
10000148:	b0001000 	imm	4096
1000014c:	30a08d30 	addik	r5, r0, -29392	// 10008d30 <__EH_FRAME_BEGIN__>
10000150:	b0001000 	imm	4096
10000154:	30c08d40 	addik	r6, r0, -29376	// 10008d40 <object.2350>
10000158:	99fc1800 	brald	r15, r3
1000015c:	80000000 	or	r0, r0, r0
10000160:	b0001000 	imm	4096
10000164:	e8608d34 	lwi	r3, r0, -29388	// 10008d34 <__JCR_END__>
10000168:	be030028 	beqid	r3, 40		// 10000190
1000016c:	e9e10000 	lwi	r15, r1, 0
10000170:	b0000000 	imm	0
10000174:	30600000 	addik	r3, r0, 0
10000178:	bc030018 	beqi	r3, 24		// 10000190
1000017c:	b0001000 	imm	4096
10000180:	30a08d34 	addik	r5, r0, -29388	// 10008d34 <__JCR_END__>
10000184:	99fc1800 	brald	r15, r3
10000188:	80000000 	or	r0, r0, r0
1000018c:	e9e10000 	lwi	r15, r1, 0
10000190:	b60f0008 	rtsd	r15, 8
10000194:	3021001c 	addik	r1, r1, 28

10000198 <_crtinit>:
10000198:	2021ffec 	addi	r1, r1, -20
1000019c:	f9e10000 	swi	r15, r1, 0
100001a0:	b0001000 	imm	4096
100001a4:	20c08d38 	addi	r6, r0, -29384	// 10008d38 <_SDA_BASE_>
100001a8:	b0001000 	imm	4096
100001ac:	20e08d38 	addi	r7, r0, -29384	// 10008d38 <_SDA_BASE_>
100001b0:	06463800 	rsub	r18, r6, r7
100001b4:	bc720014 	blei	r18, 20		// 100001c8
100001b8:	f8060000 	swi	r0, r6, 0
100001bc:	20c60004 	addi	r6, r6, 4
100001c0:	06463800 	rsub	r18, r6, r7
100001c4:	bc92fff4 	bgti	r18, -12		// 100001b8
100001c8:	b0001000 	imm	4096
100001cc:	20c08d38 	addi	r6, r0, -29384	// 10008d38 <_SDA_BASE_>
100001d0:	b0001000 	imm	4096
100001d4:	20e0e1a8 	addi	r7, r0, -7768	// 1000e1a8 <__bss_end>
100001d8:	06463800 	rsub	r18, r6, r7
100001dc:	bc720014 	blei	r18, 20		// 100001f0
100001e0:	f8060000 	swi	r0, r6, 0
100001e4:	20c60004 	addi	r6, r6, 4
100001e8:	06463800 	rsub	r18, r6, r7
100001ec:	bc92fff4 	bgti	r18, -12		// 100001e0
100001f0:	b0000000 	imm	0
100001f4:	b9f481c8 	brlid	r15, -32312	// 100083bc <_program_init>
100001f8:	80000000 	or	r0, r0, r0
100001fc:	b0000000 	imm	0
10000200:	b9f485d4 	brlid	r15, -31276	// 100087d4 <__init>
10000204:	80000000 	or	r0, r0, r0
10000208:	20c00000 	addi	r6, r0, 0
1000020c:	20e00000 	addi	r7, r0, 0
10000210:	b0000000 	imm	0
10000214:	b9f48540 	brlid	r15, -31424	// 10008754 <main>
10000218:	20a00000 	addi	r5, r0, 0
1000021c:	32630000 	addik	r19, r3, 0
10000220:	b0000000 	imm	0
10000224:	b9f485f0 	brlid	r15, -31248	// 10008814 <__fini>
10000228:	80000000 	or	r0, r0, r0
1000022c:	b0000000 	imm	0
10000230:	b9f48184 	brlid	r15, -32380	// 100083b4 <_program_clean>
10000234:	80000000 	or	r0, r0, r0
10000238:	c9e10000 	lw	r15, r1, r0
1000023c:	30730000 	addik	r3, r19, 0
10000240:	b60f0008 	rtsd	r15, 8
10000244:	20210014 	addi	r1, r1, 20

10000248 <uart_wait_rx_ready>:
void uart_wait_rx_ready(void)
{
  sb_uint32_t flag = (READ_REG32(UART_STATUS_REG) & RX_READY_FLAG_BIT);
  while(flag != RX_READY_FLAG_BIT)
  {
    flag = (READ_REG32(UART_STATUS_REG) & RX_READY_FLAG_BIT);
10000248:	b0002000 	imm	8192
1000024c:	e8600000 	lwi	r3, r0, 0
10000250:	a4630001 	andi	r3, r3, 1
 * \brief Poll the RX ready flag, return when new RX data.
 */
void uart_wait_rx_ready(void)
{
  sb_uint32_t flag = (READ_REG32(UART_STATUS_REG) & RX_READY_FLAG_BIT);
  while(flag != RX_READY_FLAG_BIT)
10000254:	a8630001 	xori	r3, r3, 1
10000258:	bc23fff0 	bnei	r3, -16	// 10000248 <uart_wait_rx_ready>
  {
    flag = (READ_REG32(UART_STATUS_REG) & RX_READY_FLAG_BIT);
  }
}
1000025c:	b60f0008 	rtsd	r15, 8
10000260:	80000000 	or	r0, r0, r0

10000264 <uart_get>:
 * \fn void uart_get(sb_uint8_t *const in)
 * \brief Get byte from the RX line 
 * \param[in,out] in The pointer to the data
 */
void uart_get(sb_uint8_t *const in)
{
10000264:	3021ffe0 	addik	r1, r1, -32
10000268:	f9e10000 	swi	r15, r1, 0
1000026c:	fa61001c 	swi	r19, r1, 28
  uart_wait_rx_ready();
10000270:	b9f4ffd8 	brlid	r15, -40	// 10000248 <uart_wait_rx_ready>
10000274:	12650000 	addk	r19, r5, r0
 * \brief Read data from RX buffer
 * \param[in,out] data The pointer to the data
 */
static __inline__ void uart_read(sb_uint8_t *const data)
{
  *data = (sb_uint8_t)READ_REG32(UART_DATA_RX_REG);
10000278:	b0002000 	imm	8192
1000027c:	e8600004 	lwi	r3, r0, 4
10000280:	f0730000 	sbi	r3, r19, 0
  uart_read(in);
}
10000284:	e9e10000 	lwi	r15, r1, 0
10000288:	ea61001c 	lwi	r19, r1, 28
1000028c:	b60f0008 	rtsd	r15, 8
10000290:	30210020 	addik	r1, r1, 32

10000294 <uart_wait_tx_done>:
void uart_wait_tx_done(void)
{
  sb_uint32_t flag = (READ_REG32(UART_STATUS_REG) & TX_BUSY_FLAG_BIT);
  while(flag == TX_BUSY_FLAG_BIT)
  {
    flag = (READ_REG32(UART_STATUS_REG) & TX_BUSY_FLAG_BIT);
10000294:	b0002000 	imm	8192
10000298:	e8600000 	lwi	r3, r0, 0
1000029c:	a4630002 	andi	r3, r3, 2
 * \brief Poll the TX busy flag, return when TX transfert is finished.
 */
void uart_wait_tx_done(void)
{
  sb_uint32_t flag = (READ_REG32(UART_STATUS_REG) & TX_BUSY_FLAG_BIT);
  while(flag == TX_BUSY_FLAG_BIT)
100002a0:	bc23fff4 	bnei	r3, -12	// 10000294 <uart_wait_tx_done>
  {
    flag = (READ_REG32(UART_STATUS_REG) & TX_BUSY_FLAG_BIT);
  }
}
100002a4:	b60f0008 	rtsd	r15, 8
100002a8:	80000000 	or	r0, r0, r0

100002ac <uart_put>:
 * \fn void uart_put(const sb_uint8_t c)
 * \brief Put byte through the TX line
 * \param[in] c The byte
 */
void uart_put(const sb_uint8_t c)
{
100002ac:	3021ffe4 	addik	r1, r1, -28
100002b0:	f9e10000 	swi	r15, r1, 0
 * \brief Write data to TX buffer
 * \param[in] data The data to write
 */
static __inline__ void uart_write(const sb_uint8_t data)
{
  WRITE_REG32(UART_DATA_TX_REG,data);
100002b4:	b0002000 	imm	8192
100002b8:	f8a0000c 	swi	r5, r0, 12
 * \fn void uart_send(void)
 * \brief Start a TX transfert
 */
static __inline__ void uart_send(void)
{
  WRITE_REG32(UART_CONTROL_REG,SEND_TX_BIT);
100002bc:	30600001 	addik	r3, r0, 1
100002c0:	b0002000 	imm	8192
100002c4:	f8600008 	swi	r3, r0, 8
  uart_write(c);
  uart_send();
  uart_wait_tx_done();
100002c8:	b9f4ffcc 	brlid	r15, -52	// 10000294 <uart_wait_tx_done>
100002cc:	80000000 	or	r0, r0, r0
}
100002d0:	e9e10000 	lwi	r15, r1, 0
100002d4:	b60f0008 	rtsd	r15, 8
100002d8:	3021001c 	addik	r1, r1, 28

100002dc <intc_init>:
{
  sb_int32_t i;
	
  /* reset hardware settings */
  WRITE_REG32(INTC_ARM_REG,0x0);           /* clear all interrupts */
  WRITE_REG32(INTC_MASK_REG,INTC_ID_BANK); /* mask all interrupts */
100002dc:	306000ff 	addik	r3, r0, 255
void intc_init(void)
{
  sb_int32_t i;
	
  /* reset hardware settings */
  WRITE_REG32(INTC_ARM_REG,0x0);           /* clear all interrupts */
100002e0:	b0004000 	imm	16384
100002e4:	f800000c 	swi	r0, r0, 12
  WRITE_REG32(INTC_MASK_REG,INTC_ID_BANK); /* mask all interrupts */
100002e8:	b0004000 	imm	16384
100002ec:	f8600008 	swi	r3, r0, 8
  WRITE_REG32(INTC_POL_REG,INTC_ID_BANK);  /* set active-high interrupts */
100002f0:	b0004000 	imm	16384
100002f4:	f8600010 	swi	r3, r0, 16
	
  /* reset priority table */
  for(i=0;i<MAX_ISR;i++)
  {
    /* default priority = id */
    it_priority_table[i] = i;
100002f8:	30600001 	addik	r3, r0, 1
100002fc:	b0001000 	imm	4096
10000300:	f860cd9c 	swi	r3, r0, -12900
10000304:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
10000308:	b0001000 	imm	4096
1000030c:	f860cda0 	swi	r3, r0, -12896
10000310:	30600003 	addik	r3, r0, 3
10000314:	b0001000 	imm	4096
10000318:	f860cda4 	swi	r3, r0, -12892
1000031c:	30600004 	addik	r3, r0, 4	// 4 <STK_OFFSET_R02>
10000320:	b0001000 	imm	4096
10000324:	f860cda8 	swi	r3, r0, -12888
10000328:	30600005 	addik	r3, r0, 5
1000032c:	b0001000 	imm	4096
10000330:	f860cdac 	swi	r3, r0, -12884
10000334:	30600006 	addik	r3, r0, 6
10000338:	b0001000 	imm	4096
1000033c:	f860cdb0 	swi	r3, r0, -12880
10000340:	30600007 	addik	r3, r0, 7
10000344:	b0001000 	imm	4096
10000348:	f800cd98 	swi	r0, r0, -12904	// 1000cd98 <it_priority_table>
1000034c:	b0001000 	imm	4096
10000350:	f860cdb4 	swi	r3, r0, -12876
  }
}
10000354:	b60f0008 	rtsd	r15, 8
10000358:	80000000 	or	r0, r0, r0

1000035c <intc_attach_handler>:
 * \param[in] handler Handler to attach
 * \param[in,out] callback Handler arg
 */
void intc_attach_handler(const sb_uint32_t interrupt_id, sb_interrupt_handler handler, void *callback)
{
  it_vector_table[interrupt_id].it_handler = handler;
1000035c:	64a50403 	bslli	r5, r5, 3
10000360:	b0001000 	imm	4096
10000364:	f8c5cd58 	swi	r6, r5, -12968
  it_vector_table[interrupt_id].callback = callback;
10000368:	b0001000 	imm	4096
1000036c:	f8e5cd5c 	swi	r7, r5, -12964
}
10000370:	b60f0008 	rtsd	r15, 8
10000374:	80000000 	or	r0, r0, r0

10000378 <BSP_IntHandler>:
/**
 * \fn void primary_int_handler(void) 
 * \brief Processor primary handler
 */
void primary_int_handler(void)
{
10000378:	3021ffd0 	addik	r1, r1, -48
1000037c:	fa61001c 	swi	r19, r1, 28
10000380:	fac10020 	swi	r22, r1, 32
10000384:	fb010028 	swi	r24, r1, 40
10000388:	f9e10000 	swi	r15, r1, 0
1000038c:	fae10024 	swi	r23, r1, 36
10000390:	fb21002c 	swi	r25, r1, 44
  sb_uint32_t int_status;
  sb_uint32_t int_mask;
  sb_uint32_t int_id;
		
  /* read status reg */
  int_status = READ_REG32(INTC_STATUS_REG);
10000394:	b0004000 	imm	16384
10000398:	eb200000 	lwi	r25, r0, 0
#ifdef INTC_FORCE_ACK_FIRST
      /* ack interrupt */
      WRITE_REG32(INTC_ACK_REG,(int_status & int_mask));
#endif
      /* run handler */				
      int_entry = &(it_vector_table[int_id]);          
1000039c:	b0001000 	imm	4096
100003a0:	32c0cd58 	addik	r22, r0, -12968	// 1000cd58 <it_vector_table>
  sb_uint32_t int_status;
  sb_uint32_t int_mask;
  sb_uint32_t int_id;
		
  /* read status reg */
  int_status = READ_REG32(INTC_STATUS_REG);
100003a4:	12600000 	addk	r19, r0, r0
  /* service all interrupts with priority */
  for(i=0;i<MAX_ISR;i++)
  {
    /* get id from priority table */
    int_id = it_priority_table[i];
    int_mask = (1<<int_id);
100003a8:	33000001 	addik	r24, r0, 1
	
  /* service all interrupts with priority */
  for(i=0;i<MAX_ISR;i++)
  {
    /* get id from priority table */
    int_id = it_priority_table[i];
100003ac:	b0001000 	imm	4096
100003b0:	e873cd98 	lwi	r3, r19, -12904
    int_mask = (1<<int_id);
100003b4:	46f81c00 	bsll	r23, r24, r3

    /* interrupt active */
    if(int_status & int_mask)
100003b8:	86f7c800 	and	r23, r23, r25
100003bc:	be170020 	beqid	r23, 32		// 100003dc
100003c0:	64630403 	bslli	r3, r3, 3
#ifdef INTC_FORCE_ACK_FIRST
      /* ack interrupt */
      WRITE_REG32(INTC_ACK_REG,(int_status & int_mask));
#endif
      /* run handler */				
      int_entry = &(it_vector_table[int_id]);          
100003c4:	1083b000 	addk	r4, r3, r22
      int_entry->it_handler(int_entry->callback); 
100003c8:	c8761800 	lw	r3, r22, r3
100003cc:	99fc1800 	brald	r15, r3
100003d0:	e8a40004 	lwi	r5, r4, 4

#ifndef INTC_FORCE_ACK_FIRST 			
      /* ack interrupt */
      WRITE_REG32(INTC_ACK_REG,(int_status & int_mask));
100003d4:	b0004000 	imm	16384
100003d8:	fae00004 	swi	r23, r0, 4
100003dc:	32730004 	addik	r19, r19, 4
		
  /* read status reg */
  int_status = READ_REG32(INTC_STATUS_REG);
	
  /* service all interrupts with priority */
  for(i=0;i<MAX_ISR;i++)
100003e0:	a8730020 	xori	r3, r19, 32
100003e4:	be23ffc8 	bneid	r3, -56		// 100003ac
100003e8:	e9e10000 	lwi	r15, r1, 0
#ifdef INTC_FORCE_ONLY_HIGHEST_PRIORITY
      break;
#endif
    }		
  }	
}
100003ec:	ea61001c 	lwi	r19, r1, 28
100003f0:	eac10020 	lwi	r22, r1, 32
100003f4:	eae10024 	lwi	r23, r1, 36
100003f8:	eb010028 	lwi	r24, r1, 40
100003fc:	eb21002c 	lwi	r25, r1, 44
10000400:	b60f0008 	rtsd	r15, 8
10000404:	30210030 	addik	r1, r1, 48

10000408 <outbyte>:
  int *varg = (int *)((char **)&format);
  return print(&out,varg);
}

void outbyte(char **str, char c)
{
10000408:	3021ffe4 	addik	r1, r1, -28
  if(str) 
1000040c:	be050020 	beqid	r5, 32		// 1000042c
10000410:	f9e10000 	swi	r15, r1, 0
  {
    **str = c;
10000414:	e8650000 	lwi	r3, r5, 0
10000418:	f0c30000 	sbi	r6, r3, 0
    ++(*str);
1000041c:	e8650000 	lwi	r3, r5, 0
10000420:	30630001 	addik	r3, r3, 1
10000424:	b8100010 	brid	16		// 10000434
10000428:	f8650000 	swi	r3, r5, 0
  }
  else 
  {
    uart_put((sb_uint8_t)c); /* UART for standart output */
1000042c:	b9f4fe80 	brlid	r15, -384	// 100002ac <uart_put>
10000430:	a4a600ff 	andi	r5, r6, 255
  }
}
10000434:	e9e10000 	lwi	r15, r1, 0
10000438:	b60f0008 	rtsd	r15, 8
1000043c:	3021001c 	addik	r1, r1, 28

10000440 <prints>:

int prints(char **out, const char *string, int width, int pad)
{
10000440:	3021ffcc 	addik	r1, r1, -52
10000444:	fa61001c 	swi	r19, r1, 28
10000448:	fae10024 	swi	r23, r1, 36
1000044c:	fb010028 	swi	r24, r1, 40
10000450:	fb21002c 	swi	r25, r1, 44
10000454:	f9e10000 	swi	r15, r1, 0
10000458:	fac10020 	swi	r22, r1, 32
1000045c:	fb410030 	swi	r26, r1, 48
10000460:	13250000 	addk	r25, r5, r0
10000464:	13060000 	addk	r24, r6, r0
10000468:	12670000 	addk	r19, r7, r0
  int pc = 0, padchar = ' ';

  if(width > 0)  
1000046c:	10600000 	addk	r3, r0, r0
10000470:	be870010 	bgtid	r7, 16		// 10000480
10000474:	32e00020 	addik	r23, r0, 32	// 20 <STK_OFFSET_R09>
    {
      padchar = '0';
    }
  }
  
  if(!(pad & PAD_RIGHT)) 
10000478:	b810003c 	brid	60		// 100004b4
1000047c:	a5080001 	andi	r8, r8, 1

  if(width > 0)  
  {
    int len = 0;
    const char *ptr;
    for (ptr = string; *ptr; ++ptr) ++len;
10000480:	c083c000 	lbu	r4, r3, r24
10000484:	be24fffc 	bneid	r4, -4		// 10000480
10000488:	30630001 	addik	r3, r3, 1
1000048c:	3063ffff 	addik	r3, r3, -1
    if (len >= width) 
10000490:	14931801 	cmp	r4, r19, r3
    {
      width = 0;
    }
    else 
    {
      width -= len;
10000494:	6484021f 	bsrai	r4, r4, 31
10000498:	16639800 	rsubk	r19, r3, r19
    }
    if(pad & PAD_ZERO) 
1000049c:	a4680002 	andi	r3, r8, 2
    {
      width = 0;
    }
    else 
    {
      width -= len;
100004a0:	86732000 	and	r19, r19, r4
    }
    if(pad & PAD_ZERO) 
100004a4:	be03000c 	beqid	r3, 12		// 100004b0
100004a8:	32e00020 	addik	r23, r0, 32	// 20 <STK_OFFSET_R09>
    {
      padchar = '0';
100004ac:	32e00030 	addik	r23, r0, 48	// 30 <STK_OFFSET_R13>
    }
  }
  
  if(!(pad & PAD_RIGHT)) 
100004b0:	a5080001 	andi	r8, r8, 1
100004b4:	be280038 	bneid	r8, 56		// 100004ec
100004b8:	12c00000 	addk	r22, r0, r0
100004bc:	12d30000 	addk	r22, r19, r0
  {
    for(;width > 0;--width) 
    {
      outbyte(out,padchar);
100004c0:	b8100014 	brid	20		// 100004d4
100004c4:	93570060 	sext8	r26, r23
100004c8:	10da0000 	addk	r6, r26, r0
100004cc:	b9f4ff3c 	brlid	r15, -196	// 10000408 <outbyte>
100004d0:	32d6ffff 	addik	r22, r22, -1
    }
  }
  
  if(!(pad & PAD_RIGHT)) 
  {
    for(;width > 0;--width) 
100004d4:	be96fff4 	bgtid	r22, -12		// 100004c8
100004d8:	10b90000 	addk	r5, r25, r0
  {
    uart_put((sb_uint8_t)c); /* UART for standart output */
  }
}

int prints(char **out, const char *string, int width, int pad)
100004dc:	aad3ffff 	xori	r22, r19, -1
100004e0:	66d6021f 	bsrai	r22, r22, 31
100004e4:	86d3b000 	and	r22, r19, r22
100004e8:	16769800 	rsubk	r19, r22, r19
100004ec:	b8100010 	brid	16		// 100004fc
100004f0:	1716c000 	rsubk	r24, r22, r24
    }
  }
  
  for(;*string;++string) 
  {
    outbyte(out,*string);
100004f4:	b9f4ff14 	brlid	r15, -236	// 10000408 <outbyte>
100004f8:	32d60001 	addik	r22, r22, 1
      outbyte(out,padchar);
      ++pc;
    }
  }
  
  for(;*string;++string) 
100004fc:	c0d6c000 	lbu	r6, r22, r24
10000500:	90c60060 	sext8	r6, r6
10000504:	be26fff0 	bneid	r6, -16		// 100004f4
10000508:	10b90000 	addk	r5, r25, r0
1000050c:	13130000 	addk	r24, r19, r0
    ++pc;
   }
   
  for(;width > 0;--width) 
  {
    outbyte(out,padchar);
10000510:	b8100014 	brid	20		// 10000524
10000514:	92f70060 	sext8	r23, r23
10000518:	10d70000 	addk	r6, r23, r0
1000051c:	b9f4feec 	brlid	r15, -276	// 10000408 <outbyte>
10000520:	3318ffff 	addik	r24, r24, -1
  {
    outbyte(out,*string);
    ++pc;
   }
   
  for(;width > 0;--width) 
10000524:	be98fff4 	bgtid	r24, -12		// 10000518
10000528:	10b90000 	addk	r5, r25, r0
  {
    uart_put((sb_uint8_t)c); /* UART for standart output */
  }
}

int prints(char **out, const char *string, int width, int pad)
1000052c:	a873ffff 	xori	r3, r19, -1
10000530:	6463021f 	bsrai	r3, r3, 31
10000534:	86731800 	and	r19, r19, r3
    outbyte(out,padchar);
    ++pc;
  }

  return pc;
}
10000538:	10769800 	addk	r3, r22, r19
1000053c:	e9e10000 	lwi	r15, r1, 0
10000540:	ea61001c 	lwi	r19, r1, 28
10000544:	eac10020 	lwi	r22, r1, 32
10000548:	eae10024 	lwi	r23, r1, 36
1000054c:	eb010028 	lwi	r24, r1, 40
10000550:	eb21002c 	lwi	r25, r1, 44
10000554:	eb410030 	lwi	r26, r1, 48
10000558:	b60f0008 	rtsd	r15, 8
1000055c:	30210034 	addik	r1, r1, 52

10000560 <printi>:

int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
10000560:	3021ffc0 	addik	r1, r1, -64
10000564:	fac10030 	swi	r22, r1, 48
10000568:	fb010038 	swi	r24, r1, 56
1000056c:	fb21003c 	swi	r25, r1, 60
10000570:	f9e10000 	swi	r15, r1, 0
10000574:	fa61002c 	swi	r19, r1, 44
10000578:	fae10034 	swi	r23, r1, 52
1000057c:	13250000 	addk	r25, r5, r0
10000580:	12c90000 	addk	r22, r9, r0
10000584:	130a0000 	addk	r24, r10, r0
  char print_buf[PRINT_BUF_LEN];
  char *s;
  int t, neg = 0, pc = 0;
  unsigned int u = i;

  if(i == 0) 
10000588:	be26002c 	bneid	r6, 44		// 100005b4
1000058c:	10860000 	addk	r4, r6, r0
  {
    print_buf[0] = '0';
    print_buf[1] = '\0';
    return prints(out,print_buf,width,pad);
10000590:	10e90000 	addk	r7, r9, r0
10000594:	110a0000 	addk	r8, r10, r0
  unsigned int u = i;

  if(i == 0) 
  {
    print_buf[0] = '0';
    print_buf[1] = '\0';
10000598:	f0c1001d 	sbi	r6, r1, 29
  int t, neg = 0, pc = 0;
  unsigned int u = i;

  if(i == 0) 
  {
    print_buf[0] = '0';
1000059c:	30600030 	addik	r3, r0, 48	// 30 <STK_OFFSET_R13>
    print_buf[1] = '\0';
    return prints(out,print_buf,width,pad);
100005a0:	30c1001c 	addik	r6, r1, 28
100005a4:	b9f4fe9c 	brlid	r15, -356	// 10000440 <prints>
100005a8:	f061001c 	sbi	r3, r1, 28
100005ac:	b81000cc 	brid	204		// 10000678
100005b0:	e9e10000 	lwi	r15, r1, 0
  }

  if(sg && b == 10 && i < 0) 
100005b4:	be080024 	beqid	r8, 36		// 100005d8
100005b8:	12e00000 	addk	r23, r0, r0
100005bc:	3060000a 	addik	r3, r0, 10
100005c0:	88671c00 	pcmpeq	r3, r7, r3
100005c4:	be030018 	beqid	r3, 24		// 100005dc
100005c8:	e8a1005c 	lwi	r5, r1, 92
100005cc:	bca60010 	bgei	r6, 16		// 100005dc
  {
    neg = 1;
    u = -i;
100005d0:	14860000 	rsubk	r4, r6, r0
    return prints(out,print_buf,width,pad);
  }

  if(sg && b == 10 && i < 0) 
  {
    neg = 1;
100005d4:	32e00001 	addik	r23, r0, 1
  while(u) 
  {
    t = u % b;
    if(t >= 10)
    {
      t += letbase - '0' - 10;
100005d8:	e8a1005c 	lwi	r5, r1, 92
    neg = 1;
    u = -i;
  }

  s = print_buf + PRINT_BUF_LEN-1;
  *s = '\0';
100005dc:	f001002b 	sbi	r0, r1, 43
  {
    neg = 1;
    u = -i;
  }

  s = print_buf + PRINT_BUF_LEN-1;
100005e0:	3261002b 	addik	r19, r1, 43
  *s = '\0';

  while(u) 
  {
    t = u % b;
    if(t >= 10)
100005e4:	30c00009 	addik	r6, r0, 9
  }

  s = print_buf + PRINT_BUF_LEN-1;
  *s = '\0';

  while(u) 
100005e8:	b8100030 	brid	48		// 10000618
100005ec:	30a5ffc6 	addik	r5, r5, -58
  {
    t = u % b;
100005f0:	48672002 	idivu	r3, r7, r4
100005f4:	41033800 	mul	r8, r3, r7
100005f8:	14882000 	rsubk	r4, r8, r4
    if(t >= 10)
100005fc:	15043001 	cmp	r8, r4, r6
10000600:	bca80008 	bgei	r8, 8		// 10000608
    {
      t += letbase - '0' - 10;
10000604:	10842800 	addk	r4, r4, r5
    }
    *--s = t + '0';
10000608:	30840030 	addik	r4, r4, 48
1000060c:	3273ffff 	addik	r19, r19, -1
10000610:	f0930000 	sbi	r4, r19, 0
    u /= b;
10000614:	10830000 	addk	r4, r3, r0
  }

  s = print_buf + PRINT_BUF_LEN-1;
  *s = '\0';

  while(u) 
10000618:	bc24ffd8 	bnei	r4, -40		// 100005f0
    }
    *--s = t + '0';
    u /= b;
  }

  if(neg) 
1000061c:	be170040 	beqid	r23, 64		// 1000065c
10000620:	10730000 	addk	r3, r19, r0
  {
    if(width && (pad & PAD_ZERO)) 
10000624:	be16002c 	beqid	r22, 44		// 10000650
10000628:	3080002d 	addik	r4, r0, 45
1000062c:	a4980002 	andi	r4, r24, 2
10000630:	be040020 	beqid	r4, 32		// 10000650
10000634:	3080002d 	addik	r4, r0, 45
    {
      outbyte(out, '-');
10000638:	10b90000 	addk	r5, r25, r0
1000063c:	30c0002d 	addik	r6, r0, 45
10000640:	b9f4fdc8 	brlid	r15, -568	// 10000408 <outbyte>
10000644:	32d6ffff 	addik	r22, r22, -1
      ++pc;
     --width;
10000648:	b8100014 	brid	20		// 1000065c
1000064c:	32e00001 	addik	r23, r0, 1
    }
    else 
    {
      *--s = '-';
10000650:	3273ffff 	addik	r19, r19, -1
10000654:	f083ffff 	sbi	r4, r3, -1

int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
  char print_buf[PRINT_BUF_LEN];
  char *s;
  int t, neg = 0, pc = 0;
10000658:	12e00000 	addk	r23, r0, r0
    {
      *--s = '-';
    }
  }

	return pc + prints(out,s,width,pad);
1000065c:	10b90000 	addk	r5, r25, r0
10000660:	10d30000 	addk	r6, r19, r0
10000664:	10f60000 	addk	r7, r22, r0
10000668:	b9f4fdd8 	brlid	r15, -552	// 10000440 <prints>
1000066c:	11180000 	addk	r8, r24, r0
10000670:	10771800 	addk	r3, r23, r3
}
10000674:	e9e10000 	lwi	r15, r1, 0
10000678:	ea61002c 	lwi	r19, r1, 44
1000067c:	eac10030 	lwi	r22, r1, 48
10000680:	eae10034 	lwi	r23, r1, 52
10000684:	eb010038 	lwi	r24, r1, 56
10000688:	eb21003c 	lwi	r25, r1, 60
1000068c:	b60f0008 	rtsd	r15, 8
10000690:	30210040 	addik	r1, r1, 64

10000694 <print>:

int print(char **out, int *varg)
{
10000694:	3021ffc0 	addik	r1, r1, -64
10000698:	fac10028 	swi	r22, r1, 40
1000069c:	fae1002c 	swi	r23, r1, 44
100006a0:	fb010030 	swi	r24, r1, 48
100006a4:	fb210034 	swi	r25, r1, 52
100006a8:	fb410038 	swi	r26, r1, 56
100006ac:	fb61003c 	swi	r27, r1, 60
100006b0:	f9e10000 	swi	r15, r1, 0
100006b4:	fa610024 	swi	r19, r1, 36
100006b8:	13050000 	addk	r24, r5, r0
  int width, pad;
  int pc = 0;
  char *format = (char *)(*varg++);
100006bc:	ea660000 	lwi	r19, r6, 0
100006c0:	32c60004 	addik	r22, r6, 4
}

int print(char **out, int *varg)
{
  int width, pad;
  int pc = 0;
100006c4:	12e00000 	addk	r23, r0, r0
      while (*format == '0') 
      {
        ++format;
        pad |= PAD_ZERO;
      }
      for (;*format >= '0' && *format <= '9';++format) 
100006c8:	33600009 	addik	r27, r0, 9
        pc += printi (out,*varg++,16,0,width,pad,'A');
        continue;
      }
      if( *format == 'u' ) 
      {
        pc += printi(out,*varg++,10,0,width,pad,'a');
100006cc:	33200061 	addik	r25, r0, 97
  int width, pad;
  int pc = 0;
  char *format = (char *)(*varg++);
  char scr[2];

  for(;*format != 0;++format) 
100006d0:	b8100190 	brid	400		// 10000860
100006d4:	33400041 	addik	r26, r0, 65
  {
    if(*format == '%') 
100006d8:	a94a0025 	xori	r10, r10, 37
100006dc:	bc2a016c 	bnei	r10, 364		// 10000848
    {
      ++format;
      width = pad = 0;
      if(*format == '\0') 
100006e0:	e0930001 	lbui	r4, r19, 1
100006e4:	90840060 	sext8	r4, r4
100006e8:	be040184 	beqid	r4, 388		// 1000086c
100006ec:	a8a40025 	xori	r5, r4, 37
      {
        break;
      }
      if(*format == '%') 
100006f0:	be050154 	beqid	r5, 340		// 10000844
100006f4:	30730001 	addik	r3, r19, 1
      {
        goto out;
      }
      if(*format == '-') 
100006f8:	a884002d 	xori	r4, r4, 45
100006fc:	bc24000c 	bnei	r4, 12		// 10000708
      {
        ++format;
10000700:	30730002 	addik	r3, r19, 2
        pad = PAD_RIGHT;
10000704:	31400001 	addik	r10, r0, 1
10000708:	b810000c 	brid	12		// 10000714
1000070c:	12630000 	addk	r19, r3, r0
      }
      while (*format == '0') 
      {
        ++format;
        pad |= PAD_ZERO;
10000710:	a14a0002 	ori	r10, r10, 2
      if(*format == '-') 
      {
        ++format;
        pad = PAD_RIGHT;
      }
      while (*format == '0') 
10000714:	e0730000 	lbui	r3, r19, 0
10000718:	90630060 	sext8	r3, r3
1000071c:	a8630030 	xori	r3, r3, 48
10000720:	be03fff0 	beqid	r3, -16		// 10000710
10000724:	32730001 	addik	r19, r19, 1
10000728:	3273ffff 	addik	r19, r19, -1
1000072c:	b810001c 	brid	28		// 10000748
10000730:	11200000 	addk	r9, r0, r0
        ++format;
        pad |= PAD_ZERO;
      }
      for (;*format >= '0' && *format <= '9';++format) 
      {
        width *= 10;
10000734:	11244800 	addk	r9, r4, r9
10000738:	11294800 	addk	r9, r9, r9
        width += *format - '0';
1000073c:	3063ffd0 	addik	r3, r3, -48
10000740:	11291800 	addk	r9, r9, r3
      while (*format == '0') 
      {
        ++format;
        pad |= PAD_ZERO;
      }
      for (;*format >= '0' && *format <= '9';++format) 
10000744:	32730001 	addik	r19, r19, 1
10000748:	e0930000 	lbui	r4, r19, 0
1000074c:	90640060 	sext8	r3, r4
10000750:	3084ffd0 	addik	r4, r4, -48
10000754:	a48400ff 	andi	r4, r4, 255
10000758:	1484d803 	cmpu	r4, r4, r27
1000075c:	bea4ffd8 	bgeid	r4, -40		// 10000734
10000760:	64890402 	bslli	r4, r9, 2
      {
        width *= 10;
        width += *format - '0';
      }
      if(*format == 's') 
10000764:	a8830073 	xori	r4, r3, 115
10000768:	be240024 	bneid	r4, 36		// 1000078c
1000076c:	a8830064 	xori	r4, r3, 100
      {
        char *s = *((char **)varg++);
10000770:	e8d60000 	lwi	r6, r22, 0
        pc += prints(out, s?s:"(null)",width,pad);
10000774:	be260010 	bneid	r6, 16		// 10000784
10000778:	32d60004 	addik	r22, r22, 4
1000077c:	b0001000 	imm	4096
10000780:	30c08834 	addik	r6, r0, -30668	// 10008834 <__rodata_start>
10000784:	b81000ac 	brid	172		// 10000830
10000788:	10b80000 	addk	r5, r24, r0
        continue;
      }  
      if(*format == 'd') 
1000078c:	be240030 	bneid	r4, 48		// 100007bc
10000790:	a9030078 	xori	r8, r3, 120
      {
        pc += printi(out,*varg++,10,1,width,pad,'a');
10000794:	10b80000 	addk	r5, r24, r0
10000798:	e8d60000 	lwi	r6, r22, 0
1000079c:	30e0000a 	addik	r7, r0, 10
100007a0:	32d60004 	addik	r22, r22, 4
100007a4:	fb21001c 	swi	r25, r1, 28
100007a8:	31000001 	addik	r8, r0, 1
100007ac:	b9f4fdb4 	brlid	r15, -588	// 10000560 <printi>
100007b0:	80000000 	or	r0, r0, r0
        continue;
100007b4:	b81000a8 	brid	168		// 1000085c
100007b8:	12f71800 	addk	r23, r23, r3
      }
      if(*format == 'x') 
100007bc:	bc280014 	bnei	r8, 20		// 100007d0
      {
        pc += printi(out,*varg++,16,0,width,pad,'a');
100007c0:	e8d60000 	lwi	r6, r22, 0
100007c4:	32d60004 	addik	r22, r22, 4
100007c8:	b810001c 	brid	28		// 100007e4
100007cc:	fb21001c 	swi	r25, r1, 28
        continue;
      } 
      if(*format == 'X') 
100007d0:	a9030058 	xori	r8, r3, 88
100007d4:	bc28001c 	bnei	r8, 28		// 100007f0
      {
        pc += printi (out,*varg++,16,0,width,pad,'A');
100007d8:	e8d60000 	lwi	r6, r22, 0
100007dc:	32d60004 	addik	r22, r22, 4
100007e0:	fb41001c 	swi	r26, r1, 28
100007e4:	10b80000 	addk	r5, r24, r0
100007e8:	b810ffc4 	brid	-60		// 100007ac
100007ec:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
        continue;
      }
      if( *format == 'u' ) 
100007f0:	a9030075 	xori	r8, r3, 117
100007f4:	be280020 	bneid	r8, 32		// 10000814
100007f8:	a8630063 	xori	r3, r3, 99
      {
        pc += printi(out,*varg++,10,0,width,pad,'a');
100007fc:	e8d60000 	lwi	r6, r22, 0
10000800:	10b80000 	addk	r5, r24, r0
10000804:	32d60004 	addik	r22, r22, 4
10000808:	fb21001c 	swi	r25, r1, 28
1000080c:	b810ffa0 	brid	-96		// 100007ac
10000810:	30e0000a 	addik	r7, r0, 10
        continue;
      }
      if(*format == 'c') 
10000814:	be230048 	bneid	r3, 72		// 1000085c
10000818:	10b80000 	addk	r5, r24, r0
      {
        scr[0] = *varg++;
1000081c:	e0960003 	lbui	r4, r22, 3
10000820:	32d60004 	addik	r22, r22, 4
10000824:	f0810020 	sbi	r4, r1, 32
        scr[1] = '\0';
10000828:	f0610021 	sbi	r3, r1, 33
        pc += prints(out,scr,width,pad);
1000082c:	30c10020 	addik	r6, r1, 32
10000830:	10e90000 	addk	r7, r9, r0
10000834:	b9f4fc0c 	brlid	r15, -1012	// 10000440 <prints>
10000838:	110a0000 	addk	r8, r10, r0
1000083c:	b8100020 	brid	32		// 1000085c
10000840:	12f71800 	addk	r23, r23, r3

  for(;*format != 0;++format) 
  {
    if(*format == '%') 
    {
      ++format;
10000844:	12630000 	addk	r19, r3, r0
       }
     }
     else 
     {
       out:
       outbyte(out,*format);
10000848:	e0d30000 	lbui	r6, r19, 0
1000084c:	10b80000 	addk	r5, r24, r0
       ++pc;
10000850:	32f70001 	addik	r23, r23, 1
       }
     }
     else 
     {
       out:
       outbyte(out,*format);
10000854:	b9f4fbb4 	brlid	r15, -1100	// 10000408 <outbyte>
10000858:	90c60060 	sext8	r6, r6
  int width, pad;
  int pc = 0;
  char *format = (char *)(*varg++);
  char scr[2];

  for(;*format != 0;++format) 
1000085c:	32730001 	addik	r19, r19, 1
10000860:	e1530000 	lbui	r10, r19, 0
10000864:	914a0060 	sext8	r10, r10
10000868:	bc2afe70 	bnei	r10, -400		// 100006d8
       outbyte(out,*format);
       ++pc;
     }
   }
   
   if(out) 
1000086c:	be180014 	beqid	r24, 20		// 10000880
10000870:	10770000 	addk	r3, r23, r0
   {
     **out = '\0';
10000874:	e8780000 	lwi	r3, r24, 0
10000878:	f0030000 	sbi	r0, r3, 0
   }
   
   return pc;
}
1000087c:	10770000 	addk	r3, r23, r0
10000880:	e9e10000 	lwi	r15, r1, 0
10000884:	ea610024 	lwi	r19, r1, 36
10000888:	eac10028 	lwi	r22, r1, 40
1000088c:	eae1002c 	lwi	r23, r1, 44
10000890:	eb010030 	lwi	r24, r1, 48
10000894:	eb210034 	lwi	r25, r1, 52
10000898:	eb410038 	lwi	r26, r1, 56
1000089c:	eb61003c 	lwi	r27, r1, 60
100008a0:	b60f0008 	rtsd	r15, 8
100008a4:	30210040 	addik	r1, r1, 64

100008a8 <e_sprintf>:
  int *varg = (int *)((char **)&format);
  return print(0,varg);
}

int e_sprintf(char *out, const char *format, ...)
{
100008a8:	f8c10008 	swi	r6, r1, 8
100008ac:	f8e1000c 	swi	r7, r1, 12
100008b0:	f9010010 	swi	r8, r1, 16
100008b4:	f9210014 	swi	r9, r1, 20
100008b8:	f9410018 	swi	r10, r1, 24
100008bc:	3021ffe4 	addik	r1, r1, -28
100008c0:	f8a10020 	swi	r5, r1, 32
100008c4:	f8c10024 	swi	r6, r1, 36
  int *varg = (int *)((char **)&format);
  return print(&out,varg);
100008c8:	30a10020 	addik	r5, r1, 32
  int *varg = (int *)((char **)&format);
  return print(0,varg);
}

int e_sprintf(char *out, const char *format, ...)
{
100008cc:	f9e10000 	swi	r15, r1, 0
  int *varg = (int *)((char **)&format);
  return print(&out,varg);
100008d0:	b9f4fdc4 	brlid	r15, -572	// 10000694 <print>
100008d4:	30c10024 	addik	r6, r1, 36
}
100008d8:	e9e10000 	lwi	r15, r1, 0
100008dc:	b60f0008 	rtsd	r15, 8
100008e0:	3021001c 	addik	r1, r1, 28

100008e4 <e_printf>:
 */

#include "e_printf.h"

int e_printf(const char *format, ...)
{ 
100008e4:	f8a10004 	swi	r5, r1, 4
100008e8:	f8c10008 	swi	r6, r1, 8
100008ec:	f8e1000c 	swi	r7, r1, 12
100008f0:	f9010010 	swi	r8, r1, 16
100008f4:	f9210014 	swi	r9, r1, 20
100008f8:	f9410018 	swi	r10, r1, 24
100008fc:	3021ffe4 	addik	r1, r1, -28
10000900:	f8a10020 	swi	r5, r1, 32
  int *varg = (int *)((char **)&format);
  return print(0,varg);
10000904:	30c10020 	addik	r6, r1, 32
 */

#include "e_printf.h"

int e_printf(const char *format, ...)
{ 
10000908:	f9e10000 	swi	r15, r1, 0
  int *varg = (int *)((char **)&format);
  return print(0,varg);
1000090c:	b9f4fd88 	brlid	r15, -632	// 10000694 <print>
10000910:	10a00000 	addk	r5, r0, r0
}
10000914:	e9e10000 	lwi	r15, r1, 0
10000918:	b60f0008 	rtsd	r15, 8
1000091c:	3021001c 	addik	r1, r1, 28

10000920 <CPU_NameClr>:
*********************************************************************************************************
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameClr (void)
{
10000920:	3021ffe0 	addik	r1, r1, -32
10000924:	f9e10000 	swi	r15, r1, 0
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
10000928:	b9f475f4 	brlid	r15, 30196	// 10007f1c <CPU_SR_Save>
1000092c:	fa61001c 	swi	r19, r1, 28
    Mem_Clr((void     *)&CPU_Name[0],
10000930:	b0001000 	imm	4096
10000934:	30a0cdb8 	addik	r5, r0, -12872	// 1000cdb8 <CPU_Name>
void  CPU_NameClr (void)
{
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
10000938:	12630000 	addk	r19, r3, r0
    Mem_Clr((void     *)&CPU_Name[0],
1000093c:	b9f40638 	brlid	r15, 1592	// 10000f74 <Mem_Clr>
10000940:	30c00010 	addik	r6, r0, 16	// 10 <STK_OFFSET_R05>
            (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
    CPU_CRITICAL_EXIT();
10000944:	b9f475e0 	brlid	r15, 30176	// 10007f24 <CPU_SR_Restore>
10000948:	10b30000 	addk	r5, r19, r0
}
1000094c:	e9e10000 	lwi	r15, r1, 0
10000950:	ea61001c 	lwi	r19, r1, 28
10000954:	b60f0008 	rtsd	r15, 8
10000958:	30210020 	addik	r1, r1, 32

1000095c <CPU_Init>:
*                                                   & other CPU interrupts disabled time measurement functions
*********************************************************************************************************
*/

void  CPU_Init (void)
{
1000095c:	3021ffe4 	addik	r1, r1, -28
10000960:	f9e10000 	swi	r15, r1, 0
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
static  void  CPU_NameInit (void)
{
    CPU_NameClr();
10000964:	b9f4ffbc 	brlid	r15, -68	// 10000920 <CPU_NameClr>
10000968:	80000000 	or	r0, r0, r0

                                                                /* ------------------ INIT CPU NAME ------------------- */
#if (CPU_CFG_NAME_EN == DEF_ENABLED)
     CPU_NameInit();
#endif
}
1000096c:	e9e10000 	lwi	r15, r1, 0
10000970:	b60f0008 	rtsd	r15, 8
10000974:	3021001c 	addik	r1, r1, 28

10000978 <CPU_NameGet>:
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameGet (CPU_CHAR  *p_name,
                   CPU_ERR   *p_err)
{
10000978:	3021ffd8 	addik	r1, r1, -40
1000097c:	fa61001c 	swi	r19, r1, 28
10000980:	fac10020 	swi	r22, r1, 32
10000984:	f9e10000 	swi	r15, r1, 0
10000988:	fae10024 	swi	r23, r1, 36
1000098c:	12c50000 	addk	r22, r5, r0
    CPU_SR_ALLOC();


    if (p_name == (CPU_CHAR *)0) {
10000990:	be250014 	bneid	r5, 20		// 100009a4
10000994:	12660000 	addk	r19, r6, r0
       *p_err = CPU_ERR_NULL_PTR;
10000998:	3060000a 	addik	r3, r0, 10
        return;
1000099c:	b8100034 	brid	52		// 100009d0
100009a0:	f4660000 	shi	r3, r6, 0
    }

    CPU_CRITICAL_ENTER();
100009a4:	b9f47578 	brlid	r15, 30072	// 10007f1c <CPU_SR_Save>
100009a8:	80000000 	or	r0, r0, r0
   (void)Str_Copy_N((CPU_CHAR *) p_name,
100009ac:	10b60000 	addk	r5, r22, r0
100009b0:	b0001000 	imm	4096
100009b4:	30c0cdb8 	addik	r6, r0, -12872	// 1000cdb8 <CPU_Name>
    if (p_name == (CPU_CHAR *)0) {
       *p_err = CPU_ERR_NULL_PTR;
        return;
    }

    CPU_CRITICAL_ENTER();
100009b8:	12e30000 	addk	r23, r3, r0
   (void)Str_Copy_N((CPU_CHAR *) p_name,
100009bc:	b9f40c9c 	brlid	r15, 3228	// 10001658 <Str_Copy_N>
100009c0:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
                    (CPU_CHAR *)&CPU_Name[0],
                    (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
    CPU_CRITICAL_EXIT();
100009c4:	b9f47560 	brlid	r15, 30048	// 10007f24 <CPU_SR_Restore>
100009c8:	10b70000 	addk	r5, r23, r0

   *p_err = CPU_ERR_NONE;
100009cc:	f4130000 	shi	r0, r19, 0
}
100009d0:	e9e10000 	lwi	r15, r1, 0
100009d4:	ea61001c 	lwi	r19, r1, 28
100009d8:	eac10020 	lwi	r22, r1, 32
100009dc:	eae10024 	lwi	r23, r1, 36
100009e0:	b60f0008 	rtsd	r15, 8
100009e4:	30210028 	addik	r1, r1, 40

100009e8 <CPU_NameSet>:
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameSet (CPU_CHAR  *p_name,
                   CPU_ERR   *p_err)
{
100009e8:	3021ffd8 	addik	r1, r1, -40
100009ec:	fa61001c 	swi	r19, r1, 28
100009f0:	fac10020 	swi	r22, r1, 32
100009f4:	f9e10000 	swi	r15, r1, 0
100009f8:	fae10024 	swi	r23, r1, 36
100009fc:	12c50000 	addk	r22, r5, r0
10000a00:	12660000 	addk	r19, r6, r0
    CPU_SIZE_T  len;
    CPU_SR_ALLOC();


    if (p_name == (CPU_CHAR *)0) {
10000a04:	be050050 	beqid	r5, 80		// 10000a54
10000a08:	3060000a 	addik	r3, r0, 10
       *p_err = CPU_ERR_NULL_PTR;
        return;
    }

    len = Str_Len_N((CPU_CHAR *)p_name,
10000a0c:	b9f40bf8 	brlid	r15, 3064	// 10001604 <Str_Len_N>
10000a10:	30c00010 	addik	r6, r0, 16	// 10 <STK_OFFSET_R05>
                    (CPU_SIZE_T)CPU_CFG_NAME_SIZE);
    if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
10000a14:	3080000f 	addik	r4, r0, 15
10000a18:	14632003 	cmpu	r3, r3, r4
10000a1c:	be430038 	bltid	r3, 56		// 10000a54
10000a20:	306003e8 	addik	r3, r0, 1000
        CPU_CRITICAL_ENTER();
10000a24:	b9f474f8 	brlid	r15, 29944	// 10007f1c <CPU_SR_Save>
10000a28:	80000000 	or	r0, r0, r0
       (void)Str_Copy_N((CPU_CHAR *)&CPU_Name[0],               /* ... copy cfg name to CPU host name.                  */
10000a2c:	b0001000 	imm	4096
10000a30:	30a0cdb8 	addik	r5, r0, -12872	// 1000cdb8 <CPU_Name>
10000a34:	10d60000 	addk	r6, r22, r0
    }

    len = Str_Len_N((CPU_CHAR *)p_name,
                    (CPU_SIZE_T)CPU_CFG_NAME_SIZE);
    if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
        CPU_CRITICAL_ENTER();
10000a38:	12e30000 	addk	r23, r3, r0
       (void)Str_Copy_N((CPU_CHAR *)&CPU_Name[0],               /* ... copy cfg name to CPU host name.                  */
10000a3c:	b9f40c1c 	brlid	r15, 3100	// 10001658 <Str_Copy_N>
10000a40:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
                        (CPU_CHAR *) p_name,
                        (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
        CPU_CRITICAL_EXIT();
10000a44:	b9f474e0 	brlid	r15, 29920	// 10007f24 <CPU_SR_Restore>
10000a48:	10b70000 	addk	r5, r23, r0
       *p_err = CPU_ERR_NONE;
10000a4c:	b810000c 	brid	12		// 10000a58
10000a50:	f4130000 	shi	r0, r19, 0

    } else {
       *p_err = CPU_ERR_NAME_SIZE;
10000a54:	f4730000 	shi	r3, r19, 0
    }
}
10000a58:	e9e10000 	lwi	r15, r1, 0
10000a5c:	ea61001c 	lwi	r19, r1, 28
10000a60:	eac10020 	lwi	r22, r1, 32
10000a64:	eae10024 	lwi	r23, r1, 36
10000a68:	b60f0008 	rtsd	r15, 8
10000a6c:	30210028 	addik	r1, r1, 40

10000a70 <CPU_CntLeadZeros>:
        nbr_lead_zeros = (CPU_DATA  )(CPU_CntLeadZerosTbl[ix] +  8u);           /* .. plus nbr msb lead zeros =  8 bits.*/
    }


#elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)                                   /* ---------- 32-BIT DATA VAL --------- */
    if (val > 0x0000FFFFu) {
10000a70:	b0000000 	imm	0
10000a74:	3060ffff 	addik	r3, r0, -1
10000a78:	14651803 	cmpu	r3, r5, r3
10000a7c:	bea30044 	bgeid	r3, 68		// 10000ac0
10000a80:	306000ff 	addik	r3, r0, 255
        if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
10000a84:	b00000ff 	imm	255
10000a88:	3060ffff 	addik	r3, r0, -1
10000a8c:	14651803 	cmpu	r3, r5, r3
10000a90:	bca30018 	bgei	r3, 24		// 10000aa8
                                                                                /* .. Nbr lead zeros =               .. */
            ix             = (CPU_INT08U)(val >> 24u);                          /* .. lookup tbl ix  = 'val' >> 24 bits */
            nbr_lead_zeros = (CPU_DATA  )(CPU_CntLeadZerosTbl[ix] +  0u);       /* .. plus nbr msb lead zeros =  0 bits.*/
10000a94:	64a50018 	bsrli	r5, r5, 24
10000a98:	b0001000 	imm	4096
10000a9c:	e065883c 	lbui	r3, r5, -30660
10000aa0:	b60f0008 	rtsd	r15, 8
10000aa4:	80000000 	or	r0, r0, r0

        } else {                                                                /* Chk bits [23:16] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
            ix             = (CPU_INT08U)(val >> 16u);                          /* .. lookup tbl ix  = 'val' >> 16 bits */
10000aa8:	64a50010 	bsrli	r5, r5, 16
            nbr_lead_zeros = (CPU_DATA  )(CPU_CntLeadZerosTbl[ix] +  8u);       /* .. plus nbr msb lead zeros =  8 bits.*/
10000aac:	a4a500ff 	andi	r5, r5, 255
10000ab0:	b0001000 	imm	4096
10000ab4:	e065883c 	lbui	r3, r5, -30660
10000ab8:	b60f0008 	rtsd	r15, 8
10000abc:	30630008 	addik	r3, r3, 8
        }

    } else {
        if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
10000ac0:	14651803 	cmpu	r3, r5, r3
10000ac4:	bca3001c 	bgei	r3, 28		// 10000ae0
                                                                                /* .. Nbr lead zeros =               .. */
            ix             = (CPU_INT08U)(val >>  8u);                          /* .. lookup tbl ix  = 'val' >>  8 bits */
10000ac8:	64a50008 	bsrli	r5, r5, 8
            nbr_lead_zeros = (CPU_DATA  )(CPU_CntLeadZerosTbl[ix] + 16u);       /* .. plus nbr msb lead zeros = 16 bits.*/
10000acc:	a4a500ff 	andi	r5, r5, 255
10000ad0:	b0001000 	imm	4096
10000ad4:	e065883c 	lbui	r3, r5, -30660
10000ad8:	b60f0008 	rtsd	r15, 8
10000adc:	30630010 	addik	r3, r3, 16

        } else {                                                                /* Chk bits [07:00] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
            ix             = (CPU_INT08U)(val >>  0u);                          /* .. lookup tbl ix  = 'val' >>  0 bits */
            nbr_lead_zeros = (CPU_DATA  )(CPU_CntLeadZerosTbl[ix] + 24u);       /* .. plus nbr msb lead zeros = 24 bits.*/
10000ae0:	a4a500ff 	andi	r5, r5, 255
10000ae4:	b0001000 	imm	4096
10000ae8:	e065883c 	lbui	r3, r5, -30660
   (void)&ix;
    nbr_lead_zeros = 0u;
#endif

    return (nbr_lead_zeros);
}
10000aec:	b60f0008 	rtsd	r15, 8
10000af0:	30630018 	addik	r3, r3, 24

10000af4 <ASCII_IsAlpha>:
CPU_BOOLEAN  ASCII_IsAlpha (CPU_CHAR  c)
{
    CPU_BOOLEAN  alpha;


    alpha = ASCII_IS_ALPHA(c);
10000af4:	a4a500ff 	andi	r5, r5, 255
10000af8:	3085ff9f 	addik	r4, r5, -97
10000afc:	30a5ffbf 	addik	r5, r5, -65
10000b00:	30600019 	addik	r3, r0, 25
10000b04:	a4a500ff 	andi	r5, r5, 255
10000b08:	a48400ff 	andi	r4, r4, 255
10000b0c:	14841803 	cmpu	r4, r4, r3
10000b10:	14651803 	cmpu	r3, r5, r3
10000b14:	84632000 	and	r3, r3, r4
10000b18:	a863ffff 	xori	r3, r3, -1

    return (alpha);
}
10000b1c:	b60f0008 	rtsd	r15, 8
10000b20:	6463001f 	bsrli	r3, r3, 31

10000b24 <ASCII_IsAlphaNum>:
CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
{
    CPU_BOOLEAN  alpha_num;


    alpha_num = ASCII_IS_ALPHA_NUM(c);
10000b24:	a4a500ff 	andi	r5, r5, 255
10000b28:	3085ff9f 	addik	r4, r5, -97
10000b2c:	a48400ff 	andi	r4, r4, 255
10000b30:	30600019 	addik	r3, r0, 25
10000b34:	14841803 	cmpu	r4, r4, r3
10000b38:	bea40030 	bgeid	r4, 48		// 10000b68
10000b3c:	3085ffbf 	addik	r4, r5, -65
10000b40:	a48400ff 	andi	r4, r4, 255
10000b44:	14641803 	cmpu	r3, r4, r3
10000b48:	bea30020 	bgeid	r3, 32		// 10000b68
10000b4c:	30a5ffd0 	addik	r5, r5, -48
10000b50:	a4a500ff 	andi	r5, r5, 255
10000b54:	30600009 	addik	r3, r0, 9
10000b58:	14651803 	cmpu	r3, r5, r3
10000b5c:	a863ffff 	xori	r3, r3, -1
10000b60:	b60f0008 	rtsd	r15, 8
10000b64:	6463001f 	bsrli	r3, r3, 31

    return (alpha_num);
}
10000b68:	b60f0008 	rtsd	r15, 8
10000b6c:	30600001 	addik	r3, r0, 1

10000b70 <ASCII_IsLower>:
CPU_BOOLEAN  ASCII_IsLower (CPU_CHAR  c)
{
    CPU_BOOLEAN  lower;


    lower = ASCII_IS_LOWER(c);
10000b70:	30a5ff9f 	addik	r5, r5, -97
10000b74:	a4a500ff 	andi	r5, r5, 255
10000b78:	30600019 	addik	r3, r0, 25
10000b7c:	14651803 	cmpu	r3, r5, r3
10000b80:	a863ffff 	xori	r3, r3, -1

    return (lower);
}
10000b84:	b60f0008 	rtsd	r15, 8
10000b88:	6463001f 	bsrli	r3, r3, 31

10000b8c <ASCII_IsUpper>:
CPU_BOOLEAN  ASCII_IsUpper (CPU_CHAR  c)
{
    CPU_BOOLEAN  upper;


    upper = ASCII_IS_UPPER(c);
10000b8c:	30a5ffbf 	addik	r5, r5, -65
10000b90:	a4a500ff 	andi	r5, r5, 255
10000b94:	30600019 	addik	r3, r0, 25
10000b98:	14651803 	cmpu	r3, r5, r3
10000b9c:	a863ffff 	xori	r3, r3, -1

    return (upper);
}
10000ba0:	b60f0008 	rtsd	r15, 8
10000ba4:	6463001f 	bsrli	r3, r3, 31

10000ba8 <ASCII_IsDig>:
CPU_BOOLEAN  ASCII_IsDig (CPU_CHAR  c)
{
    CPU_BOOLEAN  dig;


    dig = ASCII_IS_DIG(c);
10000ba8:	30a5ffd0 	addik	r5, r5, -48
10000bac:	a4a500ff 	andi	r5, r5, 255
10000bb0:	30600009 	addik	r3, r0, 9
10000bb4:	14651803 	cmpu	r3, r5, r3
10000bb8:	a863ffff 	xori	r3, r3, -1

    return (dig);
}
10000bbc:	b60f0008 	rtsd	r15, 8
10000bc0:	6463001f 	bsrli	r3, r3, 31

10000bc4 <ASCII_IsDigOct>:
CPU_BOOLEAN  ASCII_IsDigOct (CPU_CHAR  c)
{
    CPU_BOOLEAN  dig_oct;


    dig_oct = ASCII_IS_DIG_OCT(c);
10000bc4:	30a5ffd0 	addik	r5, r5, -48
10000bc8:	a4a500ff 	andi	r5, r5, 255
10000bcc:	30600007 	addik	r3, r0, 7
10000bd0:	14651803 	cmpu	r3, r5, r3
10000bd4:	a863ffff 	xori	r3, r3, -1

    return (dig_oct);
}
10000bd8:	b60f0008 	rtsd	r15, 8
10000bdc:	6463001f 	bsrli	r3, r3, 31

10000be0 <ASCII_IsDigHex>:
CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
{
    CPU_BOOLEAN  dig_hex;


    dig_hex = ASCII_IS_DIG_HEX(c);
10000be0:	a4a500ff 	andi	r5, r5, 255
10000be4:	3065ffbf 	addik	r3, r5, -65
10000be8:	a46300ff 	andi	r3, r3, 255
10000bec:	30800005 	addik	r4, r0, 5
10000bf0:	14632003 	cmpu	r3, r3, r4
10000bf4:	bea30030 	bgeid	r3, 48		// 10000c24
10000bf8:	30c00009 	addik	r6, r0, 9
10000bfc:	3065ffd0 	addik	r3, r5, -48
10000c00:	a46300ff 	andi	r3, r3, 255
10000c04:	14633003 	cmpu	r3, r3, r6
10000c08:	bca3001c 	bgei	r3, 28		// 10000c24
10000c0c:	3065ff9f 	addik	r3, r5, -97
10000c10:	a46300ff 	andi	r3, r3, 255
10000c14:	14632003 	cmpu	r3, r3, r4
10000c18:	a863ffff 	xori	r3, r3, -1
10000c1c:	b60f0008 	rtsd	r15, 8
10000c20:	6463001f 	bsrli	r3, r3, 31

    return (dig_hex);
}
10000c24:	b60f0008 	rtsd	r15, 8
10000c28:	30600001 	addik	r3, r0, 1

10000c2c <ASCII_IsBlank>:
CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
{
    CPU_BOOLEAN  blank;


    blank = ASCII_IS_BLANK(c);
10000c2c:	30800020 	addik	r4, r0, 32	// 20 <STK_OFFSET_R09>
10000c30:	30600009 	addik	r3, r0, 9
10000c34:	88651c00 	pcmpeq	r3, r5, r3
10000c38:	88a52400 	pcmpeq	r5, r5, r4

    return (blank);
}
10000c3c:	b60f0008 	rtsd	r15, 8
10000c40:	80632800 	or	r3, r3, r5

10000c44 <ASCII_IsSpace>:
CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
{
    CPU_BOOLEAN  space;


    space = ASCII_IS_SPACE(c);
10000c44:	3060000d 	addik	r3, r0, 13
10000c48:	88651c00 	pcmpeq	r3, r5, r3
10000c4c:	bc230040 	bnei	r3, 64		// 10000c8c
10000c50:	30600020 	addik	r3, r0, 32	// 20 <STK_OFFSET_R09>
10000c54:	88651c00 	pcmpeq	r3, r5, r3
10000c58:	bc230034 	bnei	r3, 52		// 10000c8c
10000c5c:	3060000c 	addik	r3, r0, 12	// c <STK_OFFSET_R04>
10000c60:	88651c00 	pcmpeq	r3, r5, r3
10000c64:	bc230030 	bnei	r3, 48		// 10000c94
10000c68:	3060000a 	addik	r3, r0, 10
10000c6c:	88651c00 	pcmpeq	r3, r5, r3
10000c70:	be230024 	bneid	r3, 36		// 10000c94
10000c74:	30800009 	addik	r4, r0, 9
10000c78:	3060000b 	addik	r3, r0, 11
10000c7c:	88651c00 	pcmpeq	r3, r5, r3
10000c80:	88a52400 	pcmpeq	r5, r5, r4
10000c84:	b60f0008 	rtsd	r15, 8
10000c88:	80632800 	or	r3, r3, r5
10000c8c:	b60f0008 	rtsd	r15, 8
10000c90:	30600001 	addik	r3, r0, 1

    return (space);
}
10000c94:	b60f0008 	rtsd	r15, 8
10000c98:	30600001 	addik	r3, r0, 1

10000c9c <ASCII_IsPrint>:
CPU_BOOLEAN  ASCII_IsPrint (CPU_CHAR  c)
{
    CPU_BOOLEAN  print;


    print = ASCII_IS_PRINT(c);
10000c9c:	30a5ffe0 	addik	r5, r5, -32
10000ca0:	a4a500ff 	andi	r5, r5, 255
10000ca4:	3060005e 	addik	r3, r0, 94
10000ca8:	14651803 	cmpu	r3, r5, r3
10000cac:	a863ffff 	xori	r3, r3, -1

    return (print);
}
10000cb0:	b60f0008 	rtsd	r15, 8
10000cb4:	6463001f 	bsrli	r3, r3, 31

10000cb8 <ASCII_IsGraph>:
CPU_BOOLEAN  ASCII_IsGraph (CPU_CHAR  c)
{
    CPU_BOOLEAN  graph;


    graph = ASCII_IS_GRAPH(c);
10000cb8:	30a5ffdf 	addik	r5, r5, -33
10000cbc:	a4a500ff 	andi	r5, r5, 255
10000cc0:	3060005d 	addik	r3, r0, 93
10000cc4:	14651803 	cmpu	r3, r5, r3
10000cc8:	a863ffff 	xori	r3, r3, -1

    return (graph);
}
10000ccc:	b60f0008 	rtsd	r15, 8
10000cd0:	6463001f 	bsrli	r3, r3, 31

10000cd4 <ASCII_IsPunct>:
CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
{
    CPU_BOOLEAN  punct;


    punct = ASCII_IS_PUNCT(c);
10000cd4:	a48500ff 	andi	r4, r5, 255
10000cd8:	30c4ffe0 	addik	r6, r4, -32
10000cdc:	3060005e 	addik	r3, r0, 94
10000ce0:	a4c600ff 	andi	r6, r6, 255
10000ce4:	14c61803 	cmpu	r6, r6, r3
10000ce8:	be460050 	bltid	r6, 80		// 10000d38
10000cec:	10600000 	addk	r3, r0, r0
10000cf0:	a8650020 	xori	r3, r5, 32
10000cf4:	be030044 	beqid	r3, 68		// 10000d38
10000cf8:	30a4ff9f 	addik	r5, r4, -97
10000cfc:	a4a500ff 	andi	r5, r5, 255
10000d00:	30600019 	addik	r3, r0, 25
10000d04:	14a51803 	cmpu	r5, r5, r3
10000d08:	bea5002c 	bgeid	r5, 44		// 10000d34
10000d0c:	30a4ffbf 	addik	r5, r4, -65
10000d10:	a4a500ff 	andi	r5, r5, 255
10000d14:	14651803 	cmpu	r3, r5, r3
10000d18:	bea3001c 	bgeid	r3, 28		// 10000d34
10000d1c:	3084ffd0 	addik	r4, r4, -48
* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
*                   printing character for which neither isspace() nor isalnum() is true".
*********************************************************************************************************
*/

CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
10000d20:	a48400ff 	andi	r4, r4, 255
10000d24:	30600009 	addik	r3, r0, 9
10000d28:	14641803 	cmpu	r3, r4, r3
{
    CPU_BOOLEAN  punct;


    punct = ASCII_IS_PUNCT(c);
10000d2c:	b60f0008 	rtsd	r15, 8
10000d30:	6463001f 	bsrli	r3, r3, 31
10000d34:	10600000 	addk	r3, r0, r0

    return (punct);
}
10000d38:	b60f0008 	rtsd	r15, 8
10000d3c:	80000000 	or	r0, r0, r0

10000d40 <ASCII_IsCtrl>:
CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
{
    CPU_BOOLEAN  ctrl;


    ctrl = ASCII_IS_CTRL(c);
10000d40:	a46500ff 	andi	r3, r5, 255
10000d44:	3080001f 	addik	r4, r0, 31
10000d48:	14632003 	cmpu	r3, r3, r4
10000d4c:	a863ffff 	xori	r3, r3, -1
10000d50:	3080007f 	addik	r4, r0, 127
10000d54:	6463001f 	bsrli	r3, r3, 31
10000d58:	88a52400 	pcmpeq	r5, r5, r4

    return (ctrl);
}
10000d5c:	b60f0008 	rtsd	r15, 8
10000d60:	80632800 	or	r3, r3, r5

10000d64 <ASCII_ToLower>:
CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
{
    CPU_CHAR  lower;


    lower = ASCII_TO_LOWER(c);
10000d64:	a48500ff 	andi	r4, r5, 255
10000d68:	30c4ffbf 	addik	r6, r4, -65
10000d6c:	30600019 	addik	r3, r0, 25
10000d70:	a4c600ff 	andi	r6, r6, 255
10000d74:	14c61803 	cmpu	r6, r6, r3
10000d78:	be460010 	bltid	r6, 16		// 10000d88
10000d7c:	10650000 	addk	r3, r5, r0
10000d80:	30640020 	addik	r3, r4, 32
10000d84:	90630060 	sext8	r3, r3

    return (lower);
}
10000d88:	b60f0008 	rtsd	r15, 8
10000d8c:	80000000 	or	r0, r0, r0

10000d90 <ASCII_ToUpper>:
CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
{
    CPU_CHAR  upper;


    upper = ASCII_TO_UPPER(c);
10000d90:	a48500ff 	andi	r4, r5, 255
10000d94:	30c4ff9f 	addik	r6, r4, -97
10000d98:	30600019 	addik	r3, r0, 25
10000d9c:	a4c600ff 	andi	r6, r6, 255
10000da0:	14c61803 	cmpu	r6, r6, r3
10000da4:	be460010 	bltid	r6, 16		// 10000db4
10000da8:	10650000 	addk	r3, r5, r0
10000dac:	3064ffe0 	addik	r3, r4, -32
10000db0:	90630060 	sext8	r3, r3

    return (upper);
}
10000db4:	b60f0008 	rtsd	r15, 8
10000db8:	80000000 	or	r0, r0, r0

10000dbc <ASCII_Cmp>:
    CPU_CHAR     c1_upper;
    CPU_CHAR     c2_upper;
    CPU_BOOLEAN  cmp;


    c1_upper =  ASCII_TO_UPPER(c1);
10000dbc:	a46500ff 	andi	r3, r5, 255
10000dc0:	3083ff9f 	addik	r4, r3, -97
10000dc4:	a48400ff 	andi	r4, r4, 255
10000dc8:	30e00019 	addik	r7, r0, 25
10000dcc:	14843803 	cmpu	r4, r4, r7
10000dd0:	bc44000c 	blti	r4, 12		// 10000ddc
10000dd4:	30a3ffe0 	addik	r5, r3, -32
10000dd8:	90a50060 	sext8	r5, r5
    c2_upper =  ASCII_TO_UPPER(c2);
10000ddc:	a46600ff 	andi	r3, r6, 255
10000de0:	3083ff9f 	addik	r4, r3, -97
10000de4:	a48400ff 	andi	r4, r4, 255
10000de8:	30e00019 	addik	r7, r0, 25
10000dec:	14843803 	cmpu	r4, r4, r7
10000df0:	bc44000c 	blti	r4, 12		// 10000dfc
10000df4:	30c3ffe0 	addik	r6, r3, -32
10000df8:	90c60060 	sext8	r6, r6
    cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);

    return (cmp);
}
10000dfc:	b60f0008 	rtsd	r15, 8
10000e00:	88653400 	pcmpeq	r3, r5, r6

10000e04 <Math_RandSetSeed>:
*                   See also 'Math_Rand()  Note #1b'.
*********************************************************************************************************
*/

void  Math_RandSetSeed (RAND_NBR  seed)
{
10000e04:	3021ffe0 	addik	r1, r1, -32
10000e08:	f9e10000 	swi	r15, r1, 0
10000e0c:	fa61001c 	swi	r19, r1, 28
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
10000e10:	b9f4710c 	brlid	r15, 28940	// 10007f1c <CPU_SR_Save>
10000e14:	12650000 	addk	r19, r5, r0
    Math_RandSeedCur = seed;
10000e18:	b0001000 	imm	4096
10000e1c:	fa60cdc8 	swi	r19, r0, -12856	// 1000cdc8 <Math_RandSeedCur>
    CPU_CRITICAL_EXIT();
10000e20:	b9f47104 	brlid	r15, 28932	// 10007f24 <CPU_SR_Restore>
10000e24:	10a30000 	addk	r5, r3, r0
}
10000e28:	e9e10000 	lwi	r15, r1, 0
10000e2c:	ea61001c 	lwi	r19, r1, 28
10000e30:	b60f0008 	rtsd	r15, 8
10000e34:	30210020 	addik	r1, r1, 32

10000e38 <Math_Init>:
*                   as when srand() is first called with a seed value of 1".
*********************************************************************************************************
*/

void  Math_Init (void)
{
10000e38:	3021ffe4 	addik	r1, r1, -28
10000e3c:	f9e10000 	swi	r15, r1, 0
    Math_RandSetSeed((RAND_NBR)RAND_SEED_INIT_VAL);             /* See Note #2.                                         */
10000e40:	b9f4ffc4 	brlid	r15, -60	// 10000e04 <Math_RandSetSeed>
10000e44:	30a00001 	addik	r5, r0, 1
}
10000e48:	e9e10000 	lwi	r15, r1, 0
10000e4c:	b60f0008 	rtsd	r15, 8
10000e50:	3021001c 	addik	r1, r1, 28

10000e54 <Math_Rand>:
*                   See also 'Math_RandSeed()  Note #2'.
*********************************************************************************************************
*/

RAND_NBR  Math_Rand (void)
{
10000e54:	3021ffe0 	addik	r1, r1, -32
10000e58:	f9e10000 	swi	r15, r1, 0
    RAND_NBR  seed;
    RAND_NBR  rand_nbr;
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
10000e5c:	b9f470c0 	brlid	r15, 28864	// 10007f1c <CPU_SR_Save>
10000e60:	fa61001c 	swi	r19, r1, 28
RAND_NBR  Math_RandSeed (RAND_NBR  seed)
{
    RAND_NBR  rand_nbr;


    rand_nbr = (((RAND_NBR)RAND_LCG_PARAM_A * seed) + (RAND_NBR)RAND_LCG_PARAM_B)  %  ((RAND_NBR)RAND_LCG_PARAM_M + 1u);
10000e64:	b0001000 	imm	4096
10000e68:	ea60cdc8 	lwi	r19, r0, -12856	// 1000cdc8 <Math_RandSeedCur>
10000e6c:	b00041c6 	imm	16838
10000e70:	62734e6d 	muli	r19, r19, 20077
10000e74:	32733039 	addik	r19, r19, 12345
10000e78:	b0007fff 	imm	32767
10000e7c:	a673ffff 	andi	r19, r19, -1


    CPU_CRITICAL_ENTER();
    seed             = Math_RandSeedCur;
    rand_nbr         = Math_RandSeed(seed);
    Math_RandSeedCur = rand_nbr;
10000e80:	b0001000 	imm	4096
10000e84:	fa60cdc8 	swi	r19, r0, -12856	// 1000cdc8 <Math_RandSeedCur>
    CPU_CRITICAL_EXIT();
10000e88:	b9f4709c 	brlid	r15, 28828	// 10007f24 <CPU_SR_Restore>
10000e8c:	10a30000 	addk	r5, r3, r0

    return (rand_nbr);
}
10000e90:	10730000 	addk	r3, r19, r0
10000e94:	e9e10000 	lwi	r15, r1, 0
10000e98:	ea61001c 	lwi	r19, r1, 28
10000e9c:	b60f0008 	rtsd	r15, 8
10000ea0:	30210020 	addik	r1, r1, 32

10000ea4 <Math_RandSeed>:
RAND_NBR  Math_RandSeed (RAND_NBR  seed)
{
    RAND_NBR  rand_nbr;


    rand_nbr = (((RAND_NBR)RAND_LCG_PARAM_A * seed) + (RAND_NBR)RAND_LCG_PARAM_B)  %  ((RAND_NBR)RAND_LCG_PARAM_M + 1u);
10000ea4:	b00041c6 	imm	16838
10000ea8:	60654e6d 	muli	r3, r5, 20077
10000eac:	30633039 	addik	r3, r3, 12345

    return (rand_nbr);
}
10000eb0:	b0007fff 	imm	32767
10000eb4:	a463ffff 	andi	r3, r3, -1
10000eb8:	b60f0008 	rtsd	r15, 8
10000ebc:	80000000 	or	r0, r0, r0

10000ec0 <Mem_Init>:
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;

                                                                        /* ------------ INIT MEM POOL TBL ------------- */
    Mem_PoolTbl = &Mem_PoolHeap;
#endif
}
10000ec0:	b60f0008 	rtsd	r15, 8
10000ec4:	80000000 	or	r0, r0, r0

10000ec8 <Mem_Set>:
    CPU_INT08U  *pmem_08;
    CPU_INT08U   mem_align_modulo;
    CPU_INT08U   i;


    if (size < 1u) {                                            /* See Note #1.                                         */
10000ec8:	bc0700a4 	beqi	r7, 164		// 10000f6c
        return;
    }
    if (pmem == (void *)0) {
10000ecc:	be0500a0 	beqid	r5, 160		// 10000f6c
10000ed0:	65260408 	bslli	r9, r6, 8


    data_align = 0u;
    for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        data_align <<=  DEF_OCTET_NBR_BITS;
        data_align  |= (CPU_ALIGN)data_val;
10000ed4:	81293000 	or	r9, r9, r6
    }


    data_align = 0u;
    for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        data_align <<=  DEF_OCTET_NBR_BITS;
10000ed8:	65290408 	bslli	r9, r9, 8
        data_align  |= (CPU_ALIGN)data_val;
10000edc:	81293000 	or	r9, r9, r6
    }


    data_align = 0u;
    for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        data_align <<=  DEF_OCTET_NBR_BITS;
10000ee0:	65290408 	bslli	r9, r9, 8
        data_align  |= (CPU_ALIGN)data_val;
    }

    size_rem         = (CPU_SIZE_T)size;
    mem_align_modulo = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));    /* See Note #3.                             */
10000ee4:	a4650003 	andi	r3, r5, 3

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
10000ee8:	be03003c 	beqid	r3, 60		// 10000f24
10000eec:	81293000 	or	r9, r9, r6
        i = mem_align_modulo;
        while ((size_rem > 0u) &&                               /* ... start mem buf fill with leading octets ...       */
               (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
10000ef0:	31000003 	addik	r8, r0, 3
    mem_align_modulo = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));    /* See Note #3.                             */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
        i = mem_align_modulo;
        while ((size_rem > 0u) &&                               /* ... start mem buf fill with leading octets ...       */
10000ef4:	b8100018 	brid	24		// 10000f0c
10000ef8:	10800000 	addk	r4, r0, r0
               (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
           *pmem_08++ = data_val;
10000efc:	f0c50000 	sbi	r6, r5, 0
            size_rem -= sizeof(CPU_INT08U);
10000f00:	30e7ffff 	addik	r7, r7, -1
    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
        i = mem_align_modulo;
        while ((size_rem > 0u) &&                               /* ... start mem buf fill with leading octets ...       */
               (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
           *pmem_08++ = data_val;
10000f04:	30a50001 	addik	r5, r5, 1
            size_rem -= sizeof(CPU_INT08U);
            i++;
10000f08:	a46300ff 	andi	r3, r3, 255

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
        i = mem_align_modulo;
        while ((size_rem > 0u) &&                               /* ... start mem buf fill with leading octets ...       */
               (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
10000f0c:	15434003 	cmpu	r10, r3, r8
10000f10:	be4a0014 	bltid	r10, 20		// 10000f24
10000f14:	8d472400 	pcmpne	r10, r7, r4
    mem_align_modulo = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));    /* See Note #3.                             */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
        i = mem_align_modulo;
        while ((size_rem > 0u) &&                               /* ... start mem buf fill with leading octets ...       */
10000f18:	be2affe4 	bneid	r10, -28		// 10000efc
10000f1c:	30630001 	addik	r3, r3, 1
10000f20:	3063ffff 	addik	r3, r3, -1

    size_rem         = (CPU_SIZE_T)size;
    mem_align_modulo = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));    /* See Note #3.                             */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_modulo != 0u) {                               /* If leading octets avail,                   ...       */
10000f24:	10850000 	addk	r4, r5, r0
10000f28:	10670000 	addk	r3, r7, r0
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
10000f2c:	b8100014 	brid	20		// 10000f40
10000f30:	31000003 	addik	r8, r0, 3
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
10000f34:	f9240000 	swi	r9, r4, 0
        size_rem    -= sizeof(CPU_ALIGN);
10000f38:	3063fffc 	addik	r3, r3, -4
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
10000f3c:	30840004 	addik	r4, r4, 4
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
10000f40:	15434003 	cmpu	r10, r3, r8
10000f44:	bc4afff0 	blti	r10, -16		// 10000f34
10000f48:	a4870003 	andi	r4, r7, 3
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                   mem_align_modulo arithmetic operation.
*********************************************************************************************************
*/

void  Mem_Set (void        *pmem,
10000f4c:	a4e7fffc 	andi	r7, r7, -4
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
10000f50:	10a53800 	addk	r5, r5, r7
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                   mem_align_modulo arithmetic operation.
*********************************************************************************************************
*/

void  Mem_Set (void        *pmem,
10000f54:	b8100010 	brid	16		// 10000f64
10000f58:	10600000 	addk	r3, r0, r0
        size_rem    -= sizeof(CPU_ALIGN);
    }

    pmem_08 = (CPU_INT08U *)pmem_align;
    while (size_rem > 0u) {                                     /* Finish mem buf fill with trailing octets.            */
       *pmem_08++   = data_val;
10000f5c:	d0c32800 	sb	r6, r3, r5
10000f60:	30630001 	addik	r3, r3, 1
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
        size_rem    -= sizeof(CPU_ALIGN);
    }

    pmem_08 = (CPU_INT08U *)pmem_align;
    while (size_rem > 0u) {                                     /* Finish mem buf fill with trailing octets.            */
10000f64:	88e32000 	xor	r7, r3, r4
10000f68:	bc27fff4 	bnei	r7, -12		// 10000f5c
10000f6c:	b60f0008 	rtsd	r15, 8
10000f70:	80000000 	or	r0, r0, r0

10000f74 <Mem_Clr>:
*********************************************************************************************************
*/

void  Mem_Clr (void        *pmem,
               CPU_SIZE_T   size)
{
10000f74:	10e60000 	addk	r7, r6, r0
10000f78:	3021ffe4 	addik	r1, r1, -28
10000f7c:	f9e10000 	swi	r15, r1, 0
    Mem_Set((void     *)pmem,
10000f80:	b9f4ff48 	brlid	r15, -184	// 10000ec8 <Mem_Set>
10000f84:	10c00000 	addk	r6, r0, r0
            (CPU_INT08U)0u,                                     /* See Note #2.                                         */
            (CPU_SIZE_T)size);
}
10000f88:	e9e10000 	lwi	r15, r1, 0
10000f8c:	b60f0008 	rtsd	r15, 8
10000f90:	3021001c 	addik	r1, r1, 28

10000f94 <Mem_Copy>:
    CPU_INT08U    mem_align_modulo_dest;
    CPU_INT08U    mem_align_modulo_src;
    CPU_BOOLEAN   mem_aligned;


    if (size < 1u) {                                            /* See Note #1.                                         */
10000f94:	bc0700b0 	beqi	r7, 176		// 10001044
        return;
    }
    if (pdest == (void *)0) {
10000f98:	bc0500ac 	beqi	r5, 172		// 10001044
        return;
    }
    if (psrc  == (void *)0) {
10000f9c:	bc0600a8 	beqi	r6, 168		// 10001044
    size_rem              = (CPU_SIZE_T  )size;

    pmem_08_dest          = (CPU_INT08U *)pdest;
    pmem_08_src           = (CPU_INT08U *)psrc;
                                                                /* See Note #4.                                         */
    mem_align_modulo_dest = (CPU_INT08U  )((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
10000fa0:	a4650003 	andi	r3, r5, 3
    mem_align_modulo_src  = (CPU_INT08U  )((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));

    mem_aligned           = (mem_align_modulo_dest == mem_align_modulo_src) ? DEF_YES : DEF_NO;
10000fa4:	a4860003 	andi	r4, r6, 3
10000fa8:	88832000 	xor	r4, r3, r4
10000fac:	bc240014 	bnei	r4, 20		// 10000fc0

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
10000fb0:	be230038 	bneid	r3, 56		// 10000fe8
10000fb4:	31000003 	addik	r8, r0, 3
10000fb8:	b8100044 	brid	68		// 10000ffc
10000fbc:	10600000 	addk	r3, r0, r0
    pmem_08_src           = (CPU_INT08U *)psrc;
                                                                /* See Note #4.                                         */
    mem_align_modulo_dest = (CPU_INT08U  )((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    mem_align_modulo_src  = (CPU_INT08U  )((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));

    mem_aligned           = (mem_align_modulo_dest == mem_align_modulo_src) ? DEF_YES : DEF_NO;
10000fc0:	10870000 	addk	r4, r7, r0

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
10000fc4:	b8100078 	brid	120		// 1000103c
10000fc8:	10600000 	addk	r3, r0, r0
            i = mem_align_modulo_dest;
            while ((size_rem   >  0u) &&                        /* ... start mem buf copy with leading octets ...       */
                   (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
               *pmem_08_dest++ = *pmem_08_src++;
10000fcc:	e1260000 	lbui	r9, r6, 0
                size_rem      -=  sizeof(CPU_INT08U);
                i++;
10000fd0:	30630001 	addik	r3, r3, 1
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
            i = mem_align_modulo_dest;
            while ((size_rem   >  0u) &&                        /* ... start mem buf copy with leading octets ...       */
                   (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
               *pmem_08_dest++ = *pmem_08_src++;
10000fd4:	30c60001 	addik	r6, r6, 1
10000fd8:	f1250000 	sbi	r9, r5, 0
                size_rem      -=  sizeof(CPU_INT08U);
10000fdc:	30e7ffff 	addik	r7, r7, -1
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
            i = mem_align_modulo_dest;
            while ((size_rem   >  0u) &&                        /* ... start mem buf copy with leading octets ...       */
                   (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
               *pmem_08_dest++ = *pmem_08_src++;
10000fe0:	30a50001 	addik	r5, r5, 1
                size_rem      -=  sizeof(CPU_INT08U);
                i++;
10000fe4:	a46300ff 	andi	r3, r3, 255
    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
            i = mem_align_modulo_dest;
            while ((size_rem   >  0u) &&                        /* ... start mem buf copy with leading octets ...       */
                   (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
10000fe8:	15234003 	cmpu	r9, r3, r8
10000fec:	be49000c 	bltid	r9, 12		// 10000ff8
10000ff0:	8d272400 	pcmpne	r9, r7, r4

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
            i = mem_align_modulo_dest;
            while ((size_rem   >  0u) &&                        /* ... start mem buf copy with leading octets ...       */
10000ff4:	bc29ffd8 	bnei	r9, -40		// 10000fcc

    mem_aligned           = (mem_align_modulo_dest == mem_align_modulo_src) ? DEF_YES : DEF_NO;

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
        if (mem_align_modulo_dest != 0u) {                      /* If leading octets avail,                   ...       */
10000ff8:	10600000 	addk	r3, r0, r0
            }
        }

        pmem_align_dest = (CPU_ALIGN *)pmem_08_dest;            /* See Note #3a.                                        */
        pmem_align_src  = (CPU_ALIGN *)pmem_08_src;
        while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
10000ffc:	b8100014 	brid	20		// 10001010
10001000:	30800003 	addik	r4, r0, 3
           *pmem_align_dest++ = *pmem_align_src++;              /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
10001004:	c9033000 	lw	r8, r3, r6
10001008:	d9032800 	sw	r8, r3, r5
1000100c:	30630004 	addik	r3, r3, 4
            }
        }

        pmem_align_dest = (CPU_ALIGN *)pmem_08_dest;            /* See Note #3a.                                        */
        pmem_align_src  = (CPU_ALIGN *)pmem_08_src;
        while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
10001010:	15033800 	rsubk	r8, r3, r7
10001014:	15082003 	cmpu	r8, r8, r4
10001018:	bc48ffec 	blti	r8, -20		// 10001004
*                   mem_align_modulo arithmetic operation.
*********************************************************************************************************
*/
/*$PAGE*/
#if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
void  Mem_Copy (void        *pdest,
1000101c:	a467fffc 	andi	r3, r7, -4
            }
        }

        pmem_align_dest = (CPU_ALIGN *)pmem_08_dest;            /* See Note #3a.                                        */
        pmem_align_src  = (CPU_ALIGN *)pmem_08_src;
        while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
10001020:	a4870003 	andi	r4, r7, 3
*                   mem_align_modulo arithmetic operation.
*********************************************************************************************************
*/
/*$PAGE*/
#if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
void  Mem_Copy (void        *pdest,
10001024:	10c61800 	addk	r6, r6, r3
10001028:	b810ff9c 	brid	-100		// 10000fc4
1000102c:	10a51800 	addk	r5, r5, r3
        pmem_08_dest = (CPU_INT08U *)pmem_align_dest;
        pmem_08_src  = (CPU_INT08U *)pmem_align_src;
    }

    while (size_rem > 0u) {                                     /* For unaligned mem bufs or trailing octets, ...       */
       *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
10001030:	c0e33000 	lbu	r7, r3, r6
10001034:	d0e32800 	sb	r7, r3, r5
10001038:	30630001 	addik	r3, r3, 1

        pmem_08_dest = (CPU_INT08U *)pmem_align_dest;
        pmem_08_src  = (CPU_INT08U *)pmem_align_src;
    }

    while (size_rem > 0u) {                                     /* For unaligned mem bufs or trailing octets, ...       */
1000103c:	88e32000 	xor	r7, r3, r4
10001040:	bc27fff0 	bnei	r7, -16		// 10001030
10001044:	b60f0008 	rtsd	r15, 8
10001048:	80000000 	or	r0, r0, r0

1000104c <Mem_Cmp>:
    CPU_INT08U    mem_align_modulo_2;
    CPU_BOOLEAN   mem_aligned;
    CPU_BOOLEAN   mem_cmp;


    if (size < 1u) {                                            /* See Note #1.                                         */
1000104c:	be07010c 	beqid	r7, 268		// 10001158
10001050:	30600001 	addik	r3, r0, 1
        return (DEF_YES);
    }
    if (p1_mem == (void *)0) {
10001054:	be050104 	beqid	r5, 260		// 10001158
10001058:	10650000 	addk	r3, r5, r0
        return (DEF_NO);
    }
    if (p2_mem == (void *)0) {
1000105c:	be0600fc 	beqid	r6, 252		// 10001158
10001060:	10660000 	addk	r3, r6, r0


    mem_cmp            =  DEF_YES;                              /* Assume mem bufs are identical until cmp fails.       */
    size_rem           =  size;
                                                                /* Start @ end of mem bufs (see Note #2).               */
    p1_mem_08          = (CPU_INT08U *)p1_mem + size;
10001064:	10a53800 	addk	r5, r5, r7
    p2_mem_08          = (CPU_INT08U *)p2_mem + size;
10001068:	10c63800 	addk	r6, r6, r7
                                                                /* See Note #4.                                         */
    mem_align_modulo_1 = (CPU_INT08U  )((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
1000106c:	a5250003 	andi	r9, r5, 3
    mem_align_modulo_2 = (CPU_INT08U  )((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));

    mem_aligned        = (mem_align_modulo_1 == mem_align_modulo_2) ? DEF_YES : DEF_NO;
10001070:	a5460003 	andi	r10, r6, 3
10001074:	89495000 	xor	r10, r9, r10
    size_rem           =  size;
                                                                /* Start @ end of mem bufs (see Note #2).               */
    p1_mem_08          = (CPU_INT08U *)p1_mem + size;
    p2_mem_08          = (CPU_INT08U *)p2_mem + size;
                                                                /* See Note #4.                                         */
    mem_align_modulo_1 = (CPU_INT08U  )((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
10001078:	10650000 	addk	r3, r5, r0
    mem_align_modulo_2 = (CPU_INT08U  )((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));

    mem_aligned        = (mem_align_modulo_1 == mem_align_modulo_2) ? DEF_YES : DEF_NO;
1000107c:	be2a00a0 	bneid	r10, 160		// 1000111c
10001080:	10860000 	addk	r4, r6, r0

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_modulo_1 != 0u) {                         /* If trailing octets avail,                  ...       */
10001084:	be290030 	bneid	r9, 48		// 100010b4
10001088:	31000001 	addik	r8, r0, 1
1000108c:	b810005c 	brid	92		// 100010e8
10001090:	30600001 	addik	r3, r0, 1
                   (size_rem > 0u)      &&                      /* ... start mem buf cmp with trailing octets ...       */
                   (i        > 0u)) {                           /* ... until next CPU_ALIGN word boundary.              */
                p1_mem_08--;
                p2_mem_08--;
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
10001094:	e103ffff 	lbui	r8, r3, -1
10001098:	e0a4ffff 	lbui	r5, r4, -1
                }
                size_rem -= sizeof(CPU_INT08U);
                i--;
1000109c:	3129ffff 	addik	r9, r9, -1
                p1_mem_08--;
                p2_mem_08--;
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_INT08U);
100010a0:	30e7ffff 	addik	r7, r7, -1
                   (size_rem > 0u)      &&                      /* ... start mem buf cmp with trailing octets ...       */
                   (i        > 0u)) {                           /* ... until next CPU_ALIGN word boundary.              */
                p1_mem_08--;
                p2_mem_08--;
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
100010a4:	89082c00 	pcmpeq	r8, r8, r5
                }
                size_rem -= sizeof(CPU_INT08U);
                i--;
100010a8:	a52900ff 	andi	r9, r9, 255
100010ac:	3063ffff 	addik	r3, r3, -1
100010b0:	3084ffff 	addik	r4, r4, -1

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_modulo_1 != 0u) {                         /* If trailing octets avail,                  ...       */
            i = mem_align_modulo_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
100010b4:	8d675400 	pcmpne	r11, r7, r10
                p2_mem_08--;
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_INT08U);
                i--;
100010b8:	10c40000 	addk	r6, r4, r0

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_modulo_1 != 0u) {                         /* If trailing octets avail,                  ...       */
            i = mem_align_modulo_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
100010bc:	be0b001c 	beqid	r11, 28		// 100010d8
100010c0:	10a30000 	addk	r5, r3, r0
100010c4:	be080018 	beqid	r8, 24		// 100010dc
100010c8:	a9080001 	xori	r8, r8, 1
                   (size_rem > 0u)      &&                      /* ... start mem buf cmp with trailing octets ...       */
100010cc:	bc29ffc8 	bnei	r9, -56		// 10001094

    mem_aligned        = (mem_align_modulo_1 == mem_align_modulo_2) ? DEF_YES : DEF_NO;

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_modulo_1 != 0u) {                         /* If trailing octets avail,                  ...       */
100010d0:	b8100018 	brid	24		// 100010e8
100010d4:	30600001 	addik	r3, r0, 1
                size_rem -= sizeof(CPU_INT08U);
                i--;
            }
        }

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
100010d8:	a9080001 	xori	r8, r8, 1
100010dc:	be280044 	bneid	r8, 68		// 10001120
100010e0:	10600000 	addk	r3, r0, r0

    mem_aligned        = (mem_align_modulo_1 == mem_align_modulo_2) ? DEF_YES : DEF_NO;

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_modulo_1 != 0u) {                         /* If trailing octets avail,                  ...       */
100010e4:	30600001 	addik	r3, r0, 1
        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
                   (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
100010e8:	b8100020 	brid	32		// 10001108
100010ec:	30800003 	addik	r4, r0, 3
                p1_mem_align--;
                p2_mem_align--;
                if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
100010f0:	e905fffc 	lwi	r8, r5, -4
100010f4:	e866fffc 	lwi	r3, r6, -4
                }
                size_rem -= sizeof(CPU_ALIGN);
100010f8:	30e7fffc 	addik	r7, r7, -4
100010fc:	30a5fffc 	addik	r5, r5, -4
            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
                   (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
                p1_mem_align--;
                p2_mem_align--;
                if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
10001100:	88681c00 	pcmpeq	r3, r8, r3
                }
                size_rem -= sizeof(CPU_ALIGN);
10001104:	30c6fffc 	addik	r6, r6, -4
        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
                   (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
10001108:	15072003 	cmpu	r8, r7, r4
1000110c:	bca80014 	bgei	r8, 20		// 10001120

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
10001110:	bc23ffe0 	bnei	r3, -32		// 100010f0
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                   mem_align_modulo arithmetic operation.
********************************************************************************************************
*/
/*$PAGE*/
CPU_BOOLEAN  Mem_Cmp (void        *p1_mem,
10001114:	b8100010 	brid	16		// 10001124
10001118:	14870000 	rsubk	r4, r7, r0
    if (p2_mem == (void *)0) {
        return (DEF_NO);
    }


    mem_cmp            =  DEF_YES;                              /* Assume mem bufs are identical until cmp fails.       */
1000111c:	30600001 	addik	r3, r0, 1
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                   mem_align_modulo arithmetic operation.
********************************************************************************************************
*/
/*$PAGE*/
CPU_BOOLEAN  Mem_Cmp (void        *p1_mem,
10001120:	14870000 	rsubk	r4, r7, r0
            p2_mem_08 = (CPU_INT08U *)p2_mem_align;
        }
    }

    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
           (size_rem > 0u)) {                                   /* ... for unaligned mem bufs or trailing octets.       */
10001124:	11000000 	addk	r8, r0, r0
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                   mem_align_modulo arithmetic operation.
********************************************************************************************************
*/
/*$PAGE*/
CPU_BOOLEAN  Mem_Cmp (void        *p1_mem,
10001128:	10a52000 	addk	r5, r5, r4
1000112c:	b8100020 	brid	32		// 1000114c
10001130:	10c62000 	addk	r6, r6, r4
10001134:	10853800 	addk	r4, r5, r7
10001138:	10663800 	addk	r3, r6, r7
    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
           (size_rem > 0u)) {                                   /* ... for unaligned mem bufs or trailing octets.       */
        p1_mem_08--;
        p2_mem_08--;
        if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
             mem_cmp = DEF_NO;
1000113c:	e084ffff 	lbui	r4, r4, -1
10001140:	e063ffff 	lbui	r3, r3, -1
        }
        size_rem -= sizeof(CPU_INT08U);
10001144:	30e7ffff 	addik	r7, r7, -1
    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
           (size_rem > 0u)) {                                   /* ... for unaligned mem bufs or trailing octets.       */
        p1_mem_08--;
        p2_mem_08--;
        if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
             mem_cmp = DEF_NO;
10001148:	88641c00 	pcmpeq	r3, r4, r3
            p1_mem_08 = (CPU_INT08U *)p1_mem_align;
            p2_mem_08 = (CPU_INT08U *)p2_mem_align;
        }
    }

    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
1000114c:	8c874400 	pcmpne	r4, r7, r8
10001150:	bc040008 	beqi	r4, 8		// 10001158
10001154:	bc23ffe0 	bnei	r3, -32		// 10001134
        }
        size_rem -= sizeof(CPU_INT08U);
    }

    return (mem_cmp);
}
10001158:	b60f0008 	rtsd	r15, 8
1000115c:	80000000 	or	r0, r0, r0

10001160 <Str_FmtNbr_Int32>:
                                     CPU_BOOLEAN   nbr_neg,
                                     CPU_CHAR      lead_char,
                                     CPU_BOOLEAN   lower_case,
                                     CPU_BOOLEAN   nul,
                                     CPU_CHAR     *pstr)
{
10001160:	3021ffc8 	addik	r1, r1, -56
10001164:	fac10020 	swi	r22, r1, 32
10001168:	eac10058 	lwi	r22, r1, 88
1000116c:	fa61001c 	swi	r19, r1, 28
10001170:	fae10024 	swi	r23, r1, 36
10001174:	fb010028 	swi	r24, r1, 40
10001178:	fb21002c 	swi	r25, r1, 44
1000117c:	fb410030 	swi	r26, r1, 48
10001180:	fb610034 	swi	r27, r1, 52
10001184:	f9e10000 	swi	r15, r1, 0
10001188:	13250000 	addk	r25, r5, r0
1000118c:	12660000 	addk	r19, r6, r0
10001190:	12e70000 	addk	r23, r7, r0
10001194:	13680000 	addk	r27, r8, r0
10001198:	13090000 	addk	r24, r9, r0
    CPU_BOOLEAN   ovf;
    CPU_BOOLEAN   print_char;


/*$PAGE*/
    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
1000119c:	be16017c 	beqid	r22, 380		// 10001318
100011a0:	134a0000 	addk	r26, r10, r0
        return ((CPU_CHAR *)0);
    }
                                                                /* Rtn NULL if invalid base (see Note #6b).             */
    if ((nbr_base <  2u) ||
100011a4:	3067fffe 	addik	r3, r7, -2
100011a8:	a46300ff 	andi	r3, r3, 255
100011ac:	30800022 	addik	r4, r0, 34
100011b0:	14632003 	cmpu	r3, r3, r4
100011b4:	bc430160 	blti	r3, 352		// 10001314
        (nbr_base > 36u)) {
        return ((CPU_CHAR *)0);
    }

    if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
100011b8:	be290068 	bneid	r9, 104		// 10001220
100011bc:	64a70402 	bslli	r5, r7, 2
        log_floor = 1u;                                         /* ... calc floor of nbr digs (see Note #1a) ...        */
        nbr_exp   = nbr_base;
100011c0:	10870000 	addk	r4, r7, r0
        ovf       = DEF_NO;
        while ((nbr_exp <= nbr) &&
               (ovf     == DEF_NO)) {
            if (nbr_exp <= Str_MultOvfThTbl_Int32U[nbr_base]) {
100011c4:	b0001000 	imm	4096
100011c8:	30e0893c 	addik	r7, r0, -30404	// 1000893c <Str_MultOvfThTbl_Int32U>
    }

    if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
        log_floor = 1u;                                         /* ... calc floor of nbr digs (see Note #1a) ...        */
        nbr_exp   = nbr_base;
        ovf       = DEF_NO;
100011cc:	10c90000 	addk	r6, r9, r0
        (nbr_base > 36u)) {
        return ((CPU_CHAR *)0);
    }

    if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
        log_floor = 1u;                                         /* ... calc floor of nbr digs (see Note #1a) ...        */
100011d0:	30600001 	addik	r3, r0, 1
        nbr_exp   = nbr_base;
        ovf       = DEF_NO;
        while ((nbr_exp <= nbr) &&
               (ovf     == DEF_NO)) {
100011d4:	11090000 	addk	r8, r9, r0

    if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
        log_floor = 1u;                                         /* ... calc floor of nbr digs (see Note #1a) ...        */
        nbr_exp   = nbr_base;
        ovf       = DEF_NO;
        while ((nbr_exp <= nbr) &&
100011d8:	b8100028 	brid	40		// 10001200
100011dc:	10a72800 	addk	r5, r7, r5
               (ovf     == DEF_NO)) {
            if (nbr_exp <= Str_MultOvfThTbl_Int32U[nbr_base]) {
100011e0:	e8e50000 	lwi	r7, r5, 0
100011e4:	14e43803 	cmpu	r7, r4, r7
100011e8:	be470010 	bltid	r7, 16		// 100011f8
100011ec:	30c00001 	addik	r6, r0, 1
                nbr_exp *= nbr_base;
100011f0:	4084b800 	mul	r4, r4, r23
100011f4:	10c00000 	addk	r6, r0, r0
            } else {
                ovf      = DEF_YES;
            }
            log_floor++;
100011f8:	30630001 	addik	r3, r3, 1
100011fc:	a46300ff 	andi	r3, r3, 255

    if (lead_char == (CPU_CHAR)'\0') {                          /* If lead char NOT avail,                   ...        */
        log_floor = 1u;                                         /* ... calc floor of nbr digs (see Note #1a) ...        */
        nbr_exp   = nbr_base;
        ovf       = DEF_NO;
        while ((nbr_exp <= nbr) &&
10001200:	88c64400 	pcmpeq	r6, r6, r8
10001204:	be06000c 	beqid	r6, 12		// 10001210
10001208:	14c4c803 	cmpu	r6, r4, r25
1000120c:	bca6ffd4 	bgei	r6, -44		// 100011e0
            } else {
                ovf      = DEF_YES;
            }
            log_floor++;
        }
        if (nbr_dig > log_floor) {
10001210:	14931803 	cmpu	r4, r19, r3
10001214:	be440028 	bltid	r4, 40		// 1000123c
10001218:	a91b0001 	xori	r8, r27, 1
1000121c:	b8000024 	bri	36		// 10001240
            nbr_dig = log_floor;                                /* ... & lim max nbr digs.                              */
        }

    } else {
        print_char = ASCII_IsPrint(lead_char);
10001220:	b9f4fa7c 	brlid	r15, -1412	// 10000c9c <ASCII_IsPrint>
10001224:	10a90000 	addk	r5, r9, r0
        if (print_char != DEF_YES) {                            /* Rtn NULL if lead char non-printable (see Note #6c).  */
10001228:	a8630001 	xori	r3, r3, 1
1000122c:	be030014 	beqid	r3, 20		// 10001240
10001230:	a91b0001 	xori	r8, r27, 1
            return ((CPU_CHAR *)0);
10001234:	b81000e4 	brid	228		// 10001318
10001238:	12c00000 	addk	r22, r0, r0
            } else {
                ovf      = DEF_YES;
            }
            log_floor++;
        }
        if (nbr_dig > log_floor) {
1000123c:	12630000 	addk	r19, r3, r0


    nbr_fmt  = nbr;
    pstr_fmt = pstr;

    if (nbr_neg == DEF_YES) {                                   /* If nbr neg                 ...                       */
10001240:	be28001c 	bneid	r8, 28		// 1000125c
10001244:	10760000 	addk	r3, r22, r0
        if (nbr_dig > 0u) {                                     /* ... & if at least one dig, ...                       */
10001248:	be130018 	beqid	r19, 24		// 10001260
1000124c:	e0a10057 	lbui	r5, r1, 87
           *pstr_fmt++ = '-';                                   /* ... prepend a neg sign.                              */
10001250:	3060002d 	addik	r3, r0, 45
10001254:	f0760000 	sbi	r3, r22, 0
10001258:	30760001 	addik	r3, r22, 1
        }
    }

    pstr_fmt += nbr_dig;                                        /* Start fmt from least significant dig.                */

    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
1000125c:	e0a10057 	lbui	r5, r1, 87
10001260:	be05000c 	beqid	r5, 12		// 1000126c
10001264:	10839800 	addk	r4, r3, r19
       *pstr_fmt = (CPU_CHAR)'\0';
10001268:	d0131800 	sb	r0, r19, r3
    }
    pstr_fmt--;

    if (nbr_dig > 0u) {
1000126c:	be1300ac 	beqid	r19, 172		// 10001318
10001270:	30600001 	addik	r3, r0, 1
    pstr_fmt += nbr_dig;                                        /* Start fmt from least significant dig.                */

    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
       *pstr_fmt = (CPU_CHAR)'\0';
    }
    pstr_fmt--;
10001274:	3084ffff 	addik	r4, r4, -1
10001278:	10b90000 	addk	r5, r25, r0

    if (nbr_dig > 0u) {
        for (i = 1u; i <= nbr_dig; i++) {                       /* Fmt str for desired nbr digs.                        */
            if ((nbr_fmt >  0u) ||                              /* If fmt nbr > 0              (see Note #3c1), ...     */
1000127c:	11600000 	addk	r11, r0, r0
                (nbr_dig == 1u) ||                              /* ... OR exactly 1 dig to fmt (see Note #3c2), ...     */
                (i       == 1u)) {                              /* ... OR on one's  dig to fmt;                 ...     */
                                                                /* ... calc & fmt dig val;                      ...     */
                nbr_dig_val = nbr_fmt % nbr_base;
                if (nbr_dig_val <= 9u) {
10001280:	31200009 	addik	r9, r0, 9
                   *pstr_fmt-- = (CPU_CHAR)(nbr_dig_val + '0');
                } else {
                    if (lower_case !=  DEF_YES) {
10001284:	895a1800 	xor	r10, r26, r3
    }
    pstr_fmt--;

    if (nbr_dig > 0u) {
        for (i = 1u; i <= nbr_dig; i++) {                       /* Fmt str for desired nbr digs.                        */
            if ((nbr_fmt >  0u) ||                              /* If fmt nbr > 0              (see Note #3c1), ...     */
10001288:	b8100078 	brid	120		// 10001300
1000128c:	89131c00 	pcmpeq	r8, r19, r3
10001290:	be270018 	bneid	r7, 24		// 100012a8
10001294:	48d72802 	idivu	r6, r23, r5
10001298:	be280014 	bneid	r8, 20		// 100012ac
1000129c:	40e6b800 	mul	r7, r6, r23
                (nbr_dig == 1u) ||                              /* ... OR exactly 1 dig to fmt (see Note #3c2), ...     */
100012a0:	a8e30001 	xori	r7, r3, 1
100012a4:	bc270040 	bnei	r7, 64		// 100012e4
                (i       == 1u)) {                              /* ... OR on one's  dig to fmt;                 ...     */
                                                                /* ... calc & fmt dig val;                      ...     */
                nbr_dig_val = nbr_fmt % nbr_base;
100012a8:	40e6b800 	mul	r7, r6, r23
100012ac:	14a72800 	rsubk	r5, r7, r5
                if (nbr_dig_val <= 9u) {
100012b0:	14e54803 	cmpu	r7, r5, r9
100012b4:	bc470010 	blti	r7, 16		// 100012c4
                   *pstr_fmt-- = (CPU_CHAR)(nbr_dig_val + '0');
100012b8:	30a50030 	addik	r5, r5, 48
100012bc:	b8100034 	brid	52		// 100012f0
100012c0:	f0a40000 	sbi	r5, r4, 0
                } else {
                    if (lower_case !=  DEF_YES) {
100012c4:	be0a0010 	beqid	r10, 16		// 100012d4
100012c8:	30e4ffff 	addik	r7, r4, -1
                       *pstr_fmt--  = (CPU_CHAR)((nbr_dig_val - 10u) + 'A');
100012cc:	b810000c 	brid	12		// 100012d8
100012d0:	30a50037 	addik	r5, r5, 55
                    } else {
                       *pstr_fmt--  = (CPU_CHAR)((nbr_dig_val - 10u) + 'a');
100012d4:	30a50057 	addik	r5, r5, 87
100012d8:	f0a40000 	sbi	r5, r4, 0
100012dc:	b8100018 	brid	24		// 100012f4
100012e0:	10870000 	addk	r4, r7, r0
                    }
                }

            } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
100012e4:	be180014 	beqid	r24, 20		// 100012f8
100012e8:	10a60000 	addk	r5, r6, r0
               *pstr_fmt-- = (CPU_CHAR)lead_char;               /* ... fmt lead char.                                   */
100012ec:	f3040000 	sbi	r24, r4, 0
100012f0:	3084ffff 	addik	r4, r4, -1
            }

            nbr_fmt /= nbr_base;                                /* Shift nbr to next more significant dig.              */
100012f4:	10a60000 	addk	r5, r6, r0
       *pstr_fmt = (CPU_CHAR)'\0';
    }
    pstr_fmt--;

    if (nbr_dig > 0u) {
        for (i = 1u; i <= nbr_dig; i++) {                       /* Fmt str for desired nbr digs.                        */
100012f8:	30630001 	addik	r3, r3, 1
100012fc:	a46300ff 	andi	r3, r3, 255
10001300:	14c39803 	cmpu	r6, r3, r19
10001304:	bea6ff8c 	bgeid	r6, -116		// 10001290
10001308:	8ce55c00 	pcmpne	r7, r5, r11
        }
    }


    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6d).                 */
}
1000130c:	b8100010 	brid	16		// 1000131c
10001310:	10760000 	addk	r3, r22, r0
        }

    } else {
        print_char = ASCII_IsPrint(lead_char);
        if (print_char != DEF_YES) {                            /* Rtn NULL if lead char non-printable (see Note #6c).  */
            return ((CPU_CHAR *)0);
10001314:	12c00000 	addk	r22, r0, r0
        }
    }


    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6d).                 */
}
10001318:	10760000 	addk	r3, r22, r0
1000131c:	e9e10000 	lwi	r15, r1, 0
10001320:	ea61001c 	lwi	r19, r1, 28
10001324:	eac10020 	lwi	r22, r1, 32
10001328:	eae10024 	lwi	r23, r1, 36
1000132c:	eb010028 	lwi	r24, r1, 40
10001330:	eb21002c 	lwi	r25, r1, 44
10001334:	eb410030 	lwi	r26, r1, 48
10001338:	eb610034 	lwi	r27, r1, 52
1000133c:	b60f0008 	rtsd	r15, 8
10001340:	30210038 	addik	r1, r1, 56

10001344 <Str_ParseNbr_Int32>:
static  CPU_INT32U  Str_ParseNbr_Int32 (CPU_CHAR      *pstr,
                                        CPU_CHAR     **pstr_next,
                                        CPU_INT08U     nbr_base,
                                        CPU_BOOLEAN    nbr_signed,
                                        CPU_BOOLEAN   *pnbr_neg)
{
10001344:	3021ffb4 	addik	r1, r1, -76
10001348:	fae10028 	swi	r23, r1, 40
1000134c:	fb210030 	swi	r25, r1, 48
10001350:	fb410034 	swi	r26, r1, 52
10001354:	fb610038 	swi	r27, r1, 56
10001358:	fb81003c 	swi	r28, r1, 60
1000135c:	f9e10000 	swi	r15, r1, 0
10001360:	fa610020 	swi	r19, r1, 32
10001364:	fac10024 	swi	r22, r1, 36
10001368:	fb01002c 	swi	r24, r1, 44
1000136c:	fba10040 	swi	r29, r1, 64
10001370:	fbc10044 	swi	r30, r1, 68
10001374:	fbe10048 	swi	r31, r1, 72
10001378:	13250000 	addk	r25, r5, r0
1000137c:	13660000 	addk	r27, r6, r0
10001380:	12e70000 	addk	r23, r7, r0
10001384:	13480000 	addk	r26, r8, r0
    CPU_BOOLEAN   neg;
    CPU_BOOLEAN   ovf;
    CPU_BOOLEAN   done;

                                                                /* Init rtn vals for err (see Note #5).                  */
    if (pstr_next != (CPU_CHAR **)0) {
10001388:	be06000c 	beqid	r6, 12		// 10001394
1000138c:	13890000 	addk	r28, r9, r0
       *pstr_next  = (CPU_CHAR  *)pstr;
10001390:	f8bb0000 	swi	r5, r27, 0
    }

    if (pnbr_neg != (CPU_BOOLEAN *)0) {
10001394:	bc1c0008 	beqi	r28, 8		// 1000139c
       *pnbr_neg  = (CPU_BOOLEAN  )DEF_NO;
10001398:	f01c0000 	sbi	r0, r28, 0
    }


    if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
1000139c:	be19022c 	beqid	r25, 556		// 100015c8
100013a0:	13190000 	addk	r24, r25, r0
        return ((CPU_INT32U)0u);
    }
                                                                /* Rtn zero if invalid base (see Note #4a).             */
    if ((nbr_base == 1u) ||
        (nbr_base > 36u)) {
100013a4:	30600024 	addik	r3, r0, 36	// 24 <STK_OFFSET_R10>
100013a8:	14771803 	cmpu	r3, r23, r3
100013ac:	be430218 	bltid	r3, 536		// 100015c4
100013b0:	30600001 	addik	r3, r0, 1

    if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
        return ((CPU_INT32U)0u);
    }
                                                                /* Rtn zero if invalid base (see Note #4a).             */
    if ((nbr_base == 1u) ||
100013b4:	88771c00 	pcmpeq	r3, r23, r3
100013b8:	be23020c 	bneid	r3, 524		// 100015c4
100013bc:	12d90000 	addk	r22, r25, r0


                                                                /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
    pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */

    whitespace = ASCII_IsSpace(*pstr_parse);
100013c0:	e0b90000 	lbui	r5, r25, 0
100013c4:	b9f4f880 	brlid	r15, -1920	// 10000c44 <ASCII_IsSpace>
100013c8:	90a50060 	sext8	r5, r5
    while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
100013cc:	b810001c 	brid	28		// 100013e8
100013d0:	a8630001 	xori	r3, r3, 1
        pstr_parse++;
        whitespace = ASCII_IsSpace(*pstr_parse);
100013d4:	e0b60001 	lbui	r5, r22, 1
100013d8:	32d60001 	addik	r22, r22, 1
100013dc:	b9f4f868 	brlid	r15, -1944	// 10000c44 <ASCII_IsSpace>
100013e0:	90a50060 	sext8	r5, r5

                                                                /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
    pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */

    whitespace = ASCII_IsSpace(*pstr_parse);
    while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
100013e4:	a8630001 	xori	r3, r3, 1
100013e8:	be03ffec 	beqid	r3, -20		// 100013d4
100013ec:	12760000 	addk	r19, r22, r0
        pstr_parse++;
        whitespace = ASCII_IsSpace(*pstr_parse);
    }

    switch (*pstr_parse) {
100013f0:	e0760000 	lbui	r3, r22, 0
100013f4:	90630060 	sext8	r3, r3
100013f8:	abc3002b 	xori	r30, r3, 43
100013fc:	be1e0018 	beqid	r30, 24		// 10001414
10001400:	a863002d 	xori	r3, r3, 45
10001404:	be030018 	beqid	r3, 24		// 1000141c
10001408:	a91a0001 	xori	r8, r26, 1
             neg = DEF_YES;
             break;


        default:
             neg = DEF_NO;
1000140c:	b8100020 	brid	32		// 1000142c
10001410:	13c00000 	addk	r30, r0, r0
        whitespace = ASCII_IsSpace(*pstr_parse);
    }

    switch (*pstr_parse) {
        case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
             pstr_parse++;
10001414:	b8100018 	brid	24		// 1000142c
10001418:	32760001 	addik	r19, r22, 1
             break;


        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
1000141c:	10600000 	addk	r3, r0, r0
10001420:	89081c00 	pcmpeq	r8, r8, r3
             }
             neg = DEF_YES;
10001424:	33c00001 	addik	r30, r0, 1
10001428:	12764000 	addk	r19, r22, r8

/*$PAGE*/
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
1000142c:	a8770008 	xori	r3, r23, 8
10001430:	bc03005c 	beqi	r3, 92		// 1000148c
10001434:	a8770010 	xori	r3, r23, 16
10001438:	bc03006c 	beqi	r3, 108		// 100014a4
1000143c:	be3700b8 	bneid	r23, 184		// 100014f4
10001440:	12d30000 	addk	r22, r19, r0
        case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
10001444:	e0730000 	lbui	r3, r19, 0
10001448:	90630060 	sext8	r3, r3
1000144c:	a8630030 	xori	r3, r3, 48
10001450:	bc2300a0 	bnei	r3, 160		// 100014f0
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
10001454:	e0730001 	lbui	r3, r19, 1
10001458:	90630060 	sext8	r3, r3
1000145c:	a8830058 	xori	r4, r3, 88
10001460:	be040014 	beqid	r4, 20		// 10001474
10001464:	32d30001 	addik	r22, r19, 1
10001468:	a8630078 	xori	r3, r3, 120
1000146c:	be230088 	bneid	r3, 136		// 100014f4
10001470:	32e00008 	addik	r23, r0, 8	// 8 <STK_OFFSET_R03>
                      case 'x':                                 /* For '0x' prefix, ...                                 */
                      case 'X':
                           nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
                           nbr_hex    =  ASCII_IsDigHex(parse_char);
10001474:	e0b30002 	lbui	r5, r19, 2
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
                      case 'x':                                 /* For '0x' prefix, ...                                 */
                      case 'X':
                           nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
10001478:	32e00010 	addik	r23, r0, 16	// 10 <STK_OFFSET_R05>
                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
                           nbr_hex    =  ASCII_IsDigHex(parse_char);
1000147c:	b9f4f764 	brlid	r15, -2204	// 10000be0 <ASCII_IsDigHex>
10001480:	90a50060 	sext8	r5, r5
                           if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
10001484:	b8100060 	brid	96		// 100014e4
10001488:	a8630001 	xori	r3, r3, 1
             }
             break;


        case  8u:                                               /* See Note #2a1B1a2.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
1000148c:	e2d30000 	lbui	r22, r19, 0
10001490:	92d60060 	sext8	r22, r22
10001494:	aad60030 	xori	r22, r22, 48
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
10001498:	8ad61c00 	pcmpeq	r22, r22, r3
1000149c:	b8100058 	brid	88		// 100014f4
100014a0:	12d3b000 	addk	r22, r19, r22
             }
             break;


        case 16u:                                               /* See Note #2a1B1a3.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
100014a4:	e0730000 	lbui	r3, r19, 0
100014a8:	90630060 	sext8	r3, r3
100014ac:	a8630030 	xori	r3, r3, 48
100014b0:	be230044 	bneid	r3, 68		// 100014f4
100014b4:	12d30000 	addk	r22, r19, r0
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
100014b8:	e0730001 	lbui	r3, r19, 1
100014bc:	90630060 	sext8	r3, r3
100014c0:	a8830058 	xori	r4, r3, 88
100014c4:	be040010 	beqid	r4, 16		// 100014d4
100014c8:	32d30001 	addik	r22, r19, 1
100014cc:	a8630078 	xori	r3, r3, 120
100014d0:	bc230024 	bnei	r3, 36		// 100014f4
                      case 'x':
                      case 'X':
                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
                           nbr_hex    =  ASCII_IsDigHex(parse_char);
100014d4:	e0b30002 	lbui	r5, r19, 2
100014d8:	b9f4f708 	brlid	r15, -2296	// 10000be0 <ASCII_IsDigHex>
100014dc:	90a50060 	sext8	r5, r5
                           if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
100014e0:	a8630001 	xori	r3, r3, 1
100014e4:	bc230010 	bnei	r3, 16		// 100014f4
                               pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
100014e8:	b810000c 	brid	12		// 100014f4
100014ec:	32d30002 	addik	r22, r19, 2
                           nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
                           break;
                  }

             } else {                                           /* For non-'0' prefix, ...                              */
                 nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
100014f0:	32e0000a 	addik	r23, r0, 10
                }
            }

            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
100014f4:	b0001000 	imm	4096
100014f8:	3080893c 	addik	r4, r0, -30404	// 1000893c <Str_MultOvfThTbl_Int32U>


/*$PAGE*/
                                                                /* ------------------ PARSE INT STR ------------------- */
    nbr  = 0u;
    ovf  = DEF_NO;
100014fc:	13400000 	addk	r26, r0, r0
                }
            }

            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
10001500:	64770402 	bslli	r3, r23, 2
    }


/*$PAGE*/
                                                                /* ------------------ PARSE INT STR ------------------- */
    nbr  = 0u;
10001504:	131a0000 	addk	r24, r26, r0
                }
            }

            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
10001508:	10641800 	addk	r3, r4, r3
1000150c:	f861001c 	swi	r3, r1, 28
    nbr  = 0u;
    ovf  = DEF_NO;
    done = DEF_NO;

    while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
        parse_char = (CPU_CHAR)*pstr_parse;
10001510:	e3b60000 	lbui	r29, r22, 0
10001514:	93fd0060 	sext8	r31, r29
        nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
10001518:	b9f4f60c 	brlid	r15, -2548	// 10000b24 <ASCII_IsAlphaNum>
1000151c:	10bf0000 	addk	r5, r31, r0
        if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
10001520:	a8630001 	xori	r3, r3, 1
10001524:	bc23006c 	bnei	r3, 108		// 10001590
                                                                /* ... convert parse char into nbr dig.                 */
            nbr_dig = ASCII_IsDig(parse_char);
10001528:	b9f4f680 	brlid	r15, -2432	// 10000ba8 <ASCII_IsDig>
1000152c:	10bf0000 	addk	r5, r31, r0
            if (nbr_dig == DEF_YES) {
10001530:	a8630001 	xori	r3, r3, 1
10001534:	be030020 	beqid	r3, 32		// 10001554
10001538:	307dffd0 	addik	r3, r29, -48
                parse_dig = (CPU_INT08U)(parse_char - '0');
            } else {
                nbr_hex_lower = ASCII_IsLower(parse_char);
1000153c:	b9f4f634 	brlid	r15, -2508	// 10000b70 <ASCII_IsLower>
10001540:	10bf0000 	addk	r5, r31, r0
                if (nbr_hex_lower == DEF_YES) {
10001544:	a8630001 	xori	r3, r3, 1
10001548:	be03000c 	beqid	r3, 12		// 10001554
1000154c:	307dffa9 	addik	r3, r29, -87
                    parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
                } else {
                    parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
10001550:	307dffc9 	addik	r3, r29, -55
10001554:	a46300ff 	andi	r3, r3, 255
                }
            }

            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
10001558:	14971803 	cmpu	r4, r23, r3
1000155c:	bca40034 	bgei	r4, 52		// 10001590
                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
10001560:	be3a0024 	bneid	r26, 36		// 10001584
10001564:	e8a1001c 	lwi	r5, r1, 28
                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
10001568:	e8850000 	lwi	r4, r5, 0
1000156c:	14982003 	cmpu	r4, r24, r4
10001570:	bc440014 	blti	r4, 20		// 10001584
                                                                /* ... merge parse char dig into nbr.                   */
                        nbr *= nbr_base;
10001574:	4318b800 	mul	r24, r24, r23
                        nbr += parse_dig;
10001578:	1303c000 	addk	r24, r3, r24
                        if (nbr < parse_dig) {
1000157c:	1463c003 	cmpu	r3, r3, r24
10001580:	bca30008 	bgei	r3, 8		// 10001588
                            ovf = DEF_YES;
10001584:	33400001 	addik	r26, r0, 1
                        }
                    } else {
                        ovf = DEF_YES;
                    }
                }
                pstr_parse++;
10001588:	b810ff88 	brid	-120		// 10001510
1000158c:	32d60001 	addik	r22, r22, 1
        } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
            done = DEF_YES;
        }
    }

    if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
10001590:	ab5a0001 	xori	r26, r26, 1
10001594:	bc3a0008 	bnei	r26, 8		// 1000159c
        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
10001598:	3300ffff 	addik	r24, r0, -1
    }


    if (pstr_next != (CPU_CHAR **)0) {
1000159c:	be1b0018 	beqid	r27, 24		// 100015b4
100015a0:	8a769800 	xor	r19, r22, r19
        if (pstr_parse != pstr_parse_nbr) {                     /* If final parse str != init'l parse nbr str,       .. */
100015a4:	bc13000c 	beqi	r19, 12		// 100015b0
           *pstr_next   = pstr_parse;                           /* .. rtn   parse str's next char (see Note #2a2B2); .. */
100015a8:	b810000c 	brid	12		// 100015b4
100015ac:	fadb0000 	swi	r22, r27, 0
        } else {
           *pstr_next   = pstr;                                 /* .. else rtn initial parse str  (see Note #2a2A2).    */
100015b0:	fb3b0000 	swi	r25, r27, 0
        }
    }

    if (pnbr_neg != (CPU_BOOLEAN *)0) {
100015b4:	be1c0018 	beqid	r28, 24		// 100015cc
100015b8:	10780000 	addk	r3, r24, r0
       *pnbr_neg  = (CPU_BOOLEAN  )neg;                         /* Rtn neg nbr status.                                  */
100015bc:	b8100010 	brid	16		// 100015cc
100015c0:	f3dc0000 	sbi	r30, r28, 0
        return ((CPU_INT32U)0u);
    }
                                                                /* Rtn zero if invalid base (see Note #4a).             */
    if ((nbr_base == 1u) ||
        (nbr_base > 36u)) {
        return ((CPU_INT32U)0u);
100015c4:	13000000 	addk	r24, r0, r0
       *pnbr_neg  = (CPU_BOOLEAN  )neg;                         /* Rtn neg nbr status.                                  */
    }


    return (nbr);
}
100015c8:	10780000 	addk	r3, r24, r0
100015cc:	e9e10000 	lwi	r15, r1, 0
100015d0:	ea610020 	lwi	r19, r1, 32
100015d4:	eac10024 	lwi	r22, r1, 36
100015d8:	eae10028 	lwi	r23, r1, 40
100015dc:	eb01002c 	lwi	r24, r1, 44
100015e0:	eb210030 	lwi	r25, r1, 48
100015e4:	eb410034 	lwi	r26, r1, 52
100015e8:	eb610038 	lwi	r27, r1, 56
100015ec:	eb81003c 	lwi	r28, r1, 60
100015f0:	eba10040 	lwi	r29, r1, 64
100015f4:	ebc10044 	lwi	r30, r1, 68
100015f8:	ebe10048 	lwi	r31, r1, 72
100015fc:	b60f0008 	rtsd	r15, 8
10001600:	3021004c 	addik	r1, r1, 76

10001604 <Str_Len_N>:
    CPU_CHAR    *pstr_len;
    CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
10001604:	10600000 	addk	r3, r0, r0
    while (( pstr_len != (CPU_CHAR *)  0 ) &&                   /* Calc str len until NULL ptr (see Note #3a) ...       */
10001608:	b8100010 	brid	16		// 10001618
1000160c:	10830000 	addk	r4, r3, r0
           (*pstr_len != (CPU_CHAR  )'\0') &&                   /* ... or NULL char found      (see Note #3b) ...       */
           ( len       < (CPU_SIZE_T)len_max)) {                /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
10001610:	30a50001 	addik	r5, r5, 1
        len++;
10001614:	30630001 	addik	r3, r3, 1
    CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (CPU_CHAR *)  0 ) &&                   /* Calc str len until NULL ptr (see Note #3a) ...       */
10001618:	bc05001c 	beqi	r5, 28		// 10001634
           (*pstr_len != (CPU_CHAR  )'\0') &&                   /* ... or NULL char found      (see Note #3b) ...       */
1000161c:	e0e50000 	lbui	r7, r5, 0
10001620:	90e70060 	sext8	r7, r7
10001624:	8ce72400 	pcmpne	r7, r7, r4
10001628:	bc07000c 	beqi	r7, 12		// 10001634
           ( len       < (CPU_SIZE_T)len_max)) {                /* ... or max nbr chars srch'd (see Note #3c).          */
1000162c:	14e61803 	cmpu	r7, r6, r3
10001630:	bc47ffe0 	blti	r7, -32		// 10001610
        pstr_len++;
        len++;
    }

    return (len);                                               /* Rtn str len (see Note #3b1).                         */
}
10001634:	b60f0008 	rtsd	r15, 8
10001638:	80000000 	or	r0, r0, r0

1000163c <Str_Len>:
*                           the NULL character (see Note #2a2).
*********************************************************************************************************
*/

CPU_SIZE_T  Str_Len (CPU_CHAR  *pstr)
{
1000163c:	3021ffe4 	addik	r1, r1, -28
10001640:	f9e10000 	swi	r15, r1, 0
    CPU_SIZE_T  len;


    len = Str_Len_N((CPU_CHAR *)pstr,
10001644:	b9f4ffc0 	brlid	r15, -64	// 10001604 <Str_Len_N>
10001648:	30c0ffff 	addik	r6, r0, -1
                    (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (len);
}
1000164c:	e9e10000 	lwi	r15, r1, 0
10001650:	b60f0008 	rtsd	r15, 8
10001654:	3021001c 	addik	r1, r1, 28

10001658 <Str_Copy_N>:
    CPU_CHAR    *pstr_copy_dest;
    CPU_CHAR    *pstr_copy_src;
    CPU_SIZE_T   len_copy;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr_dest == (CPU_CHAR *)0) {
10001658:	be050090 	beqid	r5, 144		// 100016e8
1000165c:	10650000 	addk	r3, r5, r0
        return ((CPU_CHAR *)0);
    }
    if (pstr_src  == (CPU_CHAR *)0) {
10001660:	bc060074 	beqi	r6, 116		// 100016d4
        return ((CPU_CHAR *)0);
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if copy len = 0    (see Note #3d).          */
10001664:	bc070078 	beqi	r7, 120		// 100016dc
10001668:	10850000 	addk	r4, r5, r0
1000166c:	10a00000 	addk	r5, r0, r0
    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (CPU_CHAR *)  0 ) &&             /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (CPU_CHAR *)  0 ) &&
10001670:	b8100018 	brid	24		// 10001688
10001674:	11050000 	addk	r8, r5, r0
           (*pstr_copy_src  != (CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3c); ...      */
           ( len_copy       <  (CPU_SIZE_T)len_max)) {          /* ... or max nbr chars copied (see Note #3d).          */
       *pstr_copy_dest = *pstr_copy_src;
10001678:	f1240000 	sbi	r9, r4, 0
        pstr_copy_dest++;
        pstr_copy_src++;
1000167c:	30c60001 	addik	r6, r6, 1
    while (( pstr_copy_dest != (CPU_CHAR *)  0 ) &&             /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (CPU_CHAR *)  0 ) &&
           (*pstr_copy_src  != (CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3c); ...      */
           ( len_copy       <  (CPU_SIZE_T)len_max)) {          /* ... or max nbr chars copied (see Note #3d).          */
       *pstr_copy_dest = *pstr_copy_src;
        pstr_copy_dest++;
10001680:	30840001 	addik	r4, r4, 1
        pstr_copy_src++;
        len_copy++;
10001684:	30a50001 	addik	r5, r5, 1

    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (CPU_CHAR *)  0 ) &&             /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
10001688:	8d264400 	pcmpne	r9, r6, r8
1000168c:	bc090024 	beqi	r9, 36		// 100016b0
10001690:	8d244400 	pcmpne	r9, r4, r8
10001694:	bc09001c 	beqi	r9, 28		// 100016b0
           ( pstr_copy_src  != (CPU_CHAR *)  0 ) &&
           (*pstr_copy_src  != (CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3c); ...      */
10001698:	e1260000 	lbui	r9, r6, 0
1000169c:	91490060 	sext8	r10, r9
100016a0:	8d4a4400 	pcmpne	r10, r10, r8
100016a4:	be0a000c 	beqid	r10, 12		// 100016b0
100016a8:	15472803 	cmpu	r10, r7, r5
           ( len_copy       <  (CPU_SIZE_T)len_max)) {          /* ... or max nbr chars copied (see Note #3d).          */
100016ac:	bc4affcc 	blti	r10, -52		// 10001678
        pstr_copy_dest++;
        pstr_copy_src++;
        len_copy++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
    if ((pstr_copy_dest == (CPU_CHAR *)0) ||
100016b0:	11000000 	addk	r8, r0, r0
100016b4:	88c64400 	pcmpeq	r6, r6, r8
100016b8:	be26002c 	bneid	r6, 44		// 100016e4
100016bc:	88c43400 	pcmpeq	r6, r4, r6
100016c0:	be260024 	bneid	r6, 36		// 100016e4
100016c4:	14e72803 	cmpu	r7, r7, r5
        (pstr_copy_src  == (CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
    }

    if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
100016c8:	bca70020 	bgei	r7, 32		// 100016e8
       *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
100016cc:	b60f0008 	rtsd	r15, 8
100016d0:	f0c40000 	sbi	r6, r4, 0
                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr_dest == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
    }
    if (pstr_src  == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
100016d4:	b60f0008 	rtsd	r15, 8
100016d8:	10660000 	addk	r3, r6, r0
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if copy len = 0    (see Note #3d).          */
        return ((CPU_CHAR *)0);
100016dc:	b60f0008 	rtsd	r15, 8
100016e0:	10670000 	addk	r3, r7, r0
        len_copy++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
    if ((pstr_copy_dest == (CPU_CHAR *)0) ||
        (pstr_copy_src  == (CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
100016e4:	10600000 	addk	r3, r0, r0
       *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
    }


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
100016e8:	b60f0008 	rtsd	r15, 8
100016ec:	80000000 	or	r0, r0, r0

100016f0 <Str_Copy>:
*********************************************************************************************************
*/

CPU_CHAR  *Str_Copy (CPU_CHAR  *pstr_dest,
                     CPU_CHAR  *pstr_src)
{
100016f0:	3021ffe4 	addik	r1, r1, -28
100016f4:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Copy_N((CPU_CHAR *)pstr_dest,
100016f8:	b9f4ff60 	brlid	r15, -160	// 10001658 <Str_Copy_N>
100016fc:	30e0ffff 	addik	r7, r0, -1
                          (CPU_CHAR *)pstr_src,
                          (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (pstr_rtn);
}
10001700:	e9e10000 	lwi	r15, r1, 0
10001704:	b60f0008 	rtsd	r15, 8
10001708:	3021001c 	addik	r1, r1, 28

1000170c <Str_Cat_N>:
    CPU_CHAR    *pstr_cat_dest;
    CPU_CHAR    *pstr_cat_src;
    CPU_SIZE_T   len_cat;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr_dest == (CPU_CHAR *)0) {
1000170c:	be0500a0 	beqid	r5, 160		// 100017ac
10001710:	10650000 	addk	r3, r5, r0
        return ((CPU_CHAR *)0);
    }
    if (pstr_cat  == (CPU_CHAR *)0) {
10001714:	bc06008c 	beqi	r6, 140		// 100017a0
        return ((CPU_CHAR *)0);
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
10001718:	be270018 	bneid	r7, 24		// 10001730
1000171c:	10850000 	addk	r4, r5, r0
10001720:	b800008c 	bri	140		// 100017ac
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
10001724:	bc24000c 	bnei	r4, 12		// 10001730
           (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
        pstr_cat_dest++;
    }
    if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
        return ((CPU_CHAR *)0);
10001728:	b60f0008 	rtsd	r15, 8
1000172c:	10640000 	addk	r3, r4, r0
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
10001730:	e0a40000 	lbui	r5, r4, 0
10001734:	90a50060 	sext8	r5, r5
10001738:	be25ffec 	bneid	r5, -20		// 10001724
1000173c:	30840001 	addik	r4, r4, 1
10001740:	3084ffff 	addik	r4, r4, -1

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
           ( pstr_cat_src  != (CPU_CHAR *)  0 ) &&
10001744:	b8100014 	brid	20		// 10001758
10001748:	11050000 	addk	r8, r5, r0
           (*pstr_cat_src  != (CPU_CHAR  )'\0') &&              /* ... or NULL char found     (see Note #3c); ...       */
           ( len_cat       <  (CPU_SIZE_T)len_max)) {           /* ... or max nbr chars cat'd (see Note #3d).           */
       *pstr_cat_dest = *pstr_cat_src;
1000174c:	f1240000 	sbi	r9, r4, 0
        pstr_cat_dest++;
        pstr_cat_src++;
10001750:	30c60001 	addik	r6, r6, 1
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
           ( pstr_cat_src  != (CPU_CHAR *)  0 ) &&
           (*pstr_cat_src  != (CPU_CHAR  )'\0') &&              /* ... or NULL char found     (see Note #3c); ...       */
           ( len_cat       <  (CPU_SIZE_T)len_max)) {           /* ... or max nbr chars cat'd (see Note #3d).           */
       *pstr_cat_dest = *pstr_cat_src;
        pstr_cat_dest++;
10001754:	30840001 	addik	r4, r4, 1
    }

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
10001758:	8d264400 	pcmpne	r9, r6, r8
1000175c:	bc090028 	beqi	r9, 40		// 10001784
10001760:	8d244400 	pcmpne	r9, r4, r8
10001764:	bc090020 	beqi	r9, 32		// 10001784
           ( pstr_cat_src  != (CPU_CHAR *)  0 ) &&
           (*pstr_cat_src  != (CPU_CHAR  )'\0') &&              /* ... or NULL char found     (see Note #3c); ...       */
10001768:	e1260000 	lbui	r9, r6, 0
1000176c:	91490060 	sext8	r10, r9
10001770:	8d4a4400 	pcmpne	r10, r10, r8
10001774:	be0a0010 	beqid	r10, 16		// 10001784
10001778:	15472803 	cmpu	r10, r7, r5
           ( len_cat       <  (CPU_SIZE_T)len_max)) {           /* ... or max nbr chars cat'd (see Note #3d).           */
1000177c:	be4affd0 	bltid	r10, -48		// 1000174c
10001780:	30a50001 	addik	r5, r5, 1
        pstr_cat_dest++;
        pstr_cat_src++;
        len_cat++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    if ((pstr_cat_dest == (CPU_CHAR *)0) ||
10001784:	10a00000 	addk	r5, r0, r0
10001788:	88c62c00 	pcmpeq	r6, r6, r5
1000178c:	be26001c 	bneid	r6, 28		// 100017a8
10001790:	88c43400 	pcmpeq	r6, r4, r6
10001794:	bc260014 	bnei	r6, 20		// 100017a8
    }

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
10001798:	b60f0008 	rtsd	r15, 8
1000179c:	f0c40000 	sbi	r6, r4, 0
                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr_dest == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
    }
    if (pstr_cat  == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
100017a0:	b60f0008 	rtsd	r15, 8
100017a4:	10660000 	addk	r3, r6, r0
        len_cat++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    if ((pstr_cat_dest == (CPU_CHAR *)0) ||
        (pstr_cat_src  == (CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
100017a8:	10600000 	addk	r3, r0, r0

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
100017ac:	b60f0008 	rtsd	r15, 8
100017b0:	80000000 	or	r0, r0, r0

100017b4 <Str_Cat>:
*********************************************************************************************************
*/

CPU_CHAR  *Str_Cat (CPU_CHAR  *pstr_dest,
                    CPU_CHAR  *pstr_cat)
{
100017b4:	3021ffe4 	addik	r1, r1, -28
100017b8:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_rtn;

    
    pstr_rtn = Str_Cat_N((CPU_CHAR *)pstr_dest,
100017bc:	b9f4ff50 	brlid	r15, -176	// 1000170c <Str_Cat_N>
100017c0:	30e0ffff 	addik	r7, r0, -1
                         (CPU_CHAR *)pstr_cat,
                         (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (pstr_rtn);
}
100017c4:	e9e10000 	lwi	r15, r1, 0
100017c8:	b60f0008 	rtsd	r15, 8
100017cc:	3021001c 	addik	r1, r1, 28

100017d0 <Str_Cmp_N>:
    CPU_CHAR    *pstr_cmp_2_next;
    CPU_INT16S   cmp_val;
    CPU_SIZE_T   cmp_len;


    if (len_max == 0u) {                                        /* If cmp len = 0,        rtn 0       (see Note #3d1).  */
100017d0:	be0700c8 	beqid	r7, 200		// 10001898
100017d4:	10670000 	addk	r3, r7, r0
        return ((CPU_INT16S)0);
    }

    if (pstr_1 == (CPU_CHAR *)0) {
100017d8:	be0500a0 	beqid	r5, 160		// 10001878
100017dc:	10660000 	addk	r3, r6, r0
            return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        }
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*pstr_2);
        return (cmp_val);                                       /* If pstr_1 NULL, rtn neg pstr_2 val (see Note #3a1B1).*/
    }
    if (pstr_2 == (CPU_CHAR *)0) {
100017e0:	be260014 	bneid	r6, 20		// 100017f4
100017e4:	31050001 	addik	r8, r5, 1
        cmp_val = (CPU_INT16S)(*pstr_1);
100017e8:	e0650000 	lbui	r3, r5, 0
        return (cmp_val);                                       /* If pstr_2 NULL, rtn pos pstr_1 val (see Note #3a1B2).*/
100017ec:	b60f0008 	rtsd	r15, 8
100017f0:	90630060 	sext8	r3, r3
    pstr_cmp_2      = pstr_2;
    pstr_cmp_1_next = pstr_cmp_1;
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
    pstr_cmp_2_next++;
    cmp_len         = 0u;
100017f4:	10600000 	addk	r3, r0, r0
    pstr_cmp_1      = pstr_1;
    pstr_cmp_2      = pstr_2;
    pstr_cmp_1_next = pstr_cmp_1;
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
    pstr_cmp_2_next++;
100017f8:	31460001 	addik	r10, r6, 1
    cmp_len         = 0u;

    while ((*pstr_cmp_1      == *pstr_cmp_2)      &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
100017fc:	b8100010 	brid	16		// 1000180c
10001800:	11830000 	addk	r12, r3, r0
           ( cmp_len     <  (CPU_SIZE_T)len_max)) {             /* ... or max nbr chars cmp'd        (see Note #3d2).   */
        pstr_cmp_1++;
        pstr_cmp_2++;
        pstr_cmp_1_next++;
        pstr_cmp_2_next++;
10001804:	314a0001 	addik	r10, r10, 1
        cmp_len++;
10001808:	30630001 	addik	r3, r3, 1
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
    pstr_cmp_2_next++;
    cmp_len         = 0u;

    while ((*pstr_cmp_1      == *pstr_cmp_2)      &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
1000180c:	c0832800 	lbu	r4, r3, r5
10001810:	c1233000 	lbu	r9, r3, r6
10001814:	90840060 	sext8	r4, r4
10001818:	91290060 	sext8	r9, r9
1000181c:	89644800 	xor	r11, r4, r9
10001820:	bc2b0034 	bnei	r11, 52		// 10001854
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
10001824:	8d245c00 	pcmpne	r9, r4, r11
10001828:	be090028 	beqid	r9, 40		// 10001850
1000182c:	8d685c00 	pcmpne	r11, r8, r11
10001830:	be0b0020 	beqid	r11, 32		// 10001850
10001834:	15271803 	cmpu	r9, r7, r3
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
           ( cmp_len     <  (CPU_SIZE_T)len_max)) {             /* ... or max nbr chars cmp'd        (see Note #3d2).   */
10001838:	bea9001c 	bgeid	r9, 28		// 10001854
1000183c:	11240000 	addk	r9, r4, r0
    cmp_len         = 0u;

    while ((*pstr_cmp_1      == *pstr_cmp_2)      &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
10001840:	8d2a6400 	pcmpne	r9, r10, r12
10001844:	be29ffc0 	bneid	r9, -64		// 10001804
10001848:	31080001 	addik	r8, r8, 1
1000184c:	3108ffff 	addik	r8, r8, -1
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
    pstr_cmp_2_next++;
    cmp_len         = 0u;

    while ((*pstr_cmp_1      == *pstr_cmp_2)      &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
10001850:	11240000 	addk	r9, r4, r0
        pstr_cmp_2_next++;
        cmp_len++;
    }


    if (cmp_len == len_max) {                                   /* If strs     identical for len nbr of chars, ...      */
10001854:	88633800 	xor	r3, r3, r7
10001858:	bc030040 	beqi	r3, 64		// 10001898
        return ((CPU_INT16S)0);                                 /* ... rtn 0                 (see Note #3d2).           */
    }

    if (*pstr_cmp_1 != *pstr_cmp_2) {                           /* If strs NOT identical, ...                           */
1000185c:	88644800 	xor	r3, r4, r9
10001860:	be230038 	bneid	r3, 56		// 10001898
10001864:	14692000 	rsubk	r3, r9, r4
                                                                /* ... calc & rtn char diff  (see Note #3c).            */
         cmp_val = (CPU_INT16S)(*pstr_cmp_1) - (CPU_INT16S)(*pstr_cmp_2);

    } else if (*pstr_cmp_1  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
10001868:	be040030 	beqid	r4, 48		// 10001898
1000186c:	10640000 	addk	r3, r4, r0
         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

    } else {
        if (pstr_cmp_1_next == (CPU_CHAR *)0) {
10001870:	bc280020 	bnei	r8, 32		// 10001890
            if (pstr_cmp_2_next == (CPU_CHAR *)0) {             /* If BOTH next str ptrs NULL, ...                      */
                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
10001874:	106a0000 	addk	r3, r10, r0
    } else if (*pstr_cmp_1  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

    } else {
        if (pstr_cmp_1_next == (CPU_CHAR *)0) {
            if (pstr_cmp_2_next == (CPU_CHAR *)0) {             /* If BOTH next str ptrs NULL, ...                      */
10001878:	bc030020 	beqi	r3, 32		// 10001898
                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
            } else {                                            /* If pstr_cmp_1_next NULL, ...                         */
                                                                /* ... rtn neg pstr_cmp_2_next val (see Note #3a2B1).   */
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*pstr_cmp_2_next);
1000187c:	e0630000 	lbui	r3, r3, 0
10001880:	90630060 	sext8	r3, r3
10001884:	14630000 	rsubk	r3, r3, r0
10001888:	b60f0008 	rtsd	r15, 8
1000188c:	90630061 	sext16	r3, r3
            }
        } else {                                                /* If pstr_cmp_2_next NULL, ...                         */
            cmp_val = (CPU_INT16S)(*pstr_cmp_1_next);           /* ... rtn pos pstr_cmp_1_next val (see Note #3a2B2).   */
10001890:	e0680000 	lbui	r3, r8, 0
10001894:	90630060 	sext8	r3, r3
        }
    }


    return (cmp_val);
}
10001898:	b60f0008 	rtsd	r15, 8
1000189c:	80000000 	or	r0, r0, r0

100018a0 <Str_Cmp>:
*********************************************************************************************************
*/

CPU_INT16S  Str_Cmp (CPU_CHAR  *pstr_1,
                     CPU_CHAR  *pstr_2)
{
100018a0:	3021ffe4 	addik	r1, r1, -28
100018a4:	f9e10000 	swi	r15, r1, 0
    CPU_INT16S  cmp_val;


    cmp_val = Str_Cmp_N((CPU_CHAR *)pstr_1,
100018a8:	b9f4ff28 	brlid	r15, -216	// 100017d0 <Str_Cmp_N>
100018ac:	30e0ffff 	addik	r7, r0, -1
                        (CPU_CHAR *)pstr_2,
                        (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (cmp_val);
}
100018b0:	e9e10000 	lwi	r15, r1, 0
100018b4:	b60f0008 	rtsd	r15, 8
100018b8:	3021001c 	addik	r1, r1, 28

100018bc <Str_CmpIgnoreCase_N>:
*/

CPU_INT16S  Str_CmpIgnoreCase_N (CPU_CHAR    *pstr_1,
                                 CPU_CHAR    *pstr_2,
                                 CPU_SIZE_T   len_max)
{
100018bc:	3021fff4 	addik	r1, r1, -12
100018c0:	fa610004 	swi	r19, r1, 4
100018c4:	fac10008 	swi	r22, r1, 8
    CPU_CHAR     char_2;
    CPU_INT16S   cmp_val;
    CPU_SIZE_T   cmp_len;


    if (len_max == 0u) {                                        /* If cmp len = 0,        rtn 0       (see Note #3d1).  */
100018c8:	be0701b8 	beqid	r7, 440		// 10001a80
100018cc:	10670000 	addk	r3, r7, r0
        return ((CPU_INT16S)0);
    }

    if (pstr_1 == (CPU_CHAR *)0) {
100018d0:	bc250014 	bnei	r5, 20		// 100018e4
        if (pstr_2 == (CPU_CHAR *)0) {
100018d4:	be0601ac 	beqid	r6, 428		// 10001a80
100018d8:	10660000 	addk	r3, r6, r0
            return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        }
        char_2  =  ASCII_TO_LOWER(*pstr_2);
100018dc:	b810015c 	brid	348		// 10001a38
100018e0:	e0860000 	lbui	r4, r6, 0
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
        return (cmp_val);                                       /* If pstr_1 NULL, rtn neg pstr_2 val (see Note #3a1B1).*/
    }
    if (pstr_2 == (CPU_CHAR *)0) {
100018e4:	be260030 	bneid	r6, 48		// 10001914
100018e8:	e1050000 	lbui	r8, r5, 0
        char_1  =  ASCII_TO_LOWER(*pstr_1);
100018ec:	90680060 	sext8	r3, r8
100018f0:	a50800ff 	andi	r8, r8, 255
100018f4:	3088ffbf 	addik	r4, r8, -65
100018f8:	a48400ff 	andi	r4, r4, 255
100018fc:	30a00019 	addik	r5, r0, 25
10001900:	14842803 	cmpu	r4, r4, r5
10001904:	be440180 	bltid	r4, 384		// 10001a84
10001908:	ea610004 	lwi	r19, r1, 4
1000190c:	b8100170 	brid	368		// 10001a7c
10001910:	30680020 	addik	r3, r8, 32
    pstr_cmp_2      = pstr_2;
    pstr_cmp_1_next = pstr_cmp_1;
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
    pstr_cmp_2_next++;
    char_1          = ASCII_TO_LOWER(*pstr_cmp_1);
10001914:	90880060 	sext8	r4, r8
10001918:	a50800ff 	andi	r8, r8, 255
1000191c:	3068ffbf 	addik	r3, r8, -65
10001920:	a46300ff 	andi	r3, r3, 255
10001924:	31600019 	addik	r11, r0, 25
10001928:	14635803 	cmpu	r3, r3, r11

    pstr_cmp_1      = pstr_1;
    pstr_cmp_2      = pstr_2;
    pstr_cmp_1_next = pstr_cmp_1;
    pstr_cmp_2_next = pstr_cmp_2;
    pstr_cmp_1_next++;
1000192c:	31450001 	addik	r10, r5, 1
    pstr_cmp_2_next++;
    char_1          = ASCII_TO_LOWER(*pstr_cmp_1);
10001930:	be430010 	bltid	r3, 16		// 10001940
10001934:	31260001 	addik	r9, r6, 1
10001938:	31080020 	addik	r8, r8, 32
1000193c:	90880060 	sext8	r4, r8
    char_2          = ASCII_TO_LOWER(*pstr_cmp_2);
10001940:	e0660000 	lbui	r3, r6, 0
10001944:	31800019 	addik	r12, r0, 25
10001948:	3163ffbf 	addik	r11, r3, -65
1000194c:	a56b00ff 	andi	r11, r11, 255
10001950:	156b6003 	cmpu	r11, r11, r12
10001954:	be4b0010 	bltid	r11, 16		// 10001964
10001958:	91030060 	sext8	r8, r3
1000195c:	30630020 	addik	r3, r3, 32
10001960:	91030060 	sext8	r8, r3
*/

CPU_INT16S  Str_CmpIgnoreCase_N (CPU_CHAR    *pstr_1,
                                 CPU_CHAR    *pstr_2,
                                 CPU_SIZE_T   len_max)
{
10001964:	10600000 	addk	r3, r0, r0
    cmp_len         = 0u;

    while (( char_1          ==  char_2)          &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
10001968:	12630000 	addk	r19, r3, r0
        pstr_cmp_1++;
        pstr_cmp_2++;
        pstr_cmp_1_next++;
        pstr_cmp_2_next++;
        cmp_len++;
        char_1 = ASCII_TO_LOWER(*pstr_cmp_1);
1000196c:	b810005c 	brid	92		// 100019c8
10001970:	31800019 	addik	r12, r0, 25
*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
*********************************************************************************************************
*/

CPU_INT16S  Str_CmpIgnoreCase_N (CPU_CHAR    *pstr_1,
10001974:	10851800 	addk	r4, r5, r3
        pstr_cmp_1++;
        pstr_cmp_2++;
        pstr_cmp_1_next++;
        pstr_cmp_2_next++;
        cmp_len++;
        char_1 = ASCII_TO_LOWER(*pstr_cmp_1);
10001978:	e1040001 	lbui	r8, r4, 1
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
           ( cmp_len         <  (CPU_SIZE_T)len_max)) {         /* ... or max nbr chars cmp'd        (see Note #3d2).   */
        pstr_cmp_1++;
        pstr_cmp_2++;
        pstr_cmp_1_next++;
1000197c:	314a0001 	addik	r10, r10, 1
        pstr_cmp_2_next++;
10001980:	31290001 	addik	r9, r9, 1
        cmp_len++;
        char_1 = ASCII_TO_LOWER(*pstr_cmp_1);
10001984:	3168ffbf 	addik	r11, r8, -65
10001988:	a56b00ff 	andi	r11, r11, 255
1000198c:	156b6003 	cmpu	r11, r11, r12
10001990:	be4b0010 	bltid	r11, 16		// 100019a0
10001994:	90880060 	sext8	r4, r8
10001998:	30880020 	addik	r4, r8, 32
1000199c:	90840060 	sext8	r4, r4
*               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
*********************************************************************************************************
*/

CPU_INT16S  Str_CmpIgnoreCase_N (CPU_CHAR    *pstr_1,
100019a0:	11061800 	addk	r8, r6, r3
        pstr_cmp_2++;
        pstr_cmp_1_next++;
        pstr_cmp_2_next++;
        cmp_len++;
        char_1 = ASCII_TO_LOWER(*pstr_cmp_1);
        char_2 = ASCII_TO_LOWER(*pstr_cmp_2);
100019a4:	e1680001 	lbui	r11, r8, 1
100019a8:	32cbffbf 	addik	r22, r11, -65
100019ac:	a6d600ff 	andi	r22, r22, 255
100019b0:	16d66003 	cmpu	r22, r22, r12
100019b4:	be560010 	bltid	r22, 16		// 100019c4
100019b8:	910b0060 	sext8	r8, r11
100019bc:	310b0020 	addik	r8, r11, 32
100019c0:	91080060 	sext8	r8, r8
100019c4:	30630001 	addik	r3, r3, 1
    pstr_cmp_2_next++;
    char_1          = ASCII_TO_LOWER(*pstr_cmp_1);
    char_2          = ASCII_TO_LOWER(*pstr_cmp_2);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)          &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
100019c8:	89644000 	xor	r11, r4, r8
100019cc:	bc2b0034 	bnei	r11, 52		// 10001a00
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
100019d0:	c1032800 	lbu	r8, r3, r5
100019d4:	91080060 	sext8	r8, r8
100019d8:	8d085c00 	pcmpne	r8, r8, r11
100019dc:	be080020 	beqid	r8, 32		// 100019fc
100019e0:	8d6a5c00 	pcmpne	r11, r10, r11
100019e4:	be0b0018 	beqid	r11, 24		// 100019fc
100019e8:	15071803 	cmpu	r8, r7, r3
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
           ( cmp_len         <  (CPU_SIZE_T)len_max)) {         /* ... or max nbr chars cmp'd        (see Note #3d2).   */
100019ec:	bea80014 	bgeid	r8, 20		// 10001a00
100019f0:	11040000 	addk	r8, r4, r0
    cmp_len         = 0u;

    while (( char_1          ==  char_2)          &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
           ( pstr_cmp_1_next != (CPU_CHAR *)  0 ) &&            /* ... or NULL ptr(s) found          (see Note #3a2);   */
           ( pstr_cmp_2_next != (CPU_CHAR *)  0 ) &&
100019f4:	8d099c00 	pcmpne	r8, r9, r19
100019f8:	bc28ff7c 	bnei	r8, -132		// 10001974
    char_1          = ASCII_TO_LOWER(*pstr_cmp_1);
    char_2          = ASCII_TO_LOWER(*pstr_cmp_2);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)          &&            /* Cmp strs until non-matching chars (see Note #3c) ... */
           (*pstr_cmp_1      != (CPU_CHAR  )'\0') &&            /* ... or NULL chars                 (see Note #3b) ... */
100019fc:	11040000 	addk	r8, r4, r0
        char_1 = ASCII_TO_LOWER(*pstr_cmp_1);
        char_2 = ASCII_TO_LOWER(*pstr_cmp_2);
    }


    if (cmp_len == len_max) {                                   /* If strs     identical for len nbr of chars, ...      */
10001a00:	88633800 	xor	r3, r3, r7
10001a04:	bc03007c 	beqi	r3, 124		// 10001a80
        return ((CPU_INT16S)0);                                 /* ... rtn 0                 (see Note #3d2).           */
    }

    if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
10001a08:	88644000 	xor	r3, r4, r8
10001a0c:	be030010 	beqid	r3, 16		// 10001a1c
10001a10:	14682000 	rsubk	r3, r8, r4
         cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c).            */
10001a14:	b810006c 	brid	108		// 10001a80
10001a18:	90630061 	sext16	r3, r3

    } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
10001a1c:	be040064 	beqid	r4, 100		// 10001a80
10001a20:	10640000 	addk	r3, r4, r0
         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

    } else {
        if (pstr_cmp_1_next == (CPU_CHAR *)0) {
10001a24:	be2a003c 	bneid	r10, 60		// 10001a60
10001a28:	30c00019 	addik	r6, r0, 25
            if (pstr_cmp_2_next == (CPU_CHAR *)0) {             /* If BOTH next str ptrs NULL, ...                      */
10001a2c:	be090054 	beqid	r9, 84		// 10001a80
10001a30:	10690000 	addk	r3, r9, r0
                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
            } else {                                            /* If pstr_cmp_1_next NULL, ...                         */
                char_2  =  ASCII_TO_LOWER(*pstr_cmp_2_next);
10001a34:	e0890000 	lbui	r4, r9, 0
10001a38:	30a4ffbf 	addik	r5, r4, -65
10001a3c:	a4a500ff 	andi	r5, r5, 255
10001a40:	30c00019 	addik	r6, r0, 25
10001a44:	14a53003 	cmpu	r5, r5, r6
10001a48:	be450010 	bltid	r5, 16		// 10001a58
10001a4c:	90640060 	sext8	r3, r4
10001a50:	30640020 	addik	r3, r4, 32
10001a54:	90630060 	sext8	r3, r3
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg pstr_cmp_2_next val (see Note #3a2B1).   */
10001a58:	b810ffbc 	brid	-68		// 10001a14
10001a5c:	14630000 	rsubk	r3, r3, r0
            }
        } else {                                                /* If pstr_cmp_2_next NULL, ...                         */
            char_1  =  ASCII_TO_LOWER(*pstr_cmp_1_next);
10001a60:	e08a0000 	lbui	r4, r10, 0
10001a64:	30a4ffbf 	addik	r5, r4, -65
10001a68:	a4a500ff 	andi	r5, r5, 255
10001a6c:	14a53003 	cmpu	r5, r5, r6
10001a70:	be450010 	bltid	r5, 16		// 10001a80
10001a74:	90640060 	sext8	r3, r4
10001a78:	30640020 	addik	r3, r4, 32
10001a7c:	90630060 	sext8	r3, r3
        }
    }


    return (cmp_val);
}
10001a80:	ea610004 	lwi	r19, r1, 4
10001a84:	eac10008 	lwi	r22, r1, 8
10001a88:	b60f0008 	rtsd	r15, 8
10001a8c:	3021000c 	addik	r1, r1, 12

10001a90 <Str_CmpIgnoreCase>:
*********************************************************************************************************
*/
/*$PAGE*/
CPU_INT16S  Str_CmpIgnoreCase (CPU_CHAR  *pstr_1,
                               CPU_CHAR  *pstr_2)
{
10001a90:	3021ffe4 	addik	r1, r1, -28
10001a94:	f9e10000 	swi	r15, r1, 0
    CPU_INT16S  cmp_val;


    cmp_val = Str_CmpIgnoreCase_N((CPU_CHAR *)pstr_1,
10001a98:	b9f4fe24 	brlid	r15, -476	// 100018bc <Str_CmpIgnoreCase_N>
10001a9c:	30e0ffff 	addik	r7, r0, -1
                                  (CPU_CHAR *)pstr_2,
                                  (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (cmp_val);
}
10001aa0:	e9e10000 	lwi	r15, r1, 0
10001aa4:	b60f0008 	rtsd	r15, 8
10001aa8:	3021001c 	addik	r1, r1, 28

10001aac <Str_Char_N>:
{
    CPU_CHAR    *pstr_char;
    CPU_SIZE_T   len_srch;


    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL (see Note #3a).        */
10001aac:	be050048 	beqid	r5, 72		// 10001af4
10001ab0:	10650000 	addk	r3, r5, r0
        return ((CPU_CHAR *)0);
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if srch len = 0      (see Note #3e).        */
10001ab4:	be060040 	beqid	r6, 64		// 10001af4
10001ab8:	10660000 	addk	r3, r6, r0
10001abc:	10650000 	addk	r3, r5, r0
10001ac0:	b8100010 	brid	16		// 10001ad0
10001ac4:	10a00000 	addk	r5, r0, r0


    pstr_char = pstr;
    len_srch  = 0u;

    while (( pstr_char != (CPU_CHAR *)  0 )      &&             /* Srch str until NULL ptr     [see Note #3b]  ...      */
10001ac8:	be03002c 	beqid	r3, 44		// 10001af4
10001acc:	30a50001 	addik	r5, r5, 1
           (*pstr_char != (CPU_CHAR  )'\0')      &&             /* ... or NULL char            (see Note #3c)  ...      */
10001ad0:	e0830000 	lbui	r4, r3, 0
10001ad4:	90840060 	sext8	r4, r4


    pstr_char = pstr;
    len_srch  = 0u;

    while (( pstr_char != (CPU_CHAR *)  0 )      &&             /* Srch str until NULL ptr     [see Note #3b]  ...      */
10001ad8:	be040024 	beqid	r4, 36		// 10001afc
10001adc:	8d043c00 	pcmpne	r8, r4, r7
           (*pstr_char != (CPU_CHAR  )'\0')      &&             /* ... or NULL char            (see Note #3c)  ...      */
           (*pstr_char != (CPU_CHAR  )srch_char) &&             /* ... or srch char found      (see Note #3d); ...      */
10001ae0:	be08001c 	beqid	r8, 28		// 10001afc
10001ae4:	15062803 	cmpu	r8, r6, r5
           ( len_srch  <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars srch'd (see Note #3e).          */
10001ae8:	bca80014 	bgei	r8, 20		// 10001afc
        pstr_char++;
10001aec:	b810ffdc 	brid	-36		// 10001ac8
10001af0:	30630001 	addik	r3, r3, 1
    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
         return ((CPU_CHAR *)0);
    }

    return (pstr_char);                                         /* Else rtn ptr to found srch char (see Note #3d1).     */
}
10001af4:	b60f0008 	rtsd	r15, 8
10001af8:	80000000 	or	r0, r0, r0
         return ((CPU_CHAR *)0);
    }


    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
         return ((CPU_CHAR *)0);
10001afc:	88843c00 	pcmpeq	r4, r4, r7
10001b00:	14840000 	rsubk	r4, r4, r0
10001b04:	b60f0008 	rtsd	r15, 8
10001b08:	84632000 	and	r3, r3, r4

10001b0c <Str_Char>:
*********************************************************************************************************
*/

CPU_CHAR  *Str_Char (CPU_CHAR  *pstr,
                     CPU_CHAR   srch_char)
{
10001b0c:	10e60000 	addk	r7, r6, r0
10001b10:	3021ffe4 	addik	r1, r1, -28
10001b14:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Char_N((CPU_CHAR *)pstr,
10001b18:	b9f4ff94 	brlid	r15, -108	// 10001aac <Str_Char_N>
10001b1c:	30c0ffff 	addik	r6, r0, -1
                          (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL,
                          (CPU_CHAR  )srch_char);

    return (pstr_rtn);
}
10001b20:	e9e10000 	lwi	r15, r1, 0
10001b24:	b60f0008 	rtsd	r15, 8
10001b28:	3021001c 	addik	r1, r1, 28

10001b2c <Str_Char_Last_N>:
*/
/*$PAGE*/
CPU_CHAR  *Str_Char_Last_N (CPU_CHAR    *pstr,
                            CPU_SIZE_T   len_max,
                            CPU_CHAR     srch_char)
{
10001b2c:	3021ffdc 	addik	r1, r1, -36
10001b30:	fa61001c 	swi	r19, r1, 28
10001b34:	fac10020 	swi	r22, r1, 32
10001b38:	f9e10000 	swi	r15, r1, 0
10001b3c:	12650000 	addk	r19, r5, r0
10001b40:	12c70000 	addk	r22, r7, r0
    CPU_CHAR    *pstr_char;
    CPU_SIZE_T   str_len_max;
    CPU_SIZE_T   str_len;


    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL (see Note #3a).        */
10001b44:	be050060 	beqid	r5, 96		// 10001ba4
10001b48:	10650000 	addk	r3, r5, r0
        return ((CPU_CHAR *)0);
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if srch len = 0      (see Note #3e).        */
10001b4c:	be060058 	beqid	r6, 88		// 10001ba4
10001b50:	10660000 	addk	r3, r6, r0
    }


    pstr_char    = pstr;
     str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
     str_len     = Str_Len_N(pstr_char, str_len_max);
10001b54:	b9f4fab0 	brlid	r15, -1360	// 10001604 <Str_Len_N>
10001b58:	30c6ffff 	addik	r6, r6, -1
    pstr_char   += str_len;
10001b5c:	10731800 	addk	r3, r19, r3

    if (pstr_char == (CPU_CHAR *)0) {                           /* Rtn NULL if NULL ptr found       (see Note #3b1).    */
10001b60:	be230014 	bneid	r3, 20		// 10001b74
10001b64:	88839800 	xor	r4, r3, r19
    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found  (see Note #3c1).    */
         return ((CPU_CHAR *)0);
    }

    return (pstr_char);                                         /* Else rtn ptr to found srch char  (see Note #3d1).    */
}
10001b68:	b8100040 	brid	64		// 10001ba8
10001b6c:	e9e10000 	lwi	r15, r1, 0

    if (pstr_char == (CPU_CHAR *)0) {                           /* Rtn NULL if NULL ptr found       (see Note #3b1).    */
        return ((CPU_CHAR *)0);
    }

    while (( pstr_char != pstr) &&                              /* Srch str from end until begining (see Note #3c) ...  */
10001b70:	88839800 	xor	r4, r3, r19
10001b74:	bc04001c 	beqi	r4, 28		// 10001b90
10001b78:	e0830000 	lbui	r4, r3, 0
10001b7c:	90840060 	sext8	r4, r4
10001b80:	8884b000 	xor	r4, r4, r22
10001b84:	be24ffec 	bneid	r4, -20		// 10001b70
10001b88:	3063ffff 	addik	r3, r3, -1
10001b8c:	30630001 	addik	r3, r3, 1
           (*pstr_char != srch_char)) {                         /* ... until srch char found        (see Note #3d).     */
        pstr_char--;
    }


    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found  (see Note #3c1).    */
10001b90:	e0830000 	lbui	r4, r3, 0
10001b94:	90840060 	sext8	r4, r4
         return ((CPU_CHAR *)0);
10001b98:	8ac4b400 	pcmpeq	r22, r4, r22
10001b9c:	16d60000 	rsubk	r22, r22, r0
10001ba0:	8463b000 	and	r3, r3, r22
    }

    return (pstr_char);                                         /* Else rtn ptr to found srch char  (see Note #3d1).    */
}
10001ba4:	e9e10000 	lwi	r15, r1, 0
10001ba8:	ea61001c 	lwi	r19, r1, 28
10001bac:	eac10020 	lwi	r22, r1, 32
10001bb0:	b60f0008 	rtsd	r15, 8
10001bb4:	30210024 	addik	r1, r1, 36

10001bb8 <Str_Char_Last>:
*********************************************************************************************************
*/

CPU_CHAR  *Str_Char_Last (CPU_CHAR  *pstr,
                          CPU_CHAR   srch_char)
{
10001bb8:	10e60000 	addk	r7, r6, r0
10001bbc:	3021ffe4 	addik	r1, r1, -28
10001bc0:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Char_Last_N((CPU_CHAR *)pstr,
10001bc4:	b9f4ff68 	brlid	r15, -152	// 10001b2c <Str_Char_Last_N>
10001bc8:	30c0ffff 	addik	r6, r0, -1
                               (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL,
                               (CPU_CHAR  )srch_char);

    return (pstr_rtn);
}
10001bcc:	e9e10000 	lwi	r15, r1, 0
10001bd0:	b60f0008 	rtsd	r15, 8
10001bd4:	3021001c 	addik	r1, r1, 28

10001bd8 <Str_Str_N>:
*/
/*$PAGE*/
CPU_CHAR  *Str_Str_N (CPU_CHAR    *pstr,
                      CPU_CHAR    *pstr_srch,
                      CPU_SIZE_T   len_max)
{
10001bd8:	3021ffc8 	addik	r1, r1, -56
10001bdc:	fa61001c 	swi	r19, r1, 28
10001be0:	fac10020 	swi	r22, r1, 32
10001be4:	f9e10000 	swi	r15, r1, 0
10001be8:	fae10024 	swi	r23, r1, 36
10001bec:	fb010028 	swi	r24, r1, 40
10001bf0:	fb21002c 	swi	r25, r1, 44
10001bf4:	fb410030 	swi	r26, r1, 48
10001bf8:	fb610034 	swi	r27, r1, 52
10001bfc:	12650000 	addk	r19, r5, r0
    CPU_INT16S    srch_cmp;
    CPU_CHAR     *pstr_str;
    CPU_CHAR     *pstr_srch_ix;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (CPU_CHAR *)0) {
10001c00:	be0500c0 	beqid	r5, 192		// 10001cc0
10001c04:	12c60000 	addk	r22, r6, r0
        return ((CPU_CHAR *)0);
    }
    if (pstr_srch == (CPU_CHAR *)0) {
10001c08:	bc06009c 	beqi	r6, 156		// 10001ca4
        return ((CPU_CHAR *)0);
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if srch len = 0    (see Note #3g).          */
10001c0c:	be0700a0 	beqid	r7, 160		// 10001cac
10001c10:	a867ffff 	xori	r3, r7, -1
        return ((CPU_CHAR *)0);
    }

                                                                /* Lim max srch str len (to chk > str len).             */
    len_max_srch = (len_max <      DEF_INT_CPU_U_MAX_VAL)
                 ? (len_max + 1) : DEF_INT_CPU_U_MAX_VAL;
10001c14:	be03000c 	beqid	r3, 12		// 10001c20
10001c18:	3300ffff 	addik	r24, r0, -1
10001c1c:	33070001 	addik	r24, r7, 1

    str_len      = Str_Len_N(pstr,      len_max);
10001c20:	10c70000 	addk	r6, r7, r0
10001c24:	b9f4f9e0 	brlid	r15, -1568	// 10001604 <Str_Len_N>
10001c28:	10b30000 	addk	r5, r19, r0
    str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
10001c2c:	10d80000 	addk	r6, r24, r0
10001c30:	10b60000 	addk	r5, r22, r0
10001c34:	b9f4f9d0 	brlid	r15, -1584	// 10001604 <Str_Len_N>
10001c38:	12e30000 	addk	r23, r3, r0
    if (str_len_srch == 0u) {                                   /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
10001c3c:	be030084 	beqid	r3, 132		// 10001cc0
10001c40:	13030000 	addk	r24, r3, r0
        return ((CPU_CHAR *)pstr);
    }
    if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
10001c44:	1463b803 	cmpu	r3, r3, r23
10001c48:	be43006c 	bltid	r3, 108		// 10001cb4
10001c4c:	1073b800 	addk	r3, r19, r23
        return ((CPU_CHAR *)0);
    }
                                                                /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
    pstr_str = pstr      + str_len;
    if (pstr_str == (CPU_CHAR *)0) {
10001c50:	bc03006c 	beqi	r3, 108		// 10001cbc
        return ((CPU_CHAR *)0);
    }
    pstr_str = pstr_srch + str_len_srch;
10001c54:	1076c000 	addk	r3, r22, r24
    if (pstr_str == (CPU_CHAR *)0) {
10001c58:	be030064 	beqid	r3, 100		// 10001cbc
10001c5c:	1778b800 	rsubk	r27, r24, r23
        return ((CPU_CHAR *)0);
    }


    srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
    srch_ix   = 0u;
10001c60:	12e00000 	addk	r23, r0, r0
    do {
        pstr_srch_ix = (CPU_CHAR *)(pstr + srch_ix);
        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
        srch_ix++;
    } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
10001c64:	13570000 	addk	r26, r23, r0
*                       (1) 'len_max' number of characters does NOT include terminating NULL character
*                           (see Note #2a2).
*********************************************************************************************************
*/
/*$PAGE*/
CPU_CHAR  *Str_Str_N (CPU_CHAR    *pstr,
10001c68:	1333b800 	addk	r25, r19, r23
    srch_ix   = 0u;
    srch_done = DEF_NO;

    do {
        pstr_srch_ix = (CPU_CHAR *)(pstr + srch_ix);
        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
10001c6c:	10b90000 	addk	r5, r25, r0
10001c70:	10d60000 	addk	r6, r22, r0
10001c74:	10f80000 	addk	r7, r24, r0
10001c78:	b9f4fb58 	brlid	r15, -1192	// 100017d0 <Str_Cmp_N>
10001c7c:	32f70001 	addik	r23, r23, 1
        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
        srch_ix++;
    } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
10001c80:	1497d803 	cmpu	r4, r23, r27
10001c84:	be44000c 	bltid	r4, 12		// 10001c90
10001c88:	8c83d400 	pcmpne	r4, r3, r26
10001c8c:	bc24ffdc 	bnei	r4, -36		// 10001c68


    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
        return ((CPU_CHAR *)0);
10001c90:	12600000 	addk	r19, r0, r0
10001c94:	8a639c00 	pcmpeq	r19, r3, r19
10001c98:	16730000 	rsubk	r19, r19, r0
10001c9c:	b8100024 	brid	36		// 10001cc0
10001ca0:	86799800 	and	r19, r25, r19
                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
    }
    if (pstr_srch == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
10001ca4:	b810001c 	brid	28		// 10001cc0
10001ca8:	12660000 	addk	r19, r6, r0
    }

    if (len_max == (CPU_SIZE_T)0u) {                            /* Rtn NULL if srch len = 0    (see Note #3g).          */
        return ((CPU_CHAR *)0);
10001cac:	b8100014 	brid	20		// 10001cc0
10001cb0:	12670000 	addk	r19, r7, r0
    str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
    if (str_len_srch == 0u) {                                   /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
        return ((CPU_CHAR *)pstr);
    }
    if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
        return ((CPU_CHAR *)0);
10001cb4:	b810000c 	brid	12		// 10001cc0
10001cb8:	12600000 	addk	r19, r0, r0
    if (pstr_str == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
    }
    pstr_str = pstr_srch + str_len_srch;
    if (pstr_str == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
10001cbc:	12630000 	addk	r19, r3, r0
    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
        return ((CPU_CHAR *)0);
    }

    return (pstr_srch_ix);                                      /* Else rtn ptr to found srch str (see Note #3f1).      */
}
10001cc0:	10730000 	addk	r3, r19, r0
10001cc4:	e9e10000 	lwi	r15, r1, 0
10001cc8:	ea61001c 	lwi	r19, r1, 28
10001ccc:	eac10020 	lwi	r22, r1, 32
10001cd0:	eae10024 	lwi	r23, r1, 36
10001cd4:	eb010028 	lwi	r24, r1, 40
10001cd8:	eb21002c 	lwi	r25, r1, 44
10001cdc:	eb410030 	lwi	r26, r1, 48
10001ce0:	eb610034 	lwi	r27, r1, 52
10001ce4:	b60f0008 	rtsd	r15, 8
10001ce8:	30210038 	addik	r1, r1, 56

10001cec <Str_Str>:
*********************************************************************************************************
*/

CPU_CHAR  *Str_Str (CPU_CHAR  *pstr,
                    CPU_CHAR  *pstr_srch)
{
10001cec:	3021ffe4 	addik	r1, r1, -28
10001cf0:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Str_N((CPU_CHAR *)pstr,
10001cf4:	b9f4fee4 	brlid	r15, -284	// 10001bd8 <Str_Str_N>
10001cf8:	30e0ffff 	addik	r7, r0, -1
                         (CPU_CHAR *)pstr_srch,
                         (CPU_SIZE_T)DEF_INT_CPU_U_MAX_VAL);

    return (pstr_rtn);
}
10001cfc:	e9e10000 	lwi	r15, r1, 0
10001d00:	b60f0008 	rtsd	r15, 8
10001d04:	3021001c 	addik	r1, r1, 28

10001d08 <Str_FmtNbr_Int32U>:
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
10001d08:	10880000 	addk	r4, r8, r0
10001d0c:	10690000 	addk	r3, r9, r0
10001d10:	3021ffdc 	addik	r1, r1, -36
    CPU_CHAR  *pstr_fmt;


    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U )nbr,               /* Fmt unsigned int into str.                           */
10001d14:	e9010040 	lwi	r8, r1, 64
10001d18:	f941001c 	swi	r10, r1, 28
10001d1c:	11240000 	addk	r9, r4, r0
10001d20:	11430000 	addk	r10, r3, r0
10001d24:	f9010020 	swi	r8, r1, 32
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
10001d28:	f9e10000 	swi	r15, r1, 0
    CPU_CHAR  *pstr_fmt;


    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U )nbr,               /* Fmt unsigned int into str.                           */
10001d2c:	b9f4f434 	brlid	r15, -3020	// 10001160 <Str_FmtNbr_Int32>
10001d30:	11000000 	addk	r8, r0, r0
                                (CPU_BOOLEAN)lower_case,
                                (CPU_BOOLEAN)nul,
                                (CPU_CHAR  *)pstr);

    return (pstr_fmt);
}
10001d34:	e9e10000 	lwi	r15, r1, 0
10001d38:	b60f0008 	rtsd	r15, 8
10001d3c:	30210024 	addik	r1, r1, 36

10001d40 <Str_FmtNbr_Int32S>:
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
10001d40:	3021ffdc 	addik	r1, r1, -36
10001d44:	f9e10000 	swi	r15, r1, 0
10001d48:	11680000 	addk	r11, r8, r0
10001d4c:	10890000 	addk	r4, r9, r0
    CPU_INT32S    nbr_fmt;
    CPU_BOOLEAN   nbr_neg;


    nbr_fmt = nbr;
    if (nbr_fmt < 0) {                                          /* If nbr neg, ...                                      */
10001d50:	bea50010 	bgeid	r5, 16		// 10001d60
10001d54:	10600000 	addk	r3, r0, r0
        nbr_fmt = -nbr_fmt;                                     /* ... negate nbr.                                      */
10001d58:	14a50000 	rsubk	r5, r5, r0
        nbr_neg =  DEF_YES;
10001d5c:	30600001 	addik	r3, r0, 1
    } else {
        nbr_neg =  DEF_NO;
    }

    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U )nbr_fmt,           /* Fmt signed int into str.                             */
10001d60:	e9010040 	lwi	r8, r1, 64
10001d64:	f941001c 	swi	r10, r1, 28
10001d68:	112b0000 	addk	r9, r11, r0
10001d6c:	f9010020 	swi	r8, r1, 32
10001d70:	11440000 	addk	r10, r4, r0
10001d74:	b9f4f3ec 	brlid	r15, -3092	// 10001160 <Str_FmtNbr_Int32>
10001d78:	11030000 	addk	r8, r3, r0
                                (CPU_BOOLEAN)lower_case,
                                (CPU_BOOLEAN)nul,
                                (CPU_CHAR  *)pstr);

    return (pstr_fmt);
}
10001d7c:	e9e10000 	lwi	r15, r1, 0
10001d80:	b60f0008 	rtsd	r15, 8
10001d84:	30210024 	addik	r1, r1, 36

10001d88 <Str_ParseNbr_Int32U>:
                                 CPU_INT08U    nbr_base)
{
    CPU_INT32U  nbr;


    nbr = Str_ParseNbr_Int32((CPU_CHAR    *)pstr,               /* Parse/convert str ...                                */
10001d88:	11000000 	addk	r8, r0, r0
*/

CPU_INT32U  Str_ParseNbr_Int32U (CPU_CHAR     *pstr,
                                 CPU_CHAR    **pstr_next,
                                 CPU_INT08U    nbr_base)
{
10001d8c:	3021ffe4 	addik	r1, r1, -28
10001d90:	f9e10000 	swi	r15, r1, 0
    CPU_INT32U  nbr;


    nbr = Str_ParseNbr_Int32((CPU_CHAR    *)pstr,               /* Parse/convert str ...                                */
10001d94:	b9f4f5b0 	brlid	r15, -2640	// 10001344 <Str_ParseNbr_Int32>
10001d98:	11280000 	addk	r9, r8, r0
                             (CPU_INT08U   )nbr_base,
                             (CPU_BOOLEAN  )DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
                             (CPU_BOOLEAN *)0);

    return (nbr);
}
10001d9c:	e9e10000 	lwi	r15, r1, 0
10001da0:	b60f0008 	rtsd	r15, 8
10001da4:	3021001c 	addik	r1, r1, 28

10001da8 <Str_ParseNbr_Int32S>:
*/

CPU_INT32S  Str_ParseNbr_Int32S (CPU_CHAR     *pstr,
                                 CPU_CHAR    **pstr_next,
                                 CPU_INT08U    nbr_base)
{
10001da8:	3021ffe0 	addik	r1, r1, -32
    CPU_INT32S   nbr;
    CPU_INT32U   nbr_abs;
    CPU_BOOLEAN  nbr_neg;


    nbr_abs = Str_ParseNbr_Int32((CPU_CHAR    *) pstr,          /* Parse/convert str ...                                */
10001dac:	31000001 	addik	r8, r0, 1
*/

CPU_INT32S  Str_ParseNbr_Int32S (CPU_CHAR     *pstr,
                                 CPU_CHAR    **pstr_next,
                                 CPU_INT08U    nbr_base)
{
10001db0:	f9e10000 	swi	r15, r1, 0
    CPU_INT32S   nbr;
    CPU_INT32U   nbr_abs;
    CPU_BOOLEAN  nbr_neg;


    nbr_abs = Str_ParseNbr_Int32((CPU_CHAR    *) pstr,          /* Parse/convert str ...                                */
10001db4:	b9f4f590 	brlid	r15, -2672	// 10001344 <Str_ParseNbr_Int32>
10001db8:	3121001c 	addik	r9, r1, 28
10001dbc:	10830000 	addk	r4, r3, r0
                                 (CPU_CHAR   **) pstr_next,
                                 (CPU_INT08U   ) nbr_base,
                                 (CPU_BOOLEAN  ) DEF_YES,       /* ... as signed int (see Note #2a2).                   */
                                 (CPU_BOOLEAN *)&nbr_neg);

    if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
10001dc0:	e061001c 	lbui	r3, r1, 28
10001dc4:	bc230010 	bnei	r3, 16		// 10001dd4
        nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
                                                                    :  (CPU_INT32S)nbr_abs;
10001dc8:	bea4002c 	bgeid	r4, 44		// 10001df4
10001dcc:	10640000 	addk	r3, r4, r0
10001dd0:	b800001c 	bri	28		// 10001dec
    } else {
        nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
                                                                    : -(CPU_INT32S)nbr_abs;
10001dd4:	b0008000 	imm	-32768
10001dd8:	30600000 	addik	r3, r0, 0
10001ddc:	be44001c 	bltid	r4, 28		// 10001df8
10001de0:	e9e10000 	lwi	r15, r1, 0
10001de4:	b8100014 	brid	20		// 10001df8
10001de8:	14640000 	rsubk	r3, r4, r0
                                 (CPU_BOOLEAN  ) DEF_YES,       /* ... as signed int (see Note #2a2).                   */
                                 (CPU_BOOLEAN *)&nbr_neg);

    if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
        nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
                                                                    :  (CPU_INT32S)nbr_abs;
10001dec:	b0007fff 	imm	32767
10001df0:	3060ffff 	addik	r3, r0, -1
        nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
                                                                    : -(CPU_INT32S)nbr_abs;
    }

    return (nbr);
}
10001df4:	e9e10000 	lwi	r15, r1, 0
10001df8:	b60f0008 	rtsd	r15, 8
10001dfc:	30210020 	addik	r1, r1, 32

10001e00 <OS_SchedNew>:
{
#if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
10001e00:	b0001000 	imm	4096
10001e04:	306089f4 	addik	r3, r0, -30220	// 100089f4 <OSUnMapTbl>
10001e08:	b0001000 	imm	4096
10001e0c:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10001e10:	c0841800 	lbu	r4, r4, r3
    OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
10001e14:	b0001000 	imm	4096
10001e18:	e0a4d3fc 	lbui	r5, r4, -11268
10001e1c:	64840403 	bslli	r4, r4, 3
10001e20:	c0651800 	lbu	r3, r5, r3
10001e24:	10832000 	addk	r4, r3, r4
10001e28:	b0001000 	imm	4096
10001e2c:	f080ce22 	sbi	r4, r0, -12766	// 1000ce22 <OSPrioHighRdy>
        OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl >> 8u) & 0xFFu] + 8u);
    }
#endif
}
10001e30:	b60f0008 	rtsd	r15, 8
10001e34:	80000000 	or	r0, r0, r0

10001e38 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
10001e38:	3021ffe4 	addik	r1, r1, -28
10001e3c:	f9e10000 	swi	r15, r1, 0



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
10001e40:	b9f460ec 	brlid	r15, 24812	// 10007f2c <OS_CPU_SR_Save>
10001e44:	80000000 	or	r0, r0, r0
        OSIdleCtr++;
10001e48:	b0001000 	imm	4096
10001e4c:	e880ce1c 	lwi	r4, r0, -12772	// 1000ce1c <OSIdleCtr>
        OS_EXIT_CRITICAL();
10001e50:	10a30000 	addk	r5, r3, r0


    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtr++;
10001e54:	30840001 	addik	r4, r4, 1
10001e58:	b0001000 	imm	4096
10001e5c:	f880ce1c 	swi	r4, r0, -12772	// 1000ce1c <OSIdleCtr>
        OS_EXIT_CRITICAL();
10001e60:	b9f460fc 	brlid	r15, 24828	// 10007f5c <OS_CPU_SR_Restore>
10001e64:	80000000 	or	r0, r0, r0
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
10001e68:	b9f45dc4 	brlid	r15, 24004	// 10007c2c <OSTaskIdleHook>
10001e6c:	80000000 	or	r0, r0, r0
10001e70:	b800ffd0 	bri	-48		// 10001e40

10001e74 <OSEventNameSet>:

#if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
void  OSEventNameSet (OS_EVENT  *pevent,
                      INT8U     *pname,
                      INT8U     *perr)
{
10001e74:	3021ffd4 	addik	r1, r1, -44
10001e78:	fac10020 	swi	r22, r1, 32
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10001e7c:	b0001000 	imm	4096
10001e80:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>

#if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
void  OSEventNameSet (OS_EVENT  *pevent,
                      INT8U     *pname,
                      INT8U     *perr)
{
10001e84:	fa61001c 	swi	r19, r1, 28
10001e88:	fae10024 	swi	r23, r1, 36
10001e8c:	fb010028 	swi	r24, r1, 40
10001e90:	f9e10000 	swi	r15, r1, 0
10001e94:	12e50000 	addk	r23, r5, r0
10001e98:	13060000 	addk	r24, r6, r0
10001e9c:	12670000 	addk	r19, r7, r0
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10001ea0:	be360020 	bneid	r22, 32		// 10001ec0
10001ea4:	30600012 	addik	r3, r0, 18
        *perr = OS_ERR_NAME_SET_ISR;
        return;
    }
    switch (pevent->OSEventType) {
10001ea8:	e0650000 	lbui	r3, r5, 0
10001eac:	30800003 	addik	r4, r0, 3
10001eb0:	3063ffff 	addik	r3, r3, -1
10001eb4:	14632003 	cmpu	r3, r3, r4
10001eb8:	bea30010 	bgeid	r3, 16		// 10001ec8
10001ebc:	30600001 	addik	r3, r0, 1
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
10001ec0:	b8100020 	brid	32		// 10001ee0
10001ec4:	f0730000 	sbi	r3, r19, 0
    }
    OS_ENTER_CRITICAL();
10001ec8:	b9f46064 	brlid	r15, 24676	// 10007f2c <OS_CPU_SR_Save>
10001ecc:	80000000 	or	r0, r0, r0
    pevent->OSEventName = pname;
    OS_EXIT_CRITICAL();
10001ed0:	10a30000 	addk	r5, r3, r0
10001ed4:	b9f46088 	brlid	r15, 24712	// 10007f5c <OS_CPU_SR_Restore>
10001ed8:	fb170014 	swi	r24, r23, 20
    *perr = OS_ERR_NONE;
10001edc:	f2d30000 	sbi	r22, r19, 0
}
10001ee0:	e9e10000 	lwi	r15, r1, 0
10001ee4:	ea61001c 	lwi	r19, r1, 28
10001ee8:	eac10020 	lwi	r22, r1, 32
10001eec:	eae10024 	lwi	r23, r1, 36
10001ef0:	eb010028 	lwi	r24, r1, 40
10001ef4:	b60f0008 	rtsd	r15, 8
10001ef8:	3021002c 	addik	r1, r1, 44

10001efc <OSIntEnter>:
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    if (OSRunning == OS_TRUE) {
10001efc:	b0001000 	imm	4096
10001f00:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
10001f04:	a8630001 	xori	r3, r3, 1
10001f08:	bc230020 	bnei	r3, 32		// 10001f28
        if (OSIntNesting < 255u) {
10001f0c:	b0001000 	imm	4096
10001f10:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10001f14:	a88300ff 	xori	r4, r3, 255
10001f18:	bc040010 	beqi	r4, 16		// 10001f28
            OSIntNesting++;                      /* Increment ISR nesting level                        */
10001f1c:	30630001 	addik	r3, r3, 1
10001f20:	b0001000 	imm	4096
10001f24:	f060d608 	sbi	r3, r0, -10744	// 1000d608 <OSIntNesting>
10001f28:	b60f0008 	rtsd	r15, 8
10001f2c:	80000000 	or	r0, r0, r0

10001f30 <OSIntExit>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {
10001f30:	b0001000 	imm	4096
10001f34:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
10001f38:	3021ffe0 	addik	r1, r1, -32
10001f3c:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {
10001f40:	a8630001 	xori	r3, r3, 1
10001f44:	be2300a8 	bneid	r3, 168		// 10001fec
10001f48:	fa61001c 	swi	r19, r1, 28
        OS_ENTER_CRITICAL();
10001f4c:	b9f45fe0 	brlid	r15, 24544	// 10007f2c <OS_CPU_SR_Save>
10001f50:	80000000 	or	r0, r0, r0
        if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
10001f54:	b0001000 	imm	4096
10001f58:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
10001f5c:	be040014 	beqid	r4, 20		// 10001f70
10001f60:	12630000 	addk	r19, r3, r0
            OSIntNesting--;
10001f64:	3084ffff 	addik	r4, r4, -1
10001f68:	b0001000 	imm	4096
10001f6c:	f080d608 	sbi	r4, r0, -10744	// 1000d608 <OSIntNesting>
        }
        if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
10001f70:	b0001000 	imm	4096
10001f74:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10001f78:	bc23006c 	bnei	r3, 108		// 10001fe4
            if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
10001f7c:	b0001000 	imm	4096
10001f80:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
10001f84:	bc230060 	bnei	r3, 96		// 10001fe4
                OS_SchedNew();
10001f88:	b9f4fe78 	brlid	r15, -392	// 10001e00 <OS_SchedNew>
10001f8c:	80000000 	or	r0, r0, r0
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];                
10001f90:	b0001000 	imm	4096
10001f94:	e0c0ce22 	lbui	r6, r0, -12766	// 1000ce22 <OSPrioHighRdy>
10001f98:	64660402 	bslli	r3, r6, 2
10001f9c:	b0001000 	imm	4096
10001fa0:	e883e0a4 	lwi	r4, r3, -8028
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
10001fa4:	b0001000 	imm	4096
10001fa8:	e060d0f4 	lbui	r3, r0, -12044	// 1000d0f4 <OSPrioCur>
            OSIntNesting--;
        }
        if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
                OS_SchedNew();
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];                
10001fac:	b0001000 	imm	4096
10001fb0:	f880d3f0 	swi	r4, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
10001fb4:	88c33000 	xor	r6, r3, r6
10001fb8:	bc06002c 	beqi	r6, 44		// 10001fe4
#if OS_TASK_PROFILE_EN > 0u
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
10001fbc:	e864003c 	lwi	r3, r4, 60
10001fc0:	30630001 	addik	r3, r3, 1
10001fc4:	f864003c 	swi	r3, r4, 60
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
10001fc8:	b0001000 	imm	4096
10001fcc:	e860d378 	lwi	r3, r0, -11400	// 1000d378 <OSCtxSwCtr>
10001fd0:	30630001 	addik	r3, r3, 1
10001fd4:	b0001000 	imm	4096
10001fd8:	f860d378 	swi	r3, r0, -11400	// 1000d378 <OSCtxSwCtr>
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
10001fdc:	b9f461a0 	brlid	r15, 24992	// 1000817c <OSIntCtxSw>
10001fe0:	80000000 	or	r0, r0, r0
                }
            }
        }
        OS_EXIT_CRITICAL();
10001fe4:	b9f45f78 	brlid	r15, 24440	// 10007f5c <OS_CPU_SR_Restore>
10001fe8:	10b30000 	addk	r5, r19, r0
    }
}
10001fec:	e9e10000 	lwi	r15, r1, 0
10001ff0:	ea61001c 	lwi	r19, r1, 28
10001ff4:	b60f0008 	rtsd	r15, 8
10001ff8:	30210020 	addik	r1, r1, 32

10001ffc <OSSchedLock>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
10001ffc:	b0001000 	imm	4096
10002000:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0u
void  OSSchedLock (void)
{
10002004:	3021ffe4 	addik	r1, r1, -28
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
10002008:	a8630001 	xori	r3, r3, 1
1000200c:	be230040 	bneid	r3, 64		// 1000204c
10002010:	f9e10000 	swi	r15, r1, 0
        OS_ENTER_CRITICAL();
10002014:	b9f45f18 	brlid	r15, 24344	// 10007f2c <OS_CPU_SR_Save>
10002018:	80000000 	or	r0, r0, r0
        if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
1000201c:	b0001000 	imm	4096
10002020:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
10002024:	bc240020 	bnei	r4, 32		// 10002044
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
10002028:	b0001000 	imm	4096
1000202c:	e080ce10 	lbui	r4, r0, -12784	// 1000ce10 <OSLockNesting>
10002030:	a8a400ff 	xori	r5, r4, 255
10002034:	be050010 	beqid	r5, 16		// 10002044
10002038:	30840001 	addik	r4, r4, 1
                OSLockNesting++;                 /* Increment lock nesting level                       */
1000203c:	b0001000 	imm	4096
10002040:	f080ce10 	sbi	r4, r0, -12784	// 1000ce10 <OSLockNesting>
            }
        }
        OS_EXIT_CRITICAL();
10002044:	b9f45f18 	brlid	r15, 24344	// 10007f5c <OS_CPU_SR_Restore>
10002048:	10a30000 	addk	r5, r3, r0
    }
}
1000204c:	e9e10000 	lwi	r15, r1, 0
10002050:	b60f0008 	rtsd	r15, 8
10002054:	3021001c 	addik	r1, r1, 28

10002058 <OSStart>:
*********************************************************************************************************
*/

void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
10002058:	b0001000 	imm	4096
1000205c:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
10002060:	3021ffe4 	addik	r1, r1, -28
    if (OSRunning == OS_FALSE) {
10002064:	be230044 	bneid	r3, 68		// 100020a8
10002068:	f9e10000 	swi	r15, r1, 0
        OS_SchedNew();                               /* Find highest priority's task priority number   */
1000206c:	b9f4fd94 	brlid	r15, -620	// 10001e00 <OS_SchedNew>
10002070:	80000000 	or	r0, r0, r0
        OSPrioCur     = OSPrioHighRdy;
10002074:	b0001000 	imm	4096
10002078:	e060ce22 	lbui	r3, r0, -12766	// 1000ce22 <OSPrioHighRdy>
1000207c:	b0001000 	imm	4096
10002080:	f060d0f4 	sbi	r3, r0, -12044	// 1000d0f4 <OSPrioCur>
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
10002084:	64630402 	bslli	r3, r3, 2
10002088:	b0001000 	imm	4096
1000208c:	e863e0a4 	lwi	r3, r3, -8028
10002090:	b0001000 	imm	4096
10002094:	f860d3f0 	swi	r3, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
        OSTCBCur      = OSTCBHighRdy;
10002098:	b0001000 	imm	4096
1000209c:	f860d60c 	swi	r3, r0, -10740	// 1000d60c <OSTCBCur>
        OSStartHighRdy();                            /* Execute target specific code to start task     */
100020a0:	b9f45ec4 	brlid	r15, 24260	// 10007f64 <OSStartHighRdy>
100020a4:	80000000 	or	r0, r0, r0
    }
}
100020a8:	e9e10000 	lwi	r15, r1, 0
100020ac:	b60f0008 	rtsd	r15, 8
100020b0:	3021001c 	addik	r1, r1, 28

100020b4 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0u
void  OSStatInit (void)
{
100020b4:	3021ffe4 	addik	r1, r1, -28
100020b8:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
100020bc:	b9f44d48 	brlid	r15, 19784	// 10006e04 <OSTimeDly>
100020c0:	30a00002 	addik	r5, r0, 2	// 2 <CPU_IE_BIT>
    OS_ENTER_CRITICAL();
100020c4:	b9f45e68 	brlid	r15, 24168	// 10007f2c <OS_CPU_SR_Save>
100020c8:	80000000 	or	r0, r0, r0
    OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
    OS_EXIT_CRITICAL();
100020cc:	10a30000 	addk	r5, r3, r0



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
    OS_ENTER_CRITICAL();
    OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
100020d0:	b0001000 	imm	4096
100020d4:	f800ce1c 	swi	r0, r0, -12772	// 1000ce1c <OSIdleCtr>
    OS_EXIT_CRITICAL();
100020d8:	b9f45e84 	brlid	r15, 24196	// 10007f5c <OS_CPU_SR_Restore>
100020dc:	80000000 	or	r0, r0, r0
    OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
100020e0:	b9f44d24 	brlid	r15, 19748	// 10006e04 <OSTimeDly>
100020e4:	30a0000a 	addik	r5, r0, 10
    OS_ENTER_CRITICAL();
100020e8:	b9f45e44 	brlid	r15, 24132	// 10007f2c <OS_CPU_SR_Save>
100020ec:	80000000 	or	r0, r0, r0
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
100020f0:	b0001000 	imm	4096
100020f4:	e880ce1c 	lwi	r4, r0, -12772	// 1000ce1c <OSIdleCtr>
100020f8:	b0001000 	imm	4096
100020fc:	f880d380 	swi	r4, r0, -11392	// 1000d380 <OSIdleCtrMax>
    OSStatRdy    = OS_TRUE;
10002100:	30800001 	addik	r4, r0, 1
10002104:	b0001000 	imm	4096
10002108:	f080e0a0 	sbi	r4, r0, -8032	// 1000e0a0 <OSStatRdy>
    OS_EXIT_CRITICAL();
1000210c:	b9f45e50 	brlid	r15, 24144	// 10007f5c <OS_CPU_SR_Restore>
10002110:	10a30000 	addk	r5, r3, r0
}
10002114:	e9e10000 	lwi	r15, r1, 0
10002118:	b60f0008 	rtsd	r15, 8
1000211c:	3021001c 	addik	r1, r1, 28

10002120 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
10002120:	3021ffe0 	addik	r1, r1, -32
10002124:	f9e10000 	swi	r15, r1, 0
#endif



#if OS_TIME_TICK_HOOK_EN > 0u
    OSTimeTickHook();                                      /* Call user definable hook                     */
10002128:	b9f45c84 	brlid	r15, 23684	// 10007dac <OSTimeTickHook>
1000212c:	fa61001c 	swi	r19, r1, 28
#endif
#if OS_TIME_GET_SET_EN > 0u
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
10002130:	b9f45dfc 	brlid	r15, 24060	// 10007f2c <OS_CPU_SR_Save>
10002134:	80000000 	or	r0, r0, r0
    OSTime++;
10002138:	b0001000 	imm	4096
1000213c:	e880d614 	lwi	r4, r0, -10732	// 1000d614 <OSTime>
    OS_EXIT_CRITICAL();
10002140:	10a30000 	addk	r5, r3, r0
#if OS_TIME_TICK_HOOK_EN > 0u
    OSTimeTickHook();                                      /* Call user definable hook                     */
#endif
#if OS_TIME_GET_SET_EN > 0u
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
10002144:	30840001 	addik	r4, r4, 1
10002148:	b0001000 	imm	4096
1000214c:	f880d614 	swi	r4, r0, -10732	// 1000d614 <OSTime>
    OS_EXIT_CRITICAL();
10002150:	b9f45e0c 	brlid	r15, 24076	// 10007f5c <OS_CPU_SR_Restore>
10002154:	80000000 	or	r0, r0, r0
#endif
    if (OSRunning == OS_TRUE) {
10002158:	b0001000 	imm	4096
1000215c:	e080ce18 	lbui	r4, r0, -12776	// 1000ce18 <OSRunning>
10002160:	a8840001 	xori	r4, r4, 1
10002164:	be2400e4 	bneid	r4, 228		// 10002248
10002168:	e9e10000 	lwi	r15, r1, 0
#if OS_TICK_STEP_EN > 0u
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
1000216c:	b0001000 	imm	4096
10002170:	e060d174 	lbui	r3, r0, -11916	// 1000d174 <OSTickStepState>
10002174:	a8a30001 	xori	r5, r3, 1
10002178:	be0500d4 	beqid	r5, 212		// 1000224c
1000217c:	ea61001c 	lwi	r19, r1, 28
10002180:	30a00001 	addik	r5, r0, 1
10002184:	14a51803 	cmpu	r5, r5, r3
10002188:	bc450014 	blti	r5, 20		// 1000219c
1000218c:	a8630002 	xori	r3, r3, 2
                 OSTickStepState = OS_TICK_STEP_WAIT;
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
10002190:	88832400 	pcmpeq	r4, r3, r4
10002194:	b0001000 	imm	4096
10002198:	f080d174 	sbi	r4, r0, -11916	// 1000d174 <OSTickStepState>
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
1000219c:	b0001000 	imm	4096
100021a0:	ea60d0f8 	lwi	r19, r0, -12040	// 1000d0f8 <OSTCBList>
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
100021a4:	b8100098 	brid	152		// 1000223c
100021a8:	e0730036 	lbui	r3, r19, 54
            OS_ENTER_CRITICAL();
100021ac:	b9f45d80 	brlid	r15, 23936	// 10007f2c <OS_CPU_SR_Save>
100021b0:	80000000 	or	r0, r0, r0
            if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
100021b4:	e8930030 	lwi	r4, r19, 48
100021b8:	be040078 	beqid	r4, 120		// 10002230
100021bc:	10a30000 	addk	r5, r3, r0
                ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
100021c0:	3084ffff 	addik	r4, r4, -1
                if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
100021c4:	be24006c 	bneid	r4, 108		// 10002230
100021c8:	f8930030 	swi	r4, r19, 48

                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
100021cc:	e0b30034 	lbui	r5, r19, 52
100021d0:	a4850037 	andi	r4, r5, 55
100021d4:	be040010 	beqid	r4, 16		// 100021e4
100021d8:	a4a5ffc8 	andi	r5, r5, -56
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
100021dc:	f0b30034 	sbi	r5, r19, 52
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
100021e0:	30800001 	addik	r4, r0, 1
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
100021e4:	f0930035 	sbi	r4, r19, 53
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
100021e8:	e0930034 	lbui	r4, r19, 52
100021ec:	a4840008 	andi	r4, r4, 8
100021f0:	be240040 	bneid	r4, 64		// 10002230
100021f4:	10a30000 	addk	r5, r3, r0
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
100021f8:	e0b3003a 	lbui	r5, r19, 58
100021fc:	b0001000 	imm	4096
10002200:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10002204:	80852000 	or	r4, r5, r4
10002208:	b0001000 	imm	4096
1000220c:	f080d3f8 	sbi	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10002210:	e0930038 	lbui	r4, r19, 56
10002214:	e0b30039 	lbui	r5, r19, 57
10002218:	b0001000 	imm	4096
1000221c:	e0c4d3fc 	lbui	r6, r4, -11268
10002220:	80a62800 	or	r5, r6, r5
10002224:	b0001000 	imm	4096
10002228:	f0a4d3fc 	sbi	r5, r4, -11268
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
1000222c:	10a30000 	addk	r5, r3, r0
10002230:	b9f45d2c 	brlid	r15, 23852	// 10007f5c <OS_CPU_SR_Restore>
10002234:	ea730014 	lwi	r19, r19, 20
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
10002238:	e0730036 	lbui	r3, r19, 54
1000223c:	a863003f 	xori	r3, r3, 63
10002240:	be23ff6c 	bneid	r3, -148		// 100021ac
10002244:	e9e10000 	lwi	r15, r1, 0
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
10002248:	ea61001c 	lwi	r19, r1, 28
1000224c:	b60f0008 	rtsd	r15, 8
10002250:	30210020 	addik	r1, r1, 32

10002254 <OSVersion>:
*/

INT16U  OSVersion (void)
{
    return (OS_VERSION);
}
10002254:	b60f0008 	rtsd	r15, 8
10002258:	30600122 	addik	r3, r0, 290

1000225c <OS_Dummy>:
*/

#if OS_TASK_DEL_EN > 0u
void  OS_Dummy (void)
{
}
1000225c:	b60f0008 	rtsd	r15, 8
10002260:	80000000 	or	r0, r0, r0

10002264 <OS_EventTaskWait>:
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
10002264:	b0001000 	imm	4096
10002268:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
1000226c:	e0830038 	lbui	r4, r3, 56
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
10002270:	f8a3001c 	swi	r5, r3, 28

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
10002274:	e0c30039 	lbui	r6, r3, 57
10002278:	10852000 	addk	r4, r5, r4
1000227c:	e0e4000b 	lbui	r7, r4, 11
10002280:	80c73000 	or	r6, r7, r6
10002284:	f0c4000b 	sbi	r6, r4, 11
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
10002288:	e0c3003a 	lbui	r6, r3, 58
1000228c:	e085000a 	lbui	r4, r5, 10
10002290:	80862000 	or	r4, r6, r4
10002294:	f085000a 	sbi	r4, r5, 10

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
10002298:	e0a30038 	lbui	r5, r3, 56
1000229c:	e0830039 	lbui	r4, r3, 57
100022a0:	b0001000 	imm	4096
100022a4:	e0c5d3fc 	lbui	r6, r5, -11268
100022a8:	a884ffff 	xori	r4, r4, -1
100022ac:	84843000 	and	r4, r4, r6
100022b0:	b0001000 	imm	4096
100022b4:	f085d3fc 	sbi	r4, r5, -11268
    if (OSRdyTbl[y] == 0u) {
100022b8:	bc240020 	bnei	r4, 32		// 100022d8
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
100022bc:	e063003a 	lbui	r3, r3, 58
100022c0:	b0001000 	imm	4096
100022c4:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
100022c8:	a863ffff 	xori	r3, r3, -1
100022cc:	84632000 	and	r3, r3, r4
100022d0:	b0001000 	imm	4096
100022d4:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
100022d8:	b60f0008 	rtsd	r15, 8
100022dc:	80000000 	or	r0, r0, r0

100022e0 <OS_EventTaskWaitMulti>:
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
100022e0:	b0001000 	imm	4096
100022e4:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
100022e8:	f803001c 	swi	r0, r3, 28
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
100022ec:	f8a30020 	swi	r5, r3, 32

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
100022f0:	b8100030 	brid	48		// 10002320
100022f4:	e8850000 	lwi	r4, r5, 0
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
100022f8:	10c43000 	addk	r6, r4, r6
100022fc:	e106000b 	lbui	r8, r6, 11
10002300:	80e83800 	or	r7, r8, r7
10002304:	f0e6000b 	sbi	r7, r6, 11
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
10002308:	e0e3003a 	lbui	r7, r3, 58
1000230c:	e0c4000a 	lbui	r6, r4, 10
10002310:	80c73000 	or	r6, r7, r6
10002314:	f0c4000a 	sbi	r6, r4, 10
        pevents++;
        pevent = *pevents;
10002318:	e8850004 	lwi	r4, r5, 4
1000231c:	30a50004 	addik	r5, r5, 4
10002320:	e0c30038 	lbui	r6, r3, 56
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
10002324:	be24ffd4 	bneid	r4, -44		// 100022f8
10002328:	e0e30039 	lbui	r7, r3, 57
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
1000232c:	b0001000 	imm	4096
10002330:	e0a6d3fc 	lbui	r5, r6, -11268
10002334:	a887ffff 	xori	r4, r7, -1
10002338:	84842800 	and	r4, r4, r5
1000233c:	b0001000 	imm	4096
10002340:	f086d3fc 	sbi	r4, r6, -11268
    if (OSRdyTbl[y] == 0u) {
10002344:	bc240020 	bnei	r4, 32		// 10002364
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
10002348:	e063003a 	lbui	r3, r3, 58
1000234c:	b0001000 	imm	4096
10002350:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10002354:	a863ffff 	xori	r3, r3, -1
10002358:	84632000 	and	r3, r3, r4
1000235c:	b0001000 	imm	4096
10002360:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
10002364:	b60f0008 	rtsd	r15, 8
10002368:	80000000 	or	r0, r0, r0

1000236c <OS_EventTaskRemove>:
{
    INT8U  y;


    y                       =  ptcb->OSTCBY;
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
1000236c:	e0850038 	lbui	r4, r5, 56
10002370:	e0650039 	lbui	r3, r5, 57
10002374:	10862000 	addk	r4, r6, r4
10002378:	e0e4000b 	lbui	r7, r4, 11
1000237c:	a863ffff 	xori	r3, r3, -1
10002380:	84633800 	and	r3, r3, r7
    if (pevent->OSEventTbl[y] == 0u) {
10002384:	be23001c 	bneid	r3, 28		// 100023a0
10002388:	f064000b 	sbi	r3, r4, 11
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
1000238c:	e065003a 	lbui	r3, r5, 58
10002390:	e086000a 	lbui	r4, r6, 10
10002394:	a863ffff 	xori	r3, r3, -1
10002398:	84632000 	and	r3, r3, r4
1000239c:	f066000a 	sbi	r3, r6, 10
100023a0:	b60f0008 	rtsd	r15, 8
100023a4:	80000000 	or	r0, r0, r0

100023a8 <OS_EventTaskRemoveMulti>:
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
100023a8:	e0e5003a 	lbui	r7, r5, 58
    bitx    =  ptcb->OSTCBBitX;
100023ac:	e1050039 	lbui	r8, r5, 57
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
100023b0:	e1250038 	lbui	r9, r5, 56
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
100023b4:	e8660000 	lwi	r3, r6, 0
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
        pevent->OSEventTbl[y]  &= ~bitx;
100023b8:	a908ffff 	xori	r8, r8, -1
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
100023bc:	b8100030 	brid	48		// 100023ec
100023c0:	a8e7ffff 	xori	r7, r7, -1
        pevent->OSEventTbl[y]  &= ~bitx;
100023c4:	10a34800 	addk	r5, r3, r9
100023c8:	e085000b 	lbui	r4, r5, 11
100023cc:	84882000 	and	r4, r8, r4
        if (pevent->OSEventTbl[y] == 0u) {
100023d0:	be240014 	bneid	r4, 20		// 100023e4
100023d4:	f085000b 	sbi	r4, r5, 11
            pevent->OSEventGrp &= ~bity;
100023d8:	e083000a 	lbui	r4, r3, 10
100023dc:	84872000 	and	r4, r7, r4
100023e0:	f083000a 	sbi	r4, r3, 10
        }
        pevents++;
        pevent = *pevents;
100023e4:	e8660004 	lwi	r3, r6, 4
100023e8:	30c60004 	addik	r6, r6, 4
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
100023ec:	bc23ffd8 	bnei	r3, -40		// 100023c4
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
100023f0:	b60f0008 	rtsd	r15, 8
100023f4:	80000000 	or	r0, r0, r0

100023f8 <OS_EventTaskRdy>:
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                        void      *pmsg,
                        INT8U      msk,
                        INT8U      pend_stat)
{
100023f8:	3021ffd8 	addik	r1, r1, -40
100023fc:	fa61001c 	swi	r19, r1, 28
10002400:	fac10020 	swi	r22, r1, 32
10002404:	fae10024 	swi	r23, r1, 36
10002408:	f9e10000 	swi	r15, r1, 0
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63u
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
1000240c:	e065000a 	lbui	r3, r5, 10
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                        void      *pmsg,
                        INT8U      msk,
                        INT8U      pend_stat)
{
10002410:	12c50000 	addk	r22, r5, r0
#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
10002414:	a8e7ffff 	xori	r7, r7, -1
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63u
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
10002418:	b0001000 	imm	4096
1000241c:	e08389f4 	lbui	r4, r3, -30220
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
10002420:	10652000 	addk	r3, r5, r4
10002424:	e0a3000b 	lbui	r5, r3, 11
    prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
10002428:	64640403 	bslli	r3, r4, 3
1000242c:	b0001000 	imm	4096
10002430:	e2e589f4 	lbui	r23, r5, -30220
10002434:	12f71800 	addk	r23, r23, r3
10002438:	a6f700ff 	andi	r23, r23, 255
        x = OSUnMapTbl[(*ptbl >> 8u) & 0xFF] + 8u;
    }
    prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
1000243c:	64770402 	bslli	r3, r23, 2
10002440:	b0001000 	imm	4096
10002444:	ea63e0a4 	lwi	r19, r3, -8028
#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
10002448:	e0730034 	lbui	r3, r19, 52
    }
    prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
    ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
1000244c:	f8130030 	swi	r0, r19, 48
#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
10002450:	f8d30024 	swi	r6, r19, 36
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
10002454:	84e71800 	and	r7, r7, r3
10002458:	f0f30034 	sbi	r7, r19, 52
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
1000245c:	a4e70008 	andi	r7, r7, 8
10002460:	be270038 	bneid	r7, 56		// 10002498
10002464:	f1130035 	sbi	r8, r19, 53
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
10002468:	e0b3003a 	lbui	r5, r19, 58
1000246c:	b0001000 	imm	4096
10002470:	e060d3f8 	lbui	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
10002474:	80651800 	or	r3, r5, r3
10002478:	b0001000 	imm	4096
1000247c:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
10002480:	b0001000 	imm	4096
10002484:	e0a4d3fc 	lbui	r5, r4, -11268
10002488:	e0730039 	lbui	r3, r19, 57
1000248c:	80651800 	or	r3, r5, r3
10002490:	b0001000 	imm	4096
10002494:	f064d3fc 	sbi	r3, r4, -11268
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
10002498:	10d60000 	addk	r6, r22, r0
1000249c:	b9f4fed0 	brlid	r15, -304	// 1000236c <OS_EventTaskRemove>
100024a0:	10b30000 	addk	r5, r19, r0
#if (OS_EVENT_MULTI_EN > 0u)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
100024a4:	e8d30020 	lwi	r6, r19, 32
100024a8:	be060018 	beqid	r6, 24		// 100024c0
100024ac:	10770000 	addk	r3, r23, r0
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
100024b0:	b9f4fef8 	brlid	r15, -264	// 100023a8 <OS_EventTaskRemoveMulti>
100024b4:	10b30000 	addk	r5, r19, r0
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
100024b8:	fad3001c 	swi	r22, r19, 28
    }
#endif

    return (prio);
}
100024bc:	10770000 	addk	r3, r23, r0
100024c0:	e9e10000 	lwi	r15, r1, 0
100024c4:	ea61001c 	lwi	r19, r1, 28
100024c8:	eac10020 	lwi	r22, r1, 32
100024cc:	eae10024 	lwi	r23, r1, 36
100024d0:	b60f0008 	rtsd	r15, 8
100024d4:	30210028 	addik	r1, r1, 40

100024d8 <OS_EventWaitListInit>:
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
100024d8:	f005000a 	sbi	r0, r5, 10
    ptbl               = &pevent->OSEventTbl[0];
100024dc:	10600000 	addk	r3, r0, r0
100024e0:	30a5000b 	addik	r5, r5, 11

    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0u;
100024e4:	d0032800 	sb	r0, r3, r5
100024e8:	30630001 	addik	r3, r3, 1


    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
100024ec:	a8830008 	xori	r4, r3, 8
100024f0:	bc24fff4 	bnei	r4, -12		// 100024e4
        *ptbl++ = 0u;
    }
}
100024f4:	b60f0008 	rtsd	r15, 8
100024f8:	80000000 	or	r0, r0, r0

100024fc <OS_MemClr>:
*/

void  OS_MemClr (INT8U  *pdest,
                 INT16U  size)
{
    while (size > 0u) {
100024fc:	b8000014 	bri	20		// 10002510
        *pdest++ = (INT8U)0;
10002500:	f0050000 	sbi	r0, r5, 0
        size--;
10002504:	b0000000 	imm	0
10002508:	a4c6ffff 	andi	r6, r6, -1

void  OS_MemClr (INT8U  *pdest,
                 INT16U  size)
{
    while (size > 0u) {
        *pdest++ = (INT8U)0;
1000250c:	30a50001 	addik	r5, r5, 1
*/

void  OS_MemClr (INT8U  *pdest,
                 INT16U  size)
{
    while (size > 0u) {
10002510:	be26fff0 	bneid	r6, -16		// 10002500
10002514:	30c6ffff 	addik	r6, r6, -1
        *pdest++ = (INT8U)0;
        size--;
    }
}
10002518:	b60f0008 	rtsd	r15, 8
1000251c:	30c60001 	addik	r6, r6, 1

10002520 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
10002520:	3021ffc8 	addik	r1, r1, -56
10002524:	f9e10000 	swi	r15, r1, 0
10002528:	fa61002c 	swi	r19, r1, 44
1000252c:	fac10030 	swi	r22, r1, 48
    OSInitHookBegin();                                           /* Call port specific initialization code   */
10002530:	b9f456d4 	brlid	r15, 22228	// 10007c04 <OSInitHookBegin>
10002534:	fae10034 	swi	r23, r1, 52
*/

static  void  OS_InitMisc (void)
{
#if OS_TIME_GET_SET_EN > 0u
    OSTime                    = 0L;                        /* Clear the 32-bit system clock            */
10002538:	b0001000 	imm	4096
1000253c:	f800d614 	swi	r0, r0, -10732	// 1000d614 <OSTime>
#endif

    OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
10002540:	b0001000 	imm	4096
10002544:	f000d608 	sbi	r0, r0, -10744	// 1000d608 <OSIntNesting>
    OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
10002548:	b0001000 	imm	4096
1000254c:	f000ce10 	sbi	r0, r0, -12784	// 1000ce10 <OSLockNesting>

    OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
10002550:	b0001000 	imm	4096
10002554:	f000d389 	sbi	r0, r0, -11383	// 1000d389 <OSTaskCtr>

    OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
10002558:	b0001000 	imm	4096
1000255c:	f000ce18 	sbi	r0, r0, -12776	// 1000ce18 <OSRunning>

    OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
10002560:	b0001000 	imm	4096
10002564:	f800d378 	swi	r0, r0, -11400	// 1000d378 <OSCtxSwCtr>
    OSIdleCtr                 = 0L;                        /* Clear the 32-bit idle counter            */
10002568:	b0001000 	imm	4096
1000256c:	f800ce1c 	swi	r0, r0, -12772	// 1000ce1c <OSIdleCtr>

#if OS_TASK_STAT_EN > 0u
    OSIdleCtrRun              = 0L;
10002570:	b0001000 	imm	4096
10002574:	f800e1a4 	swi	r0, r0, -7772	// 1000e1a4 <OSIdleCtrRun>
    OSIdleCtrMax              = 0L;
10002578:	b0001000 	imm	4096
1000257c:	f800d380 	swi	r0, r0, -11392	// 1000d380 <OSIdleCtrMax>
    OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
10002580:	b0001000 	imm	4096
10002584:	f000e0a0 	sbi	r0, r0, -8032	// 1000e0a0 <OSStatRdy>
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
10002588:	b0001000 	imm	4096
1000258c:	f000d3f8 	sbi	r0, r0, -11272	// 1000d3f8 <OSRdyGrp>
10002590:	10600000 	addk	r3, r0, r0
    prdytbl       = &OSRdyTbl[0];
    for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0u;
10002594:	b0001000 	imm	4096
10002598:	f003d3fc 	sbi	r0, r3, -11268
1000259c:	30630001 	addik	r3, r3, 1
#endif


    OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
100025a0:	aa630008 	xori	r19, r3, 8
100025a4:	bc33fff0 	bnei	r19, -16		// 10002594
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
100025a8:	b0001000 	imm	4096
100025ac:	30a0d90c 	addik	r5, r0, -9972	// 1000d90c <OSTCBTbl>
    prdytbl       = &OSRdyTbl[0];
    for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0u;
    }

    OSPrioCur     = 0u;
100025b0:	b0001000 	imm	4096
100025b4:	f260d0f4 	sbi	r19, r0, -12044	// 1000d0f4 <OSPrioCur>
    OSPrioHighRdy = 0u;
100025b8:	b0001000 	imm	4096
100025bc:	f260ce22 	sbi	r19, r0, -12766	// 1000ce22 <OSPrioHighRdy>

    OSTCBHighRdy  = (OS_TCB *)0;
100025c0:	b0001000 	imm	4096
100025c4:	fa60d3f0 	swi	r19, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
    OSTCBCur      = (OS_TCB *)0;
100025c8:	b0001000 	imm	4096
100025cc:	fa60d60c 	swi	r19, r0, -10740	// 1000d60c <OSTCBCur>
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
100025d0:	b9f4ff2c 	brlid	r15, -212	// 100024fc <OS_MemClr>
100025d4:	30c00790 	addik	r6, r0, 1936
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
100025d8:	b0001000 	imm	4096
100025dc:	30a0e0a4 	addik	r5, r0, -8028	// 1000e0a4 <OSTCBPrioTbl>
100025e0:	b9f4ff1c 	brlid	r15, -228	// 100024fc <OS_MemClr>
100025e4:	30c00100 	addik	r6, r0, 256	// 100 <_HEAP_SIZE>
100025e8:	10930000 	addk	r4, r19, r0
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
100025ec:	b0001000 	imm	4096
100025f0:	30c0d964 	addik	r6, r0, -9884
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_EN > 0u
        ptcb1->OSTCBTaskName = (INT8U *)"?";                     /* Unknown name                       */
100025f4:	b0001000 	imm	4096
100025f8:	30a089d0 	addik	r5, r0, -30256
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
100025fc:	10e62000 	addk	r7, r6, r4
    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
        ptcb1->OSTCBNext = ptcb2;
10002600:	b0001000 	imm	4096
10002604:	f8e4d920 	swi	r7, r4, -9952
#if OS_TASK_NAME_EN > 0u
        ptcb1->OSTCBTaskName = (INT8U *)"?";                     /* Unknown name                       */
10002608:	b0001000 	imm	4096
1000260c:	f8a4d95c 	swi	r5, r4, -9892
10002610:	30840058 	addik	r4, r4, 88

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
10002614:	aa640738 	xori	r19, r4, 1848
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
10002618:	b0001000 	imm	4096
1000261c:	3060d90c 	addik	r3, r0, -9972	// 1000d90c <OSTCBTbl>
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_EN > 0u
        ptcb1->OSTCBTaskName = (INT8U *)"?";                     /* Unknown name                       */
10002620:	b0001000 	imm	4096
10002624:	32c089d0 	addik	r22, r0, -30256

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0u; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); i++) {/* Init. list of free TCBs            */
10002628:	be33ffd8 	bneid	r19, -40		// 10002600
1000262c:	10e62000 	addk	r7, r6, r4
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
10002630:	b0001000 	imm	4096
10002634:	30a0d81c 	addik	r5, r0, -10212	// 1000d81c <OSEventTbl>
        ptcb1->OSTCBTaskName = (INT8U *)"?";                     /* Unknown name                       */
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
10002638:	fa63074c 	swi	r19, r3, 1868
#if OS_TASK_NAME_EN > 0u
    ptcb1->OSTCBTaskName    = (INT8U *)"?";                      /* Unknown name                       */
1000263c:	fac30788 	swi	r22, r3, 1928
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    OSTCBFreeList           = &OSTCBTbl[0];
10002640:	b0001000 	imm	4096
10002644:	f860d384 	swi	r3, r0, -11388	// 1000d384 <OSTCBFreeList>
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
#if OS_TASK_NAME_EN > 0u
    ptcb1->OSTCBTaskName    = (INT8U *)"?";                      /* Unknown name                       */
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
10002648:	b0001000 	imm	4096
1000264c:	fa60d0f8 	swi	r19, r0, -12040	// 1000d0f8 <OSTCBList>
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
10002650:	b9f4feac 	brlid	r15, -340	// 100024fc <OS_MemClr>
10002654:	30c000f0 	addik	r6, r0, 240
10002658:	10730000 	addk	r3, r19, r0
*
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
1000265c:	b0001000 	imm	4096
10002660:	30a0d834 	addik	r5, r0, -10188
10002664:	10c51800 	addk	r6, r5, r3

    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0u; i < (OS_MAX_EVENTS - 1u); i++) {           /* Init. list of free EVENT control blocks */
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
10002668:	b0001000 	imm	4096
1000266c:	f003d81c 	sbi	r0, r3, -10212
        pevent1->OSEventPtr     = pevent2;
10002670:	b0001000 	imm	4096
10002674:	f8c3d820 	swi	r6, r3, -10208
#if OS_EVENT_NAME_EN > 0u
        pevent1->OSEventName    = (INT8U *)"?";             /* Unknown name                            */
10002678:	b0001000 	imm	4096
1000267c:	fac3d830 	swi	r22, r3, -10192
10002680:	30630018 	addik	r3, r3, 24


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0u; i < (OS_MAX_EVENTS - 1u); i++) {           /* Init. list of free EVENT control blocks */
10002684:	aa6300d8 	xori	r19, r3, 216
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
10002688:	b0001000 	imm	4096
1000268c:	3080d81c 	addik	r4, r0, -10212	// 1000d81c <OSEventTbl>


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0u; i < (OS_MAX_EVENTS - 1u); i++) {           /* Init. list of free EVENT control blocks */
10002690:	be33ffd8 	bneid	r19, -40		// 10002668
10002694:	10c51800 	addk	r6, r5, r3
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    pevent1->OSEventPtr             = (OS_EVENT *)0;
#if OS_EVENT_NAME_EN > 0u
    pevent1->OSEventName            = (INT8U *)"?";         /* Unknown name                            */
10002698:	b0001000 	imm	4096
1000269c:	306089d0 	addik	r3, r0, -30256
        pevent1->OSEventName    = (INT8U *)"?";             /* Unknown name                            */
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
100026a0:	f26400d8 	sbi	r19, r4, 216
    pevent1->OSEventPtr             = (OS_EVENT *)0;
100026a4:	fa6400dc 	swi	r19, r4, 220
#if OS_EVENT_NAME_EN > 0u
    pevent1->OSEventName            = (INT8U *)"?";         /* Unknown name                            */
100026a8:	f86400ec 	swi	r3, r4, 236
#endif
    OSEventFreeList                 = &OSEventTbl[0];
100026ac:	b0001000 	imm	4096
100026b0:	f880d604 	swi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */

#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
100026b4:	b9f40dc0 	brlid	r15, 3520	// 10003474 <OS_FlagInit>
100026b8:	32e00080 	addik	r23, r0, 128
#endif

#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
    OS_MemInit();                                                /* Initialize the memory manager            */
100026bc:	b9f41ebc 	brlid	r15, 7868	// 10004578 <OS_MemInit>
100026c0:	32c00003 	addik	r22, r0, 3
#endif

#if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
    OS_QInit();                                                  /* Initialize the message queue structures  */
100026c4:	b9f4326c 	brlid	r15, 12908	// 10005930 <OS_QInit>
100026c8:	80000000 	or	r0, r0, r0
#endif


#if OS_TASK_CREATE_EXT_EN > 0u
    #if OS_STK_GROWTH == 1u
    (void)OSTaskCreateExt(OS_TaskIdle,
100026cc:	10d30000 	addk	r6, r19, r0
100026d0:	b0000000 	imm	0
100026d4:	3120ffff 	addik	r9, r0, -1
100026d8:	b0001000 	imm	4096
100026dc:	3140d61c 	addik	r10, r0, -10724	// 1000d61c <OSTaskIdleStk>
100026e0:	b0001000 	imm	4096
100026e4:	30a01e38 	addik	r5, r0, 7736	// 10001e38 <OS_TaskIdle>
100026e8:	b0001000 	imm	4096
100026ec:	30e0d818 	addik	r7, r0, -10216
100026f0:	3100003f 	addik	r8, r0, 63
100026f4:	fae1001c 	swi	r23, r1, 28
100026f8:	fa610020 	swi	r19, r1, 32
100026fc:	b9f445a0 	brlid	r15, 17824	// 10006c9c <OSTaskCreateExt>
10002700:	fac10024 	swi	r22, r1, 36
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_EN > 0u
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
10002704:	b0001000 	imm	4096
10002708:	30c089d4 	addik	r6, r0, -30252
1000270c:	30e10028 	addik	r7, r1, 40
10002710:	b9f43ffc 	brlid	r15, 16380	// 1000670c <OSTaskNameSet>
10002714:	30a0003f 	addik	r5, r0, 63
#endif


#if OS_TASK_CREATE_EXT_EN > 0u
    #if OS_STK_GROWTH == 1u
    (void)OSTaskCreateExt(OS_TaskStat,
10002718:	b0000000 	imm	0
1000271c:	3120fffe 	addik	r9, r0, -2
10002720:	b0001000 	imm	4096
10002724:	3140d178 	addik	r10, r0, -11912	// 1000d178 <OSTaskStatStk>
10002728:	10d30000 	addk	r6, r19, r0
1000272c:	b0001000 	imm	4096
10002730:	30a02d7c 	addik	r5, r0, 11644	// 10002d7c <OS_TaskStat>
10002734:	b0001000 	imm	4096
10002738:	30e0d374 	addik	r7, r0, -11404
1000273c:	3100003e 	addik	r8, r0, 62
10002740:	fae1001c 	swi	r23, r1, 28
10002744:	fa610020 	swi	r19, r1, 32
10002748:	b9f44554 	brlid	r15, 17748	// 10006c9c <OSTaskCreateExt>
1000274c:	fac10024 	swi	r22, r1, 36
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_EN > 0u
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
10002750:	b0001000 	imm	4096
10002754:	30c089e4 	addik	r6, r0, -30236
10002758:	30a0003e 	addik	r5, r0, 62
1000275c:	b9f43fb0 	brlid	r15, 16304	// 1000670c <OSTaskNameSet>
10002760:	30e10028 	addik	r7, r1, 40
#if OS_TASK_STAT_EN > 0u
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_TMR_EN > 0u
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
10002764:	b9f45330 	brlid	r15, 21296	// 10007a94 <OSTmr_Init>
10002768:	80000000 	or	r0, r0, r0
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
1000276c:	b9f454a0 	brlid	r15, 21664	// 10007c0c <OSInitHookEnd>
10002770:	80000000 	or	r0, r0, r0

#if OS_DEBUG_EN > 0u
    OSDebugInit();
10002774:	b9f45640 	brlid	r15, 22080	// 10007db4 <OSDebugInit>
10002778:	80000000 	or	r0, r0, r0
#endif
}
1000277c:	e9e10000 	lwi	r15, r1, 0
10002780:	ea61002c 	lwi	r19, r1, 44
10002784:	eac10030 	lwi	r22, r1, 48
10002788:	eae10034 	lwi	r23, r1, 52
1000278c:	b60f0008 	rtsd	r15, 8
10002790:	30210038 	addik	r1, r1, 56

10002794 <OS_MemCopy>:

void  OS_MemCopy (INT8U  *pdest,
                  INT8U  *psrc,
                  INT16U  size)
{
    while (size > 0u) {
10002794:	b8100020 	brid	32		// 100027b4
10002798:	10600000 	addk	r3, r0, r0
        *pdest++ = *psrc++;
1000279c:	c0833000 	lbu	r4, r3, r6
        size--;
100027a0:	30e7ffff 	addik	r7, r7, -1
100027a4:	b0000000 	imm	0
100027a8:	a4e7ffff 	andi	r7, r7, -1
void  OS_MemCopy (INT8U  *pdest,
                  INT8U  *psrc,
                  INT16U  size)
{
    while (size > 0u) {
        *pdest++ = *psrc++;
100027ac:	d0832800 	sb	r4, r3, r5
        size--;
100027b0:	30630001 	addik	r3, r3, 1

void  OS_MemCopy (INT8U  *pdest,
                  INT8U  *psrc,
                  INT16U  size)
{
    while (size > 0u) {
100027b4:	bc27ffe8 	bnei	r7, -24		// 1000279c
        *pdest++ = *psrc++;
        size--;
    }
}
100027b8:	b60f0008 	rtsd	r15, 8
100027bc:	80000000 	or	r0, r0, r0

100027c0 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
100027c0:	3021ffe0 	addik	r1, r1, -32
100027c4:	fa61001c 	swi	r19, r1, 28
100027c8:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    OS_ENTER_CRITICAL();
100027cc:	b9f45760 	brlid	r15, 22368	// 10007f2c <OS_CPU_SR_Save>
100027d0:	80000000 	or	r0, r0, r0
100027d4:	12630000 	addk	r19, r3, r0
    if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
100027d8:	b0001000 	imm	4096
100027dc:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
100027e0:	bc23006c 	bnei	r3, 108		// 1000284c
        if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
100027e4:	b0001000 	imm	4096
100027e8:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
100027ec:	bc230060 	bnei	r3, 96		// 1000284c
            OS_SchedNew();
100027f0:	b9f4f610 	brlid	r15, -2544	// 10001e00 <OS_SchedNew>
100027f4:	80000000 	or	r0, r0, r0
            OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
100027f8:	b0001000 	imm	4096
100027fc:	e0c0ce22 	lbui	r6, r0, -12766	// 1000ce22 <OSPrioHighRdy>
10002800:	64660402 	bslli	r3, r6, 2
10002804:	b0001000 	imm	4096
10002808:	e883e0a4 	lwi	r4, r3, -8028
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
1000280c:	b0001000 	imm	4096
10002810:	e060d0f4 	lbui	r3, r0, -12044	// 1000d0f4 <OSPrioCur>

    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
            OS_SchedNew();
            OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
10002814:	b0001000 	imm	4096
10002818:	f880d3f0 	swi	r4, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
1000281c:	88c33000 	xor	r6, r3, r6
10002820:	bc06002c 	beqi	r6, 44		// 1000284c
#if OS_TASK_PROFILE_EN > 0u
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
10002824:	e864003c 	lwi	r3, r4, 60
10002828:	30630001 	addik	r3, r3, 1
1000282c:	f864003c 	swi	r3, r4, 60
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
10002830:	b0001000 	imm	4096
10002834:	e860d378 	lwi	r3, r0, -11400	// 1000d378 <OSCtxSwCtr>
10002838:	30630001 	addik	r3, r3, 1
1000283c:	b0001000 	imm	4096
10002840:	f860d378 	swi	r3, r0, -11400	// 1000d378 <OSCtxSwCtr>
                OS_TASK_SW();                          /* Perform a context switch                     */
10002844:	b9f457d0 	brlid	r15, 22480	// 10008014 <OSCtxSw>
10002848:	80000000 	or	r0, r0, r0
            }
        }
    }
    OS_EXIT_CRITICAL();
1000284c:	b9f45710 	brlid	r15, 22288	// 10007f5c <OS_CPU_SR_Restore>
10002850:	10b30000 	addk	r5, r19, r0
}
10002854:	e9e10000 	lwi	r15, r1, 0
10002858:	ea61001c 	lwi	r19, r1, 28
1000285c:	b60f0008 	rtsd	r15, 8
10002860:	30210020 	addik	r1, r1, 32

10002864 <OSSchedUnlock>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
10002864:	b0001000 	imm	4096
10002868:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0u
void  OSSchedUnlock (void)
{
1000286c:	3021ffe4 	addik	r1, r1, -28
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
10002870:	a8630001 	xori	r3, r3, 1
10002874:	be230060 	bneid	r3, 96		// 100028d4
10002878:	f9e10000 	swi	r15, r1, 0
        OS_ENTER_CRITICAL();
1000287c:	b9f456b0 	brlid	r15, 22192	// 10007f2c <OS_CPU_SR_Save>
10002880:	80000000 	or	r0, r0, r0
10002884:	10a30000 	addk	r5, r3, r0
        if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
10002888:	b0001000 	imm	4096
1000288c:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
10002890:	be03003c 	beqid	r3, 60		// 100028cc
10002894:	3063ffff 	addik	r3, r3, -1
            OSLockNesting--;                               /* Decrement lock nesting level             */
10002898:	a46300ff 	andi	r3, r3, 255
1000289c:	b0001000 	imm	4096
100028a0:	f060ce10 	sbi	r3, r0, -12784	// 1000ce10 <OSLockNesting>
            if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
100028a4:	bc230028 	bnei	r3, 40		// 100028cc
                if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
100028a8:	b0001000 	imm	4096
100028ac:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
100028b0:	bc23001c 	bnei	r3, 28		// 100028cc
                    OS_EXIT_CRITICAL();
100028b4:	b9f456a8 	brlid	r15, 22184	// 10007f5c <OS_CPU_SR_Restore>
100028b8:	80000000 	or	r0, r0, r0
                    OS_Sched();                            /* See if a HPT is ready                    */
100028bc:	b9f4ff04 	brlid	r15, -252	// 100027c0 <OS_Sched>
100028c0:	80000000 	or	r0, r0, r0
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
100028c4:	b8100014 	brid	20		// 100028d8
100028c8:	e9e10000 	lwi	r15, r1, 0
                }
            } else {
                OS_EXIT_CRITICAL();
            }
        } else {
            OS_EXIT_CRITICAL();
100028cc:	b9f45690 	brlid	r15, 22160	// 10007f5c <OS_CPU_SR_Restore>
100028d0:	80000000 	or	r0, r0, r0
        }
    }
}
100028d4:	e9e10000 	lwi	r15, r1, 0
100028d8:	b60f0008 	rtsd	r15, 8
100028dc:	3021001c 	addik	r1, r1, 28

100028e0 <OSEventPendMulti>:
INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                          OS_EVENT  **pevents_rdy,
                          void      **pmsgs_rdy,
                          INT32U      timeout,
                          INT8U      *perr)
{
100028e0:	3021ffc0 	addik	r1, r1, -64
100028e4:	fac10020 	swi	r22, r1, 32
100028e8:	fae10024 	swi	r23, r1, 36
100028ec:	fb21002c 	swi	r25, r1, 44
100028f0:	fb410030 	swi	r26, r1, 48
100028f4:	fb810038 	swi	r28, r1, 56
100028f8:	fba1003c 	swi	r29, r1, 60
100028fc:	f9e10000 	swi	r15, r1, 0
10002900:	fa61001c 	swi	r19, r1, 28
10002904:	fb010028 	swi	r24, r1, 40
10002908:	fb610034 	swi	r27, r1, 52
       *perr =  OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
1000290c:	f8060000 	swi	r0, r6, 0
INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                          OS_EVENT  **pevents_rdy,
                          void      **pmsgs_rdy,
                          INT32U      timeout,
                          INT8U      *perr)
{
10002910:	13450000 	addk	r26, r5, r0
10002914:	12c60000 	addk	r22, r6, r0
10002918:	12e70000 	addk	r23, r7, r0
1000291c:	13a80000 	addk	r29, r8, r0
10002920:	13290000 	addk	r25, r9, r0
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
10002924:	eb050000 	lwi	r24, r5, 0
10002928:	13850000 	addk	r28, r5, r0
    while  (pevent != (OS_EVENT *)0) {
1000292c:	10650000 	addk	r3, r5, r0
10002930:	b8100030 	brid	48		// 10002960
10002934:	30800002 	addik	r4, r0, 2	// 2 <CPU_IE_BIT>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
10002938:	e0b80000 	lbui	r5, r24, 0
1000293c:	30a5ffff 	addik	r5, r5, -1
10002940:	14a52003 	cmpu	r5, r5, r4
10002944:	bea50014 	bgeid	r5, 20		// 10002958
10002948:	13000000 	addk	r24, r0, r0
#endif

            case OS_EVENT_TYPE_MUTEX:
            case OS_EVENT_TYPE_FLAG:
            default:
                *perr = OS_ERR_EVENT_TYPE;
1000294c:	30600001 	addik	r3, r0, 1
                 return (0u);
10002950:	b81002a0 	brid	672		// 10002bf0
10002954:	f0790000 	sbi	r3, r25, 0
        }
        pevents++;
        pevent = *pevents;
10002958:	eb030004 	lwi	r24, r3, 4
1000295c:	30630004 	addik	r3, r3, 4

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
10002960:	bc38ffd8 	bnei	r24, -40		// 10002938
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
10002964:	b0001000 	imm	4096
10002968:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
1000296c:	be230018 	bneid	r3, 24		// 10002984
10002970:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
        return (0u);
    }
    if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
10002974:	b0001000 	imm	4096
10002978:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
1000297c:	bc030010 	beqi	r3, 16		// 1000298c
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
10002980:	3060000d 	addik	r3, r0, 13
        return (0u);
10002984:	b810026c 	brid	620		// 10002bf0
10002988:	f0790000 	sbi	r3, r25, 0
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
1000298c:	b9f455a0 	brlid	r15, 21920	// 10007f2c <OS_CPU_SR_Save>
10002990:	80000000 	or	r0, r0, r0
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0u;
    events_stat    =  OS_STAT_RDY;
10002994:	10980000 	addk	r4, r24, r0
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
        return (0u);
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
10002998:	13630000 	addk	r27, r3, r0
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0u;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
1000299c:	ea7a0000 	lwi	r19, r26, 0
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
100029a0:	b81000e8 	brid	232		// 10002a88
100029a4:	10640000 	addk	r3, r4, r0
        switch (pevent->OSEventType) {
100029a8:	e0b30000 	lbui	r5, r19, 0
100029ac:	a8c50002 	xori	r6, r5, 2
100029b0:	be060084 	beqid	r6, 132		// 10002a34
100029b4:	a8c50003 	xori	r6, r5, 3
100029b8:	be060010 	beqid	r6, 16		// 100029c8
100029bc:	a8a50001 	xori	r5, r5, 1
100029c0:	bc050038 	beqi	r5, 56		// 100029f8
100029c4:	b80001d8 	bri	472		// 10002b9c
#if (OS_SEM_EN > 0u)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
100029c8:	e4b30008 	lhui	r5, r19, 8
100029cc:	be050020 	beqid	r5, 32		// 100029ec
100029d0:	30a5ffff 	addik	r5, r5, -1
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
100029d4:	f4b30008 	shi	r5, r19, 8
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
100029d8:	fa760000 	swi	r19, r22, 0
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
100029dc:	f8d70000 	swi	r6, r23, 0
        switch (pevent->OSEventType) {
#if (OS_SEM_EN > 0u)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
100029e0:	32d60004 	addik	r22, r22, 4
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
100029e4:	b8100030 	brid	48		// 10002a14
100029e8:	32f70004 	addik	r23, r23, 4
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
100029ec:	a0840001 	ori	r4, r4, 1
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
100029f0:	b8100090 	brid	144		// 10002a80
100029f4:	a48400ff 	andi	r4, r4, 255
                 break;
#endif

#if (OS_MBOX_EN > 0u)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
100029f8:	e8d30004 	lwi	r6, r19, 4
100029fc:	bc06002c 	beqi	r6, 44		// 10002a28
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
10002a00:	f8d70000 	swi	r6, r23, 0
                     pevent->OSEventPtr  = (void *)0;
10002a04:	f8b30004 	swi	r5, r19, 4

#if (OS_MBOX_EN > 0u)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
10002a08:	32f70004 	addik	r23, r23, 4
                     pevent->OSEventPtr  = (void *)0;
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
10002a0c:	fa760000 	swi	r19, r22, 0
10002a10:	32d60004 	addik	r22, r22, 4
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;
10002a14:	33180001 	addik	r24, r24, 1
10002a18:	b0000000 	imm	0
10002a1c:	a718ffff 	andi	r24, r24, -1
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
                     pevent->OSEventPtr  = (void *)0;
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
10002a20:	b8100060 	brid	96		// 10002a80
10002a24:	30600001 	addik	r3, r0, 1
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
10002a28:	a0840002 	ori	r4, r4, 2
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
10002a2c:	b8100054 	brid	84		// 10002a80
10002a30:	a48400ff 	andi	r4, r4, 255
                 break;
#endif

#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
10002a34:	e8f30004 	lwi	r7, r19, 4
                 if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
10002a38:	e4a70016 	lhui	r5, r7, 22
10002a3c:	bc05003c 	beqi	r5, 60		// 10002a78
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
10002a40:	e8670010 	lwi	r3, r7, 16
10002a44:	e8c30000 	lwi	r6, r3, 0
10002a48:	30630004 	addik	r3, r3, 4
10002a4c:	f8d70000 	swi	r6, r23, 0
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
10002a50:	e8c70008 	lwi	r6, r7, 8
#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
                 if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
10002a54:	f8670010 	swi	r3, r7, 16
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
10002a58:	88633000 	xor	r3, r3, r6
10002a5c:	be230010 	bneid	r3, 16		// 10002a6c
10002a60:	32f70004 	addik	r23, r23, 4
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
10002a64:	e8670004 	lwi	r3, r7, 4
10002a68:	f8670010 	swi	r3, r7, 16
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
10002a6c:	30a5ffff 	addik	r5, r5, -1
10002a70:	b810ff9c 	brid	-100		// 10002a0c
10002a74:	f4a70016 	shi	r5, r7, 22
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
10002a78:	a0840004 	ori	r4, r4, 4
10002a7c:	a48400ff 	andi	r4, r4, 255
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
                *perr        =  OS_ERR_EVENT_TYPE;
                 return (events_rdy_nbr);
        }
        pevents++;
        pevent = *pevents;
10002a80:	ea7c0004 	lwi	r19, r28, 4
10002a84:	339c0004 	addik	r28, r28, 4
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0u;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
10002a88:	bc33ff20 	bnei	r19, -224		// 100029a8
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
10002a8c:	a8630001 	xori	r3, r3, 1
10002a90:	be23001c 	bneid	r3, 28		// 10002aac
10002a94:	13960000 	addk	r28, r22, r0
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
        OS_EXIT_CRITICAL();
10002a98:	10bb0000 	addk	r5, r27, r0
10002a9c:	b9f454c0 	brlid	r15, 21696	// 10007f5c <OS_CPU_SR_Restore>
10002aa0:	fa760000 	swi	r19, r22, 0
       *perr        =  OS_ERR_NONE;
        return (events_rdy_nbr);
10002aa4:	b810014c 	brid	332		// 10002bf0
10002aa8:	f2790000 	sbi	r19, r25, 0
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
10002aac:	b0001000 	imm	4096
10002ab0:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10002ab4:	e0a30034 	lbui	r5, r3, 52
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
10002ab8:	f2630035 	sbi	r19, r3, 53
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
10002abc:	fba30030 	swi	r29, r3, 48
       *perr        =  OS_ERR_NONE;
        return (events_rdy_nbr);
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
10002ac0:	a0a5ff80 	ori	r5, r5, -128
10002ac4:	80842800 	or	r4, r4, r5
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
10002ac8:	10ba0000 	addk	r5, r26, r0
10002acc:	b9f4f814 	brlid	r15, -2028	// 100022e0 <OS_EventTaskWaitMulti>
10002ad0:	f0830034 	sbi	r4, r3, 52

    OS_EXIT_CRITICAL();
10002ad4:	b9f45488 	brlid	r15, 21640	// 10007f5c <OS_CPU_SR_Restore>
10002ad8:	10bb0000 	addk	r5, r27, r0
    OS_Sched();                                         /* Find next highest priority task ready       */
10002adc:	b9f4fce4 	brlid	r15, -796	// 100027c0 <OS_Sched>
10002ae0:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
10002ae4:	b9f45448 	brlid	r15, 21576	// 10007f2c <OS_CPU_SR_Save>
10002ae8:	80000000 	or	r0, r0, r0

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
10002aec:	b0001000 	imm	4096
10002af0:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
    OS_ENTER_CRITICAL();
10002af4:	13630000 	addk	r27, r3, r0

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
10002af8:	e0640035 	lbui	r3, r4, 53
10002afc:	be030010 	beqid	r3, 16		// 10002b0c
10002b00:	a8630002 	xori	r3, r3, 2
10002b04:	be230038 	bneid	r3, 56		// 10002b3c
10002b08:	10a40000 	addk	r5, r4, r0
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
10002b0c:	ea64001c 	lwi	r19, r4, 28
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
10002b10:	be130024 	beqid	r19, 36		// 10002b34
10002b14:	30600001 	addik	r3, r0, 1
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
10002b18:	fa760000 	swi	r19, r22, 0
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;
10002b1c:	33180001 	addik	r24, r24, 1
    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
10002b20:	32d60004 	addik	r22, r22, 4
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;
10002b24:	b0000000 	imm	0
10002b28:	a718ffff 	andi	r24, r24, -1
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
10002b2c:	b8100018 	brid	24		// 10002b44
10002b30:	f81c0004 	swi	r0, r28, 4
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
10002b34:	f0640035 	sbi	r3, r4, 53
             }
			 break;

        case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
10002b38:	10a40000 	addk	r5, r4, r0
10002b3c:	b9f4f86c 	brlid	r15, -1940	// 100023a8 <OS_EventTaskRemoveMulti>
10002b40:	10da0000 	addk	r6, r26, r0
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
10002b44:	b0001000 	imm	4096
10002b48:	e8c0d60c 	lwi	r6, r0, -10740	// 1000d60c <OSTCBCur>
10002b4c:	e0660035 	lbui	r3, r6, 53
10002b50:	be030014 	beqid	r3, 20		// 10002b64
10002b54:	a8630002 	xori	r3, r3, 2
10002b58:	bc030060 	beqi	r3, 96		// 10002bb8
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
             break;

        case OS_STAT_PEND_TO:
        default:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
10002b5c:	b8100068 	brid	104		// 10002bc4
10002b60:	f8170000 	swi	r0, r23, 0
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
10002b64:	e0930000 	lbui	r4, r19, 0
10002b68:	30600001 	addik	r3, r0, 1
10002b6c:	14632003 	cmpu	r3, r3, r4
10002b70:	bc43002c 	blti	r3, 44		// 10002b9c
10002b74:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
10002b78:	14641803 	cmpu	r3, r4, r3
10002b7c:	bea30014 	bgeid	r3, 20		// 10002b90
10002b80:	a8840003 	xori	r4, r4, 3
10002b84:	bc240018 	bnei	r4, 24		// 10002b9c
#if (OS_SEM_EN > 0u)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
                      break;
10002b88:	b8100028 	brid	40		// 10002bb0
10002b8c:	f8970000 	swi	r4, r23, 0

#if ((OS_MBOX_EN > 0u) ||                 \
    ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
10002b90:	e8660024 	lwi	r3, r6, 36
                      break;
10002b94:	b810001c 	brid	28		// 10002bb0
10002b98:	f8770000 	swi	r3, r23, 0
#endif

                 case OS_EVENT_TYPE_MUTEX:
                 case OS_EVENT_TYPE_FLAG:
                 default:
                      OS_EXIT_CRITICAL();
10002b9c:	b9f453c0 	brlid	r15, 21440	// 10007f5c <OS_CPU_SR_Restore>
10002ba0:	10bb0000 	addk	r5, r27, r0
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
                     *perr        =  OS_ERR_EVENT_TYPE;
10002ba4:	30600001 	addik	r3, r0, 1

                 case OS_EVENT_TYPE_MUTEX:
                 case OS_EVENT_TYPE_FLAG:
                 default:
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
10002ba8:	b810fddc 	brid	-548		// 10002984
10002bac:	f8160000 	swi	r0, r22, 0
                     *perr        =  OS_ERR_EVENT_TYPE;
                      return (events_rdy_nbr);
             }
            *perr = OS_ERR_NONE;
             break;
10002bb0:	b810001c 	brid	28		// 10002bcc
10002bb4:	f0190000 	sbi	r0, r25, 0

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
10002bb8:	f8770000 	swi	r3, r23, 0
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
10002bbc:	b810000c 	brid	12		// 10002bc8
10002bc0:	3060000e 	addik	r3, r0, 14
             break;

        case OS_STAT_PEND_TO:
        default:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
10002bc4:	3060000a 	addik	r3, r0, 10
10002bc8:	f0790000 	sbi	r3, r25, 0
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
10002bcc:	b0001000 	imm	4096
10002bd0:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#if ((OS_MBOX_EN > 0u) ||                 \
    ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
#endif
    OS_EXIT_CRITICAL();
10002bd4:	10bb0000 	addk	r5, r27, r0
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
10002bd8:	f0040034 	sbi	r0, r4, 52
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
10002bdc:	f0040035 	sbi	r0, r4, 53
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
10002be0:	f804001c 	swi	r0, r4, 28
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
10002be4:	f8040020 	swi	r0, r4, 32
#if ((OS_MBOX_EN > 0u) ||                 \
    ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
#endif
    OS_EXIT_CRITICAL();
10002be8:	b9f45374 	brlid	r15, 21364	// 10007f5c <OS_CPU_SR_Restore>
10002bec:	f8040024 	swi	r0, r4, 36

    return (events_rdy_nbr);
}
10002bf0:	10780000 	addk	r3, r24, r0
10002bf4:	e9e10000 	lwi	r15, r1, 0
10002bf8:	ea61001c 	lwi	r19, r1, 28
10002bfc:	eac10020 	lwi	r22, r1, 32
10002c00:	eae10024 	lwi	r23, r1, 36
10002c04:	eb010028 	lwi	r24, r1, 40
10002c08:	eb21002c 	lwi	r25, r1, 44
10002c0c:	eb410030 	lwi	r26, r1, 48
10002c10:	eb610034 	lwi	r27, r1, 52
10002c14:	eb810038 	lwi	r28, r1, 56
10002c18:	eba1003c 	lwi	r29, r1, 60
10002c1c:	b60f0008 	rtsd	r15, 8
10002c20:	30210040 	addik	r1, r1, 64

10002c24 <OS_StrLen>:
{
    INT8U  len;


    len = 0u;
    while (*psrc != OS_ASCII_NUL) {
10002c24:	10800000 	addk	r4, r0, r0
10002c28:	a46400ff 	andi	r3, r4, 255
10002c2c:	30840001 	addik	r4, r4, 1
*              2) The string to check must be less than 255 characters long.
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
INT8U  OS_StrLen (INT8U *psrc)
10002c30:	10c52000 	addk	r6, r5, r4
{
    INT8U  len;


    len = 0u;
    while (*psrc != OS_ASCII_NUL) {
10002c34:	e0c6ffff 	lbui	r6, r6, -1
10002c38:	bc26fff0 	bnei	r6, -16		// 10002c28
        psrc++;
        len++;
    }
    return (len);
}
10002c3c:	b60f0008 	rtsd	r15, 8
10002c40:	80000000 	or	r0, r0, r0

10002c44 <OSEventNameGet>:

#if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
INT8U  OSEventNameGet (OS_EVENT   *pevent,
                       INT8U     **pname,
                       INT8U      *perr)
{
10002c44:	3021ffd0 	addik	r1, r1, -48
10002c48:	fae10024 	swi	r23, r1, 36
    if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10002c4c:	b0001000 	imm	4096
10002c50:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>

#if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
INT8U  OSEventNameGet (OS_EVENT   *pevent,
                       INT8U     **pname,
                       INT8U      *perr)
{
10002c54:	fa61001c 	swi	r19, r1, 28
10002c58:	fac10020 	swi	r22, r1, 32
10002c5c:	fb21002c 	swi	r25, r1, 44
10002c60:	f9e10000 	swi	r15, r1, 0
10002c64:	fb010028 	swi	r24, r1, 40
10002c68:	12650000 	addk	r19, r5, r0
10002c6c:	13260000 	addk	r25, r6, r0
    if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10002c70:	be170018 	beqid	r23, 24		// 10002c88
10002c74:	12c70000 	addk	r22, r7, r0
        *perr  = OS_ERR_NAME_GET_ISR;
10002c78:	30600011 	addik	r3, r0, 17
10002c7c:	f0670000 	sbi	r3, r7, 0
        return (0u);
10002c80:	b8100058 	brid	88		// 10002cd8
10002c84:	12600000 	addk	r19, r0, r0
    }
    switch (pevent->OSEventType) {
10002c88:	e0650000 	lbui	r3, r5, 0
10002c8c:	30800003 	addik	r4, r0, 3
10002c90:	3063ffff 	addik	r3, r3, -1
10002c94:	14632003 	cmpu	r3, r3, r4
10002c98:	bea30014 	bgeid	r3, 20		// 10002cac
10002c9c:	30600001 	addik	r3, r0, 1
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
10002ca0:	f0670000 	sbi	r3, r7, 0
             return (0u);
10002ca4:	b8100034 	brid	52		// 10002cd8
10002ca8:	12770000 	addk	r19, r23, r0
    }
    OS_ENTER_CRITICAL();
10002cac:	b9f45280 	brlid	r15, 21120	// 10007f2c <OS_CPU_SR_Save>
10002cb0:	80000000 	or	r0, r0, r0
    *pname = pevent->OSEventName;
10002cb4:	e8930014 	lwi	r4, r19, 20

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0u);
    }
    OS_ENTER_CRITICAL();
10002cb8:	13030000 	addk	r24, r3, r0
    *pname = pevent->OSEventName;
    len    = OS_StrLen(*pname);
10002cbc:	10a40000 	addk	r5, r4, r0
10002cc0:	b9f4ff64 	brlid	r15, -156	// 10002c24 <OS_StrLen>
10002cc4:	f8990000 	swi	r4, r25, 0
    OS_EXIT_CRITICAL();
10002cc8:	10b80000 	addk	r5, r24, r0
10002ccc:	b9f45290 	brlid	r15, 21136	// 10007f5c <OS_CPU_SR_Restore>
10002cd0:	12630000 	addk	r19, r3, r0
    *perr  = OS_ERR_NONE;
10002cd4:	f2f60000 	sbi	r23, r22, 0
    return (len);
}
10002cd8:	10730000 	addk	r3, r19, r0
10002cdc:	e9e10000 	lwi	r15, r1, 0
10002ce0:	ea61001c 	lwi	r19, r1, 28
10002ce4:	eac10020 	lwi	r22, r1, 32
10002ce8:	eae10024 	lwi	r23, r1, 36
10002cec:	eb010028 	lwi	r24, r1, 40
10002cf0:	eb21002c 	lwi	r25, r1, 44
10002cf4:	b60f0008 	rtsd	r15, 8
10002cf8:	30210030 	addik	r1, r1, 48

10002cfc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
void  OS_TaskStatStkChk (void)
{
10002cfc:	3021ffd4 	addik	r1, r1, -44
10002d00:	fac10028 	swi	r22, r1, 40
10002d04:	12c00000 	addk	r22, r0, r0
10002d08:	fa610024 	swi	r19, r1, 36
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
10002d0c:	12760000 	addk	r19, r22, r0
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
void  OS_TaskStatStkChk (void)
{
10002d10:	f9e10000 	swi	r15, r1, 0
    INT8U        err;
    INT8U        prio;


    for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
        err = OSTaskStkChk(prio, &stk_data);
10002d14:	10b30000 	addk	r5, r19, r0
10002d18:	b9f43bac 	brlid	r15, 15276	// 100068c4 <OSTaskStkChk>
10002d1c:	30c1001c 	addik	r6, r1, 28
        if (err == OS_ERR_NONE) {
10002d20:	bc230034 	bnei	r3, 52		// 10002d54
            ptcb = OSTCBPrioTbl[prio];
10002d24:	b0001000 	imm	4096
10002d28:	e876e0a4 	lwi	r3, r22, -8028
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
10002d2c:	be030028 	beqid	r3, 40		// 10002d54
10002d30:	a8830001 	xori	r4, r3, 1
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
10002d34:	bc040020 	beqi	r4, 32		// 10002d54
#if OS_TASK_PROFILE_EN > 0u
                    #if OS_STK_GROWTH == 1u
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
10002d38:	e883000c 	lwi	r4, r3, 12
10002d3c:	e8a30008 	lwi	r5, r3, 8
10002d40:	64840402 	bslli	r4, r4, 2
10002d44:	10852000 	addk	r4, r5, r4
10002d48:	f8830048 	swi	r4, r3, 72
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
10002d4c:	e8810020 	lwi	r4, r1, 32
10002d50:	f883004c 	swi	r4, r3, 76
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
10002d54:	32730001 	addik	r19, r19, 1
10002d58:	a67300ff 	andi	r19, r19, 255
10002d5c:	a8730040 	xori	r3, r19, 64
10002d60:	be23ffb4 	bneid	r3, -76		// 10002d14
10002d64:	32d60004 	addik	r22, r22, 4
#endif
                }
            }
        }
    }
}
10002d68:	e9e10000 	lwi	r15, r1, 0
10002d6c:	ea610024 	lwi	r19, r1, 36
10002d70:	eac10028 	lwi	r22, r1, 40
10002d74:	b60f0008 	rtsd	r15, 8
10002d78:	3021002c 	addik	r1, r1, 44

10002d7c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0u
void  OS_TaskStat (void *p_arg)
{
10002d7c:	3021ffe4 	addik	r1, r1, -28
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
10002d80:	b8100010 	brid	16		// 10002d90
10002d84:	f9e10000 	swi	r15, r1, 0
        OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
10002d88:	b9f4407c 	brlid	r15, 16508	// 10006e04 <OSTimeDly>
10002d8c:	30a00014 	addik	r5, r0, 20	// 14 <STK_OFFSET_R06>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
10002d90:	b0001000 	imm	4096
10002d94:	e060e0a0 	lbui	r3, r0, -8032	// 1000e0a0 <OSStatRdy>
10002d98:	be03fff0 	beqid	r3, -16		// 10002d88
10002d9c:	30600064 	addik	r3, r0, 100	// 64 <STK_OFFSET_R27>
        OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
10002da0:	b0001000 	imm	4096
10002da4:	e880d380 	lwi	r4, r0, -11392	// 1000d380 <OSIdleCtrMax>
10002da8:	48632002 	idivu	r3, r3, r4
10002dac:	b0001000 	imm	4096
10002db0:	f860d380 	swi	r3, r0, -11392	// 1000d380 <OSIdleCtrMax>
    if (OSIdleCtrMax == 0L) {
10002db4:	bc230014 	bnei	r3, 20		// 10002dc8
        OSCPUUsage = 0u;
10002db8:	b0001000 	imm	4096
10002dbc:	f060d388 	sbi	r3, r0, -11384	// 1000d388 <OSCPUUsage>
#if OS_TASK_SUSPEND_EN > 0u
        (void)OSTaskSuspend(OS_PRIO_SELF);
10002dc0:	b9f43be0 	brlid	r15, 15328	// 100069a0 <OSTaskSuspend>
10002dc4:	30a000ff 	addik	r5, r0, 255
            OSTimeDly(OS_TICKS_PER_SEC);
        }
#endif
    }
    for (;;) {
        OS_ENTER_CRITICAL();
10002dc8:	b9f45164 	brlid	r15, 20836	// 10007f2c <OS_CPU_SR_Save>
10002dcc:	80000000 	or	r0, r0, r0
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
        OS_EXIT_CRITICAL();
10002dd0:	10a30000 	addk	r5, r3, r0
        }
#endif
    }
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
10002dd4:	b0001000 	imm	4096
10002dd8:	e880ce1c 	lwi	r4, r0, -12772	// 1000ce1c <OSIdleCtr>
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
10002ddc:	b0001000 	imm	4096
10002de0:	f800ce1c 	swi	r0, r0, -12772	// 1000ce1c <OSIdleCtr>
        }
#endif
    }
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
10002de4:	b0001000 	imm	4096
10002de8:	f880e1a4 	swi	r4, r0, -7772	// 1000e1a4 <OSIdleCtrRun>
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
        OS_EXIT_CRITICAL();
10002dec:	b9f45170 	brlid	r15, 20848	// 10007f5c <OS_CPU_SR_Restore>
10002df0:	80000000 	or	r0, r0, r0
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
10002df4:	b0001000 	imm	4096
10002df8:	e880e1a4 	lwi	r4, r0, -7772	// 1000e1a4 <OSIdleCtrRun>
10002dfc:	b0001000 	imm	4096
10002e00:	e860d380 	lwi	r3, r0, -11392	// 1000d380 <OSIdleCtrMax>
10002e04:	48632002 	idivu	r3, r3, r4
10002e08:	30800064 	addik	r4, r0, 100	// 64 <STK_OFFSET_R27>
10002e0c:	14632000 	rsubk	r3, r3, r4
10002e10:	b0001000 	imm	4096
10002e14:	f060d388 	sbi	r3, r0, -11384	// 1000d388 <OSCPUUsage>
        OSTaskStatHook();                        /* Invoke user definable hook                         */
10002e18:	b9f44e1c 	brlid	r15, 19996	// 10007c34 <OSTaskStatHook>
10002e1c:	80000000 	or	r0, r0, r0
#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
10002e20:	b9f4fedc 	brlid	r15, -292	// 10002cfc <OS_TaskStatStkChk>
10002e24:	80000000 	or	r0, r0, r0
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
10002e28:	b9f43fdc 	brlid	r15, 16348	// 10006e04 <OSTimeDly>
10002e2c:	30a0000a 	addik	r5, r0, 10
10002e30:	b800ff98 	bri	-104		// 10002dc8

10002e34 <OS_TCBInit>:
                   OS_STK  *pbos,
                   INT16U   id,
                   INT32U   stk_size,
                   void    *pext,
                   INT16U   opt)
{
10002e34:	3021ffc8 	addik	r1, r1, -56
10002e38:	fa61001c 	swi	r19, r1, 28
10002e3c:	fac10020 	swi	r22, r1, 32
10002e40:	fae10024 	swi	r23, r1, 36
10002e44:	fb010028 	swi	r24, r1, 40
10002e48:	fb21002c 	swi	r25, r1, 44
10002e4c:	fb410030 	swi	r26, r1, 48
10002e50:	fb610034 	swi	r27, r1, 52
10002e54:	12c50000 	addk	r22, r5, r0
10002e58:	f9e10000 	swi	r15, r1, 0
10002e5c:	13660000 	addk	r27, r6, r0
10002e60:	13070000 	addk	r24, r7, r0
10002e64:	12e80000 	addk	r23, r8, r0
10002e68:	13290000 	addk	r25, r9, r0
#if OS_TASK_REG_TBL_SIZE > 0u
    INT8U      i;
#endif


    OS_ENTER_CRITICAL();
10002e6c:	b9f450c0 	brlid	r15, 20672	// 10007f2c <OS_CPU_SR_Save>
10002e70:	134a0000 	addk	r26, r10, r0
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
10002e74:	b0001000 	imm	4096
10002e78:	ea60d384 	lwi	r19, r0, -11388	// 1000d384 <OSTCBFreeList>
    if (ptcb != (OS_TCB *)0) {
10002e7c:	be130140 	beqid	r19, 320		// 10002fbc
10002e80:	10a30000 	addk	r5, r3, r0
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
10002e84:	e8730014 	lwi	r3, r19, 20
10002e88:	b0001000 	imm	4096
10002e8c:	f860d384 	swi	r3, r0, -11388	// 1000d384 <OSTCBFreeList>
        OS_EXIT_CRITICAL();
10002e90:	b9f450cc 	brlid	r15, 20684	// 10007f5c <OS_CPU_SR_Restore>
10002e94:	80000000 	or	r0, r0, r0

#if OS_TASK_CREATE_EXT_EN > 0u
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
10002e98:	e4610056 	lhui	r3, r1, 86
#endif

#if OS_LOWEST_PRIO <= 63u
        ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
        ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
        ptcb->OSTCBBitY          = (INT8U)(1u << ptcb->OSTCBY);
10002e9c:	30800001 	addik	r4, r0, 1
#if OS_TASK_DEL_EN > 0u
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63u
        ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
10002ea0:	64b60003 	bsrli	r5, r22, 3

#if OS_TASK_CREATE_EXT_EN > 0u
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
10002ea4:	f4730010 	shi	r3, r19, 16
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63u
        ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
        ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
10002ea8:	a4760007 	andi	r3, r22, 7
10002eac:	f0730037 	sbi	r3, r19, 55
        ptcb->OSTCBBitY          = (INT8U)(1u << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT8U)(1u << ptcb->OSTCBX);
10002eb0:	44641c00 	bsll	r3, r4, r3
#if OS_TASK_DEL_EN > 0u
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63u
        ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
10002eb4:	f0b30038 	sbi	r5, r19, 56
        ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
        ptcb->OSTCBBitY          = (INT8U)(1u << ptcb->OSTCBY);
10002eb8:	44a42c00 	bsll	r5, r4, r5
        ptcb->OSTCBBitX          = (INT8U)(1u << ptcb->OSTCBX);
10002ebc:	f0730039 	sbi	r3, r19, 57
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_EN > 0u
        ptcb->OSTCBTaskName    = (INT8U *)"?";
10002ec0:	b0001000 	imm	4096
10002ec4:	306089d0 	addik	r3, r0, -30256
#endif

#if OS_LOWEST_PRIO <= 63u
        ptcb->OSTCBY             = (INT8U)(prio >> 3u);           /* Pre-compute X, Y, BitX and BitY   */
        ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
        ptcb->OSTCBBitY          = (INT8U)(1u << ptcb->OSTCBY);
10002ec8:	f0b3003a 	sbi	r5, r19, 58
        for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
            ptcb->OSTCBRegTbl[i] = 0u;
        }
#endif

        OSTCBInitHook(ptcb);
10002ecc:	10b30000 	addk	r5, r19, r0
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_EN > 0u
        ptcb->OSTCBTaskName    = (INT8U *)"?";
10002ed0:	f8730050 	swi	r3, r19, 80
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
10002ed4:	f2d30036 	sbi	r22, r19, 54
    OS_ENTER_CRITICAL();
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
10002ed8:	fb730000 	swi	r27, r19, 0
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
10002edc:	f0130034 	sbi	r0, r19, 52
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
10002ee0:	f0130035 	sbi	r0, r19, 53
        ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
10002ee4:	f8130030 	swi	r0, r19, 48

#if OS_TASK_CREATE_EXT_EN > 0u
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
10002ee8:	fb530004 	swi	r26, r19, 4
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
10002eec:	fb33000c 	swi	r25, r19, 12
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
10002ef0:	fb130008 	swi	r24, r19, 8
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
10002ef4:	f6f30012 	shi	r23, r19, 18
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0u
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
10002ef8:	f013003b 	sbi	r0, r19, 59
        ptcb->OSTCBBitY          = (INT16U)(1u << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1u << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
10002efc:	f813001c 	swi	r0, r19, 28
#if (OS_EVENT_MULTI_EN > 0u)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
10002f00:	f8130020 	swi	r0, r19, 32
#endif
#endif

#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
10002f04:	f8130028 	swi	r0, r19, 40
#endif

#if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
10002f08:	f8130024 	swi	r0, r19, 36
#endif

#if OS_TASK_PROFILE_EN > 0u
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
10002f0c:	f813003c 	swi	r0, r19, 60
        ptcb->OSTCBCyclesStart = 0L;
10002f10:	f8130044 	swi	r0, r19, 68
        ptcb->OSTCBCyclesTot   = 0L;
10002f14:	f8130040 	swi	r0, r19, 64
        ptcb->OSTCBStkBase     = (OS_STK *)0;
10002f18:	f8130048 	swi	r0, r19, 72
        ptcb->OSTCBStkUsed     = 0L;
10002f1c:	f813004c 	swi	r0, r19, 76
        for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
            ptcb->OSTCBRegTbl[i] = 0u;
        }
#endif

        OSTCBInitHook(ptcb);
10002f20:	b9f44e84 	brlid	r15, 20100	// 10007da4 <OSTCBInitHook>
10002f24:	f8130054 	swi	r0, r19, 84

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
10002f28:	10b30000 	addk	r5, r19, r0
10002f2c:	b9f44ce8 	brlid	r15, 19688	// 10007c14 <OSTaskCreateHook>
10002f30:	66d60402 	bslli	r22, r22, 2

        OS_ENTER_CRITICAL();
10002f34:	b9f44ff8 	brlid	r15, 20472	// 10007f2c <OS_CPU_SR_Save>
10002f38:	80000000 	or	r0, r0, r0
        OSTCBPrioTbl[prio] = ptcb;
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
10002f3c:	b0001000 	imm	4096
10002f40:	e880d0f8 	lwi	r4, r0, -12040	// 1000d0f8 <OSTCBList>
        OSTCBInitHook(ptcb);

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
10002f44:	b0001000 	imm	4096
10002f48:	fa76e0a4 	swi	r19, r22, -8028
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
10002f4c:	f8130018 	swi	r0, r19, 24
        if (OSTCBList != (OS_TCB *)0) {
10002f50:	be04000c 	beqid	r4, 12		// 10002f5c
10002f54:	f8930014 	swi	r4, r19, 20
            OSTCBList->OSTCBPrev = ptcb;
10002f58:	fa640018 	swi	r19, r4, 24
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
10002f5c:	e0b3003a 	lbui	r5, r19, 58
10002f60:	b0001000 	imm	4096
10002f64:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
10002f68:	b0001000 	imm	4096
10002f6c:	fa60d0f8 	swi	r19, r0, -12040	// 1000d0f8 <OSTCBList>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
10002f70:	80852000 	or	r4, r5, r4
10002f74:	b0001000 	imm	4096
10002f78:	f080d3f8 	sbi	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10002f7c:	e0930038 	lbui	r4, r19, 56
10002f80:	e0b30039 	lbui	r5, r19, 57
10002f84:	b0001000 	imm	4096
10002f88:	e0c4d3fc 	lbui	r6, r4, -11268
10002f8c:	80a62800 	or	r5, r6, r5
10002f90:	b0001000 	imm	4096
10002f94:	f0a4d3fc 	sbi	r5, r4, -11268
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
10002f98:	b0001000 	imm	4096
10002f9c:	e080d389 	lbui	r4, r0, -11383	// 1000d389 <OSTaskCtr>
10002fa0:	30840001 	addik	r4, r4, 1
10002fa4:	b0001000 	imm	4096
10002fa8:	f080d389 	sbi	r4, r0, -11383	// 1000d389 <OSTaskCtr>
        OS_EXIT_CRITICAL();
10002fac:	b9f44fb0 	brlid	r15, 20400	// 10007f5c <OS_CPU_SR_Restore>
10002fb0:	10a30000 	addk	r5, r3, r0
        return (OS_ERR_NONE);
10002fb4:	b8100014 	brid	20		// 10002fc8
10002fb8:	10600000 	addk	r3, r0, r0
    }
    OS_EXIT_CRITICAL();
10002fbc:	b9f44fa0 	brlid	r15, 20384	// 10007f5c <OS_CPU_SR_Restore>
10002fc0:	80000000 	or	r0, r0, r0
    return (OS_ERR_TASK_NO_MORE_TCB);
10002fc4:	30600042 	addik	r3, r0, 66
}
10002fc8:	e9e10000 	lwi	r15, r1, 0
10002fcc:	ea61001c 	lwi	r19, r1, 28
10002fd0:	eac10020 	lwi	r22, r1, 32
10002fd4:	eae10024 	lwi	r23, r1, 36
10002fd8:	eb010028 	lwi	r24, r1, 40
10002fdc:	eb21002c 	lwi	r25, r1, 44
10002fe0:	eb410030 	lwi	r26, r1, 48
10002fe4:	eb610034 	lwi	r27, r1, 52
10002fe8:	b60f0008 	rtsd	r15, 8
10002fec:	30210038 	addik	r1, r1, 56

10002ff0 <OS_FlagBlock>:
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
10002ff0:	b0001000 	imm	4096
10002ff4:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10002ff8:	e0830034 	lbui	r4, r3, 52
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
10002ffc:	f0030035 	sbi	r0, r3, 53
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
10003000:	f9230030 	swi	r9, r3, 48
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
10003004:	a0840020 	ori	r4, r4, 32
10003008:	f0830034 	sbi	r4, r3, 52
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
#if OS_TASK_DEL_EN > 0u
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
1000300c:	f8c30028 	swi	r6, r3, 40
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
10003010:	f1060012 	sbi	r8, r6, 18
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
10003014:	e8850004 	lwi	r4, r5, 4
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
#if OS_TASK_DEL_EN > 0u
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
10003018:	f4e60010 	shi	r7, r6, 16
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
1000301c:	f8660008 	swi	r3, r6, 8
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
10003020:	f8860000 	swi	r4, r6, 0
    pnode->OSFlagNodePrev     = (void *)0;
10003024:	f8060004 	swi	r0, r6, 4
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
10003028:	be04000c 	beqid	r4, 12		// 10003034
1000302c:	f8a6000c 	swi	r5, r6, 12
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
10003030:	f8c40004 	swi	r6, r4, 4
    }
    pgrp->OSFlagWaitList = (void *)pnode;
10003034:	f8c50004 	swi	r6, r5, 4

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
10003038:	e0a30038 	lbui	r5, r3, 56
1000303c:	e0830039 	lbui	r4, r3, 57
10003040:	b0001000 	imm	4096
10003044:	e0c5d3fc 	lbui	r6, r5, -11268
10003048:	a884ffff 	xori	r4, r4, -1
1000304c:	84843000 	and	r4, r4, r6
10003050:	b0001000 	imm	4096
10003054:	f085d3fc 	sbi	r4, r5, -11268
    if (OSRdyTbl[y] == 0x00) {
10003058:	bc240020 	bnei	r4, 32		// 10003078
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
1000305c:	e063003a 	lbui	r3, r3, 58
10003060:	b0001000 	imm	4096
10003064:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10003068:	a863ffff 	xori	r3, r3, -1
1000306c:	84632000 	and	r3, r3, r4
10003070:	b0001000 	imm	4096
10003074:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
10003078:	b60f0008 	rtsd	r15, 8
1000307c:	80000000 	or	r0, r0, r0

10003080 <OSFlagAccept>:
#if OS_FLAG_ACCEPT_EN > 0u
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                        OS_FLAGS      flags, 
                        INT8U         wait_type, 
                        INT8U        *perr)
{
10003080:	3021ffd0 	addik	r1, r1, -48
10003084:	fa61001c 	swi	r19, r1, 28
10003088:	fac10020 	swi	r22, r1, 32
1000308c:	fae10024 	swi	r23, r1, 36
10003090:	fb21002c 	swi	r25, r1, 44
10003094:	f9e10000 	swi	r15, r1, 0
10003098:	fb010028 	swi	r24, r1, 40
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
1000309c:	e0650000 	lbui	r3, r5, 0
#if OS_FLAG_ACCEPT_EN > 0u
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                        OS_FLAGS      flags, 
                        INT8U         wait_type, 
                        INT8U        *perr)
{
100030a0:	12c50000 	addk	r22, r5, r0
100030a4:	13260000 	addk	r25, r6, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
100030a8:	a8630005 	xori	r3, r3, 5
#if OS_FLAG_ACCEPT_EN > 0u
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                        OS_FLAGS      flags, 
                        INT8U         wait_type, 
                        INT8U        *perr)
{
100030ac:	12670000 	addk	r19, r7, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
100030b0:	be030010 	beqid	r3, 16		// 100030c0
100030b4:	12e80000 	addk	r23, r8, r0
        *perr = OS_ERR_EVENT_TYPE;
100030b8:	b81000ec 	brid	236		// 100031a4
100030bc:	30600001 	addik	r3, r0, 1
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
100030c0:	a7070080 	andi	r24, r7, 128
100030c4:	a71800ff 	andi	r24, r24, 255
100030c8:	bc18000c 	beqi	r24, 12		// 100030d4
        wait_type &= ~OS_FLAG_CONSUME;
100030cc:	a667007f 	andi	r19, r7, 127
        consume    = OS_TRUE;
100030d0:	33000001 	addik	r24, r0, 1
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
    OS_ENTER_CRITICAL();
100030d4:	b9f44e58 	brlid	r15, 20056	// 10007f2c <OS_CPU_SR_Save>
100030d8:	f0170000 	sbi	r0, r23, 0
100030dc:	10a30000 	addk	r5, r3, r0
    switch (wait_type) {
100030e0:	a8730001 	xori	r3, r19, 1
100030e4:	be030078 	beqid	r3, 120		// 1000315c
100030e8:	30600001 	addik	r3, r0, 1
100030ec:	14639803 	cmpu	r3, r3, r19
100030f0:	be430050 	bltid	r3, 80		// 10003140
100030f4:	a8730002 	xori	r3, r19, 2
100030f8:	be030010 	beqid	r3, 16		// 10003108
100030fc:	aa730003 	xori	r19, r19, 3
10003100:	bc130020 	beqi	r19, 32		// 10003120
10003104:	b8000094 	bri	148		// 10003198
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
10003108:	e4760008 	lhui	r3, r22, 8
1000310c:	86791800 	and	r19, r25, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
10003110:	8b33c800 	xor	r25, r19, r25
10003114:	be39006c 	bneid	r25, 108		// 10003180
10003118:	ab180001 	xori	r24, r24, 1
1000311c:	b8000014 	bri	20		// 10003130
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
10003120:	e4760008 	lhui	r3, r22, 8
10003124:	86791800 	and	r19, r25, r3
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
10003128:	be130058 	beqid	r19, 88		// 10003180
1000312c:	ab180001 	xori	r24, r24, 1
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
10003130:	be380058 	bneid	r24, 88		// 10003188
10003134:	a893ffff 	xori	r4, r19, -1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
10003138:	b8100040 	brid	64		// 10003178
1000313c:	84641800 	and	r3, r4, r3
             OS_EXIT_CRITICAL();
             break;

#if OS_FLAG_WAIT_CLR_EN > 0u
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
10003140:	e4760008 	lhui	r3, r22, 8
10003144:	aa63ffff 	xori	r19, r3, -1
10003148:	86799800 	and	r19, r25, r19
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
1000314c:	8b33c800 	xor	r25, r19, r25
10003150:	be390030 	bneid	r25, 48		// 10003180
10003154:	ab180001 	xori	r24, r24, 1
10003158:	b8000018 	bri	24		// 10003170
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
1000315c:	e4760008 	lhui	r3, r22, 8
10003160:	aa63ffff 	xori	r19, r3, -1
10003164:	86799800 	and	r19, r25, r19
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
10003168:	be130018 	beqid	r19, 24		// 10003180
1000316c:	ab180001 	xori	r24, r24, 1
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
10003170:	bc380018 	bnei	r24, 24		// 10003188
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
10003174:	80731800 	or	r3, r19, r3
10003178:	b8100010 	brid	16		// 10003188
1000317c:	f4760008 	shi	r3, r22, 8
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
10003180:	30600070 	addik	r3, r0, 112	// 70 <STK_OFFSET_R30>
10003184:	f0770000 	sbi	r3, r23, 0
             }
             OS_EXIT_CRITICAL();
10003188:	b9f44dd4 	brlid	r15, 19924	// 10007f5c <OS_CPU_SR_Restore>
1000318c:	80000000 	or	r0, r0, r0
             break;
10003190:	b8100020 	brid	32		// 100031b0
10003194:	10730000 	addk	r3, r19, r0
#endif

        default:
             OS_EXIT_CRITICAL();
10003198:	b9f44dc4 	brlid	r15, 19908	// 10007f5c <OS_CPU_SR_Restore>
1000319c:	80000000 	or	r0, r0, r0
             flags_rdy = (OS_FLAGS)0;
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
100031a0:	3060006f 	addik	r3, r0, 111
100031a4:	f0770000 	sbi	r3, r23, 0
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
100031a8:	12600000 	addk	r19, r0, r0
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
             break;
    }
    return (flags_rdy);
}
100031ac:	10730000 	addk	r3, r19, r0
100031b0:	e9e10000 	lwi	r15, r1, 0
100031b4:	ea61001c 	lwi	r19, r1, 28
100031b8:	eac10020 	lwi	r22, r1, 32
100031bc:	eae10024 	lwi	r23, r1, 36
100031c0:	eb010028 	lwi	r24, r1, 40
100031c4:	eb21002c 	lwi	r25, r1, 44
100031c8:	b60f0008 	rtsd	r15, 8
100031cc:	30210030 	addik	r1, r1, 48

100031d0 <OSFlagCreate>:
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags, 
                            INT8U    *perr)
{
100031d0:	3021ffd4 	addik	r1, r1, -44
100031d4:	fae10024 	swi	r23, r1, 36
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif
                                                           
    if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
100031d8:	b0001000 	imm	4096
100031dc:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags, 
                            INT8U    *perr)
{
100031e0:	fac10020 	swi	r22, r1, 32
100031e4:	fb010028 	swi	r24, r1, 40
100031e8:	f9e10000 	swi	r15, r1, 0
100031ec:	fa61001c 	swi	r19, r1, 28
100031f0:	13050000 	addk	r24, r5, r0
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif
                                                           
    if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
100031f4:	be170018 	beqid	r23, 24		// 1000320c
100031f8:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
100031fc:	30600010 	addik	r3, r0, 16	// 10 <STK_OFFSET_R05>
10003200:	f0660000 	sbi	r3, r6, 0
        return ((OS_FLAG_GRP *)0);
10003204:	b8100064 	brid	100		// 10003268
10003208:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
1000320c:	b9f44d20 	brlid	r15, 19744	// 10007f2c <OS_CPU_SR_Save>
10003210:	80000000 	or	r0, r0, r0
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
10003214:	b0001000 	imm	4096
10003218:	ea60e09c 	lwi	r19, r0, -8036	// 1000e09c <OSFlagFreeList>
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
1000321c:	be13003c 	beqid	r19, 60		// 10003258
10003220:	10a30000 	addk	r5, r3, r0
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
10003224:	e8930004 	lwi	r4, r19, 4
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
10003228:	f7130008 	shi	r24, r19, 8
    }
    OS_ENTER_CRITICAL();
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
1000322c:	b0001000 	imm	4096
10003230:	f880e09c 	swi	r4, r0, -8036	// 1000e09c <OSFlagFreeList>
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
10003234:	30800005 	addik	r4, r0, 5
10003238:	f0930000 	sbi	r4, r19, 0
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
#if OS_FLAG_NAME_EN > 0u
        pgrp->OSFlagName     = (INT8U *)"?";
1000323c:	b0001000 	imm	4096
10003240:	30808af4 	addik	r4, r0, -29964
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
10003244:	faf30004 	swi	r23, r19, 4
#if OS_FLAG_NAME_EN > 0u
        pgrp->OSFlagName     = (INT8U *)"?";
#endif
        OS_EXIT_CRITICAL();
10003248:	b9f44d14 	brlid	r15, 19732	// 10007f5c <OS_CPU_SR_Restore>
1000324c:	f893000c 	swi	r4, r19, 12
        *perr                = OS_ERR_NONE;
10003250:	b8100018 	brid	24		// 10003268
10003254:	f2f60000 	sbi	r23, r22, 0
    } else {
        OS_EXIT_CRITICAL();
10003258:	b9f44d04 	brlid	r15, 19716	// 10007f5c <OS_CPU_SR_Restore>
1000325c:	10a30000 	addk	r5, r3, r0
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
10003260:	30600072 	addik	r3, r0, 114
10003264:	f0760000 	sbi	r3, r22, 0
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
}
10003268:	10730000 	addk	r3, r19, r0
1000326c:	e9e10000 	lwi	r15, r1, 0
10003270:	ea61001c 	lwi	r19, r1, 28
10003274:	eac10020 	lwi	r22, r1, 32
10003278:	eae10024 	lwi	r23, r1, 36
1000327c:	eb010028 	lwi	r24, r1, 40
10003280:	b60f0008 	rtsd	r15, 8
10003284:	3021002c 	addik	r1, r1, 44

10003288 <OSFlagNameGet>:

#if OS_FLAG_NAME_EN > 0u
INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp, 
                      INT8U        **pname, 
                      INT8U         *perr)
{
10003288:	3021ffcc 	addik	r1, r1, -52
1000328c:	fa61001c 	swi	r19, r1, 28
    if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10003290:	b0001000 	imm	4096
10003294:	e260d608 	lbui	r19, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_FLAG_NAME_EN > 0u
INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp, 
                      INT8U        **pname, 
                      INT8U         *perr)
{
10003298:	fac10020 	swi	r22, r1, 32
1000329c:	fb21002c 	swi	r25, r1, 44
100032a0:	fb410030 	swi	r26, r1, 48
100032a4:	f9e10000 	swi	r15, r1, 0
100032a8:	fae10024 	swi	r23, r1, 36
100032ac:	fb010028 	swi	r24, r1, 40
100032b0:	13250000 	addk	r25, r5, r0
100032b4:	13460000 	addk	r26, r6, r0
    if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
100032b8:	be130018 	beqid	r19, 24		// 100032d0
100032bc:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_NAME_GET_ISR;
100032c0:	30600011 	addik	r3, r0, 17
100032c4:	f0670000 	sbi	r3, r7, 0
        return (0u);
100032c8:	b8100054 	brid	84		// 1000331c
100032cc:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
100032d0:	b9f44c5c 	brlid	r15, 19548	// 10007f2c <OS_CPU_SR_Save>
100032d4:	80000000 	or	r0, r0, r0
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
100032d8:	e2f90000 	lbui	r23, r25, 0
100032dc:	aaf70005 	xori	r23, r23, 5
100032e0:	be17001c 	beqid	r23, 28		// 100032fc
100032e4:	13030000 	addk	r24, r3, r0
        OS_EXIT_CRITICAL();
100032e8:	b9f44c74 	brlid	r15, 19572	// 10007f5c <OS_CPU_SR_Restore>
100032ec:	10a30000 	addk	r5, r3, r0
        *perr = OS_ERR_EVENT_TYPE;
100032f0:	30600001 	addik	r3, r0, 1
        return (0u);
100032f4:	b8100028 	brid	40		// 1000331c
100032f8:	f0760000 	sbi	r3, r22, 0
    }
    *pname = pgrp->OSFlagName;
100032fc:	e899000c 	lwi	r4, r25, 12
    len    = OS_StrLen(*pname);
10003300:	10a40000 	addk	r5, r4, r0
10003304:	b9f4f920 	brlid	r15, -1760	// 10002c24 <OS_StrLen>
10003308:	f89a0000 	swi	r4, r26, 0
    OS_EXIT_CRITICAL();
1000330c:	10b80000 	addk	r5, r24, r0
10003310:	b9f44c4c 	brlid	r15, 19532	// 10007f5c <OS_CPU_SR_Restore>
10003314:	12630000 	addk	r19, r3, r0
    *perr  = OS_ERR_NONE;
10003318:	f2f60000 	sbi	r23, r22, 0
    return (len);
}
1000331c:	10730000 	addk	r3, r19, r0
10003320:	e9e10000 	lwi	r15, r1, 0
10003324:	ea61001c 	lwi	r19, r1, 28
10003328:	eac10020 	lwi	r22, r1, 32
1000332c:	eae10024 	lwi	r23, r1, 36
10003330:	eb010028 	lwi	r24, r1, 40
10003334:	eb21002c 	lwi	r25, r1, 44
10003338:	eb410030 	lwi	r26, r1, 48
1000333c:	b60f0008 	rtsd	r15, 8
10003340:	30210034 	addik	r1, r1, 52

10003344 <OSFlagNameSet>:
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10003344:	b0001000 	imm	4096
10003348:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_FLAG_NAME_EN > 0u
void  OSFlagNameSet (OS_FLAG_GRP  *pgrp, 
                     INT8U        *pname, 
                     INT8U        *perr)
{
1000334c:	3021ffd4 	addik	r1, r1, -44
10003350:	fa61001c 	swi	r19, r1, 28
10003354:	fae10024 	swi	r23, r1, 36
10003358:	fb010028 	swi	r24, r1, 40
1000335c:	f9e10000 	swi	r15, r1, 0
10003360:	fac10020 	swi	r22, r1, 32
10003364:	12e50000 	addk	r23, r5, r0
10003368:	13060000 	addk	r24, r6, r0
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
1000336c:	be030010 	beqid	r3, 16		// 1000337c
10003370:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_NAME_SET_ISR;
10003374:	b810002c 	brid	44		// 100033a0
10003378:	30600012 	addik	r3, r0, 18
        return;
    }
    OS_ENTER_CRITICAL();
1000337c:	b9f44bb0 	brlid	r15, 19376	// 10007f2c <OS_CPU_SR_Save>
10003380:	80000000 	or	r0, r0, r0
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
10003384:	e2d70000 	lbui	r22, r23, 0
10003388:	aad60005 	xori	r22, r22, 5
1000338c:	be16001c 	beqid	r22, 28		// 100033a8
10003390:	10a30000 	addk	r5, r3, r0
        OS_EXIT_CRITICAL();
10003394:	b9f44bc8 	brlid	r15, 19400	// 10007f5c <OS_CPU_SR_Restore>
10003398:	10a30000 	addk	r5, r3, r0
        *perr = OS_ERR_EVENT_TYPE;
1000339c:	30600001 	addik	r3, r0, 1
        return;
100033a0:	b8100014 	brid	20		// 100033b4
100033a4:	f0730000 	sbi	r3, r19, 0
    }
    pgrp->OSFlagName = pname;
    OS_EXIT_CRITICAL();
100033a8:	b9f44bb4 	brlid	r15, 19380	// 10007f5c <OS_CPU_SR_Restore>
100033ac:	fb17000c 	swi	r24, r23, 12
    *perr            = OS_ERR_NONE;
100033b0:	f2d30000 	sbi	r22, r19, 0
    return;
}
100033b4:	e9e10000 	lwi	r15, r1, 0
100033b8:	ea61001c 	lwi	r19, r1, 28
100033bc:	eac10020 	lwi	r22, r1, 32
100033c0:	eae10024 	lwi	r23, r1, 36
100033c4:	eb010028 	lwi	r24, r1, 40
100033c8:	b60f0008 	rtsd	r15, 8
100033cc:	3021002c 	addik	r1, r1, 44

100033d0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
100033d0:	3021ffe0 	addik	r1, r1, -32
100033d4:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR     cpu_sr = 0u;
#endif



    OS_ENTER_CRITICAL();
100033d8:	b9f44b54 	brlid	r15, 19284	// 10007f2c <OS_CPU_SR_Save>
100033dc:	fa61001c 	swi	r19, r1, 28
    flags = OSTCBCur->OSTCBFlagsRdy;
100033e0:	b0001000 	imm	4096
100033e4:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OS_EXIT_CRITICAL();
100033e8:	10a30000 	addk	r5, r3, r0
100033ec:	b9f44b70 	brlid	r15, 19312	// 10007f5c <OS_CPU_SR_Restore>
100033f0:	e664002c 	lhui	r19, r4, 44
    return (flags);
}
100033f4:	e9e10000 	lwi	r15, r1, 0
100033f8:	10730000 	addk	r3, r19, r0
100033fc:	ea61001c 	lwi	r19, r1, 28
10003400:	b60f0008 	rtsd	r15, 8
10003404:	30210020 	addik	r1, r1, 32

10003408 <OSFlagQuery>:
*/

#if OS_FLAG_QUERY_EN > 0u
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp, 
                       INT8U        *perr)
{
10003408:	3021ffd8 	addik	r1, r1, -40
1000340c:	fa61001c 	swi	r19, r1, 28
10003410:	fac10020 	swi	r22, r1, 32
10003414:	f9e10000 	swi	r15, r1, 0
10003418:	fae10024 	swi	r23, r1, 36
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
1000341c:	e2e50000 	lbui	r23, r5, 0
*/

#if OS_FLAG_QUERY_EN > 0u
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp, 
                       INT8U        *perr)
{
10003420:	12650000 	addk	r19, r5, r0
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
10003424:	aaf70005 	xori	r23, r23, 5
10003428:	be170018 	beqid	r23, 24		// 10003440
1000342c:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_EVENT_TYPE;
10003430:	30600001 	addik	r3, r0, 1
10003434:	f0660000 	sbi	r3, r6, 0
        return ((OS_FLAGS)0);
10003438:	b8100020 	brid	32		// 10003458
1000343c:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
10003440:	b9f44aec 	brlid	r15, 19180	// 10007f2c <OS_CPU_SR_Save>
10003444:	80000000 	or	r0, r0, r0
    flags = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
10003448:	10a30000 	addk	r5, r3, r0
1000344c:	b9f44b10 	brlid	r15, 19216	// 10007f5c <OS_CPU_SR_Restore>
10003450:	e6730008 	lhui	r19, r19, 8
    *perr = OS_ERR_NONE;
10003454:	f2f60000 	sbi	r23, r22, 0
    return (flags);                               /* Return the current value of the event flags       */
}
10003458:	10730000 	addk	r3, r19, r0
1000345c:	e9e10000 	lwi	r15, r1, 0
10003460:	ea61001c 	lwi	r19, r1, 28
10003464:	eac10020 	lwi	r22, r1, 32
10003468:	eae10024 	lwi	r23, r1, 36
1000346c:	b60f0008 	rtsd	r15, 8
10003470:	30210028 	addik	r1, r1, 40

10003474 <OS_FlagInit>:
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
10003474:	b0001000 	imm	4096
10003478:	30a0ce24 	addik	r5, r0, -12764	// 1000ce24 <OSFlagTbl>
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
1000347c:	3021ffe4 	addik	r1, r1, -28
10003480:	f9e10000 	swi	r15, r1, 0
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
10003484:	b9f4f078 	brlid	r15, -3976	// 100024fc <OS_MemClr>
10003488:	30c00050 	addik	r6, r0, 80	// 50 <STK_OFFSET_R22>
*
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
1000348c:	b0001000 	imm	4096
10003490:	30e0ce34 	addik	r7, r0, -12748
    pgrp2 = &OSFlagTbl[1];
    for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        pgrp1->OSFlagWaitList = (void *)pgrp2;
#if OS_FLAG_NAME_EN > 0u
        pgrp1->OSFlagName     = (INT8U *)"?";                       /* Unknown name                    */
10003494:	b0001000 	imm	4096
10003498:	30c08af4 	addik	r6, r0, -29964
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
1000349c:	10600000 	addk	r3, r0, r0
*
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
100034a0:	10a71800 	addk	r5, r7, r3
    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        pgrp1->OSFlagWaitList = (void *)pgrp2;
100034a4:	b0001000 	imm	4096
100034a8:	f8a3ce28 	swi	r5, r3, -12760

    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
100034ac:	b0001000 	imm	4096
100034b0:	f003ce24 	sbi	r0, r3, -12764
        pgrp1->OSFlagWaitList = (void *)pgrp2;
#if OS_FLAG_NAME_EN > 0u
        pgrp1->OSFlagName     = (INT8U *)"?";                       /* Unknown name                    */
100034b4:	b0001000 	imm	4096
100034b8:	f8c3ce30 	swi	r6, r3, -12752
100034bc:	30630010 	addik	r3, r3, 16


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
100034c0:	a8a30040 	xori	r5, r3, 64
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
100034c4:	b0001000 	imm	4096
100034c8:	3080ce24 	addik	r4, r0, -12764	// 1000ce24 <OSFlagTbl>


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0u; i < (OS_MAX_FLAGS - 1u); i++) {                    /* Init. list of free EVENT FLAGS  */
100034cc:	be25ffd4 	bneid	r5, -44		// 100034a0
100034d0:	e9e10000 	lwi	r15, r1, 0
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    pgrp1->OSFlagWaitList = (void *)0;
#if OS_FLAG_NAME_EN > 0u
    pgrp1->OSFlagName     = (INT8U *)"?";                           /* Unknown name                    */
100034d4:	b0001000 	imm	4096
100034d8:	30608af4 	addik	r3, r0, -29964
        pgrp1->OSFlagName     = (INT8U *)"?";                       /* Unknown name                    */
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
100034dc:	f0a40040 	sbi	r5, r4, 64
    pgrp1->OSFlagWaitList = (void *)0;
100034e0:	f8a40044 	swi	r5, r4, 68
#if OS_FLAG_NAME_EN > 0u
    pgrp1->OSFlagName     = (INT8U *)"?";                           /* Unknown name                    */
100034e4:	f864004c 	swi	r3, r4, 76
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
100034e8:	b0001000 	imm	4096
100034ec:	f880e09c 	swi	r4, r0, -8036	// 1000e09c <OSFlagFreeList>
#endif
}
100034f0:	b60f0008 	rtsd	r15, 8
100034f4:	3021001c 	addik	r1, r1, 28

100034f8 <OS_FlagUnlink>:
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
100034f8:	e8850004 	lwi	r4, r5, 4
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
100034fc:	be240014 	bneid	r4, 20		// 10003510
10003500:	e8650000 	lwi	r3, r5, 0
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
10003504:	e8c5000c 	lwi	r6, r5, 12
10003508:	b810000c 	brid	12		// 10003514
1000350c:	f8660004 	swi	r3, r6, 4
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
10003510:	f8640000 	swi	r3, r4, 0
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
10003514:	bc030008 	beqi	r3, 8		// 1000351c
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
10003518:	f8830004 	swi	r4, r3, 4
        }
    }
#if OS_TASK_DEL_EN > 0u
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
1000351c:	e8650008 	lwi	r3, r5, 8
#endif
}
10003520:	b60f0008 	rtsd	r15, 8
10003524:	f8030028 	swi	r0, r3, 40

10003528 <OS_FlagTaskRdy>:
{
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
10003528:	e8850008 	lwi	r4, r5, 8
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, 
                                 OS_FLAGS      flags_rdy)
{
1000352c:	3021ffe0 	addik	r1, r1, -32
10003530:	fa61001c 	swi	r19, r1, 28
10003534:	f9e10000 	swi	r15, r1, 0


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
    ptcb->OSTCBDly       = 0;
    ptcb->OSTCBFlagsRdy  = flags_rdy;
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
10003538:	e0640034 	lbui	r3, r4, 52
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
    ptcb->OSTCBDly       = 0;
1000353c:	f8040030 	swi	r0, r4, 48
    ptcb->OSTCBFlagsRdy  = flags_rdy;
10003540:	f4c4002c 	shi	r6, r4, 44
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
10003544:	a46300df 	andi	r3, r3, 223
10003548:	f0640034 	sbi	r3, r4, 52
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
1000354c:	f0040035 	sbi	r0, r4, 53
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
10003550:	be230040 	bneid	r3, 64		// 10003590
10003554:	12600000 	addk	r19, r0, r0
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
10003558:	e0c4003a 	lbui	r6, r4, 58
1000355c:	b0001000 	imm	4096
10003560:	e060d3f8 	lbui	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        sched                   = OS_TRUE;
10003564:	32600001 	addik	r19, r0, 1
    ptcb->OSTCBDly       = 0;
    ptcb->OSTCBFlagsRdy  = flags_rdy;
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
10003568:	80661800 	or	r3, r6, r3
1000356c:	b0001000 	imm	4096
10003570:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10003574:	e0640038 	lbui	r3, r4, 56
10003578:	e0840039 	lbui	r4, r4, 57
1000357c:	b0001000 	imm	4096
10003580:	e0c3d3fc 	lbui	r6, r3, -11268
10003584:	80862000 	or	r4, r6, r4
10003588:	b0001000 	imm	4096
1000358c:	f083d3fc 	sbi	r4, r3, -11268
        sched                   = OS_TRUE;
    } else {
        sched                   = OS_FALSE;
    }
    OS_FlagUnlink(pnode);
10003590:	b9f4ff68 	brlid	r15, -152	// 100034f8 <OS_FlagUnlink>
10003594:	80000000 	or	r0, r0, r0
    return (sched);
}
10003598:	10730000 	addk	r3, r19, r0
1000359c:	e9e10000 	lwi	r15, r1, 0
100035a0:	ea61001c 	lwi	r19, r1, 28
100035a4:	b60f0008 	rtsd	r15, 8
100035a8:	30210020 	addik	r1, r1, 32

100035ac <OSFlagPost>:
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp, 
                      OS_FLAGS      flags, 
                      INT8U         opt, 
                      INT8U        *perr)
{
100035ac:	3021ffcc 	addik	r1, r1, -52
100035b0:	fa61001c 	swi	r19, r1, 28
100035b4:	fae10024 	swi	r23, r1, 36
100035b8:	fb010028 	swi	r24, r1, 40
100035bc:	fb410030 	swi	r26, r1, 48
100035c0:	f9e10000 	swi	r15, r1, 0
100035c4:	fac10020 	swi	r22, r1, 32
100035c8:	fb21002c 	swi	r25, r1, 44
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
100035cc:	e2c50000 	lbui	r22, r5, 0
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp, 
                      OS_FLAGS      flags, 
                      INT8U         opt, 
                      INT8U        *perr)
{
100035d0:	12650000 	addk	r19, r5, r0
100035d4:	12e60000 	addk	r23, r6, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
100035d8:	aad60005 	xori	r22, r22, 5
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp, 
                      OS_FLAGS      flags, 
                      INT8U         opt, 
                      INT8U        *perr)
{
100035dc:	13470000 	addk	r26, r7, r0
100035e0:	13080000 	addk	r24, r8, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
100035e4:	be3600f8 	bneid	r22, 248		// 100036dc
100035e8:	30600001 	addik	r3, r0, 1
        *perr = OS_ERR_EVENT_TYPE;
        return ((OS_FLAGS)0);
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
100035ec:	b9f44940 	brlid	r15, 18752	// 10007f2c <OS_CPU_SR_Save>
100035f0:	80000000 	or	r0, r0, r0
    switch (opt) {
100035f4:	be1a0018 	beqid	r26, 24		// 1000360c
100035f8:	13230000 	addk	r25, r3, r0
100035fc:	ab5a0001 	xori	r26, r26, 1
10003600:	be1a001c 	beqid	r26, 28		// 1000361c
10003604:	10a30000 	addk	r5, r3, r0
10003608:	b8000030 	bri	48		// 10003638
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
1000360c:	e4730008 	lhui	r3, r19, 8
10003610:	aaf7ffff 	xori	r23, r23, -1
10003614:	b8100010 	brid	16		// 10003624
10003618:	86f71800 	and	r23, r23, r3
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
1000361c:	e4730008 	lhui	r3, r19, 8
10003620:	82f71800 	or	r23, r23, r3
10003624:	f6f30008 	shi	r23, r19, 8
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
10003628:	ead30004 	lwi	r22, r19, 4
        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
1000362c:	12e00000 	addk	r23, r0, r0
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
10003630:	b81000bc 	brid	188		// 100036ec
10003634:	33400001 	addik	r26, r0, 1
        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
10003638:	b9f44924 	brlid	r15, 18724	// 10007f5c <OS_CPU_SR_Restore>
1000363c:	12760000 	addk	r19, r22, r0
             *perr = OS_ERR_FLAG_INVALID_OPT;
10003640:	30600071 	addik	r3, r0, 113
             return ((OS_FLAGS)0);
10003644:	b81000dc 	brid	220		// 10003720
10003648:	f0780000 	sbi	r3, r24, 0
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
1000364c:	e0960012 	lbui	r4, r22, 18
10003650:	a8640001 	xori	r3, r4, 1
10003654:	be030050 	beqid	r3, 80		// 100036a4
10003658:	147a2003 	cmpu	r3, r26, r4
1000365c:	be43002c 	bltid	r3, 44		// 10003688
10003660:	a8640002 	xori	r3, r4, 2
10003664:	be030010 	beqid	r3, 16		// 10003674
10003668:	a8840003 	xori	r4, r4, 3
1000366c:	bc040014 	beqi	r4, 20		// 10003680
10003670:	b8000060 	bri	96		// 100036d0
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
10003674:	e4760010 	lhui	r3, r22, 16
10003678:	b810001c 	brid	28		// 10003694
1000367c:	e4d30008 	lhui	r6, r19, 8
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
10003680:	b810002c 	brid	44		// 100036ac
10003684:	e4d30008 	lhui	r6, r19, 8
                 }
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0u
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
10003688:	e4d30008 	lhui	r6, r19, 8
1000368c:	e4760010 	lhui	r3, r22, 16
10003690:	a8c6ffff 	xori	r6, r6, -1
10003694:	84c61800 	and	r6, r6, r3
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
10003698:	88661800 	xor	r3, r6, r3
1000369c:	bc23004c 	bnei	r3, 76		// 100036e8
100036a0:	b8000018 	bri	24		// 100036b8
                     }
                 }
                 break;

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
100036a4:	e4d30008 	lhui	r6, r19, 8
100036a8:	a8c6ffff 	xori	r6, r6, -1
100036ac:	e4760010 	lhui	r3, r22, 16
100036b0:	84c61800 	and	r6, r6, r3
                 if (flags_rdy != (OS_FLAGS)0) {
100036b4:	bc060034 	beqi	r6, 52		// 100036e8
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
100036b8:	b9f4fe70 	brlid	r15, -400	// 10003528 <OS_FlagTaskRdy>
100036bc:	10b60000 	addk	r5, r22, r0
                     if (rdy == OS_TRUE) {
100036c0:	a8630001 	xori	r3, r3, 1
100036c4:	bc230024 	bnei	r3, 36		// 100036e8
                         sched = OS_TRUE;                     /* When done we will reschedule          */
100036c8:	b8100020 	brid	32		// 100036e8
100036cc:	32e00001 	addik	r23, r0, 1
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
100036d0:	b9f4488c 	brlid	r15, 18572	// 10007f5c <OS_CPU_SR_Restore>
100036d4:	10b90000 	addk	r5, r25, r0
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
100036d8:	3060006f 	addik	r3, r0, 111
100036dc:	f0780000 	sbi	r3, r24, 0
                 return ((OS_FLAGS)0);
100036e0:	b8100040 	brid	64		// 10003720
100036e4:	12600000 	addk	r19, r0, r0
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
100036e8:	ead60000 	lwi	r22, r22, 0
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
100036ec:	be36ff60 	bneid	r22, -160		// 1000364c
100036f0:	10b90000 	addk	r5, r25, r0
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
100036f4:	b9f44868 	brlid	r15, 18536	// 10007f5c <OS_CPU_SR_Restore>
100036f8:	aaf70001 	xori	r23, r23, 1
    if (sched == OS_TRUE) {
100036fc:	bc37000c 	bnei	r23, 12		// 10003708
        OS_Sched();
10003700:	b9f4f0c0 	brlid	r15, -3904	// 100027c0 <OS_Sched>
10003704:	80000000 	or	r0, r0, r0
    }
    OS_ENTER_CRITICAL();
10003708:	b9f44824 	brlid	r15, 18468	// 10007f2c <OS_CPU_SR_Save>
1000370c:	80000000 	or	r0, r0, r0
    flags_cur = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
10003710:	10a30000 	addk	r5, r3, r0
10003714:	b9f44848 	brlid	r15, 18504	// 10007f5c <OS_CPU_SR_Restore>
10003718:	e6730008 	lhui	r19, r19, 8
    *perr     = OS_ERR_NONE;
1000371c:	f0180000 	sbi	r0, r24, 0
    return (flags_cur);
}
10003720:	10730000 	addk	r3, r19, r0
10003724:	e9e10000 	lwi	r15, r1, 0
10003728:	ea61001c 	lwi	r19, r1, 28
1000372c:	eac10020 	lwi	r22, r1, 32
10003730:	eae10024 	lwi	r23, r1, 36
10003734:	eb010028 	lwi	r24, r1, 40
10003738:	eb21002c 	lwi	r25, r1, 44
1000373c:	eb410030 	lwi	r26, r1, 48
10003740:	b60f0008 	rtsd	r15, 8
10003744:	30210034 	addik	r1, r1, 52

10003748 <OSFlagDel>:
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return (pgrp);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10003748:	b0001000 	imm	4096
1000374c:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_FLAG_DEL_EN > 0u
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                         INT8U         opt, 
                         INT8U        *perr)
{
10003750:	3021ffc8 	addik	r1, r1, -56
10003754:	fa61001c 	swi	r19, r1, 28
10003758:	fae10024 	swi	r23, r1, 36
1000375c:	fb610034 	swi	r27, r1, 52
10003760:	f9e10000 	swi	r15, r1, 0
10003764:	fac10020 	swi	r22, r1, 32
10003768:	fb010028 	swi	r24, r1, 40
1000376c:	fb21002c 	swi	r25, r1, 44
10003770:	fb410030 	swi	r26, r1, 48
10003774:	12650000 	addk	r19, r5, r0
10003778:	13660000 	addk	r27, r6, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return (pgrp);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
1000377c:	be030010 	beqid	r3, 16		// 1000378c
10003780:	12e70000 	addk	r23, r7, r0
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
10003784:	b81000fc 	brid	252		// 10003880
10003788:	3060000f 	addik	r3, r0, 15
        return (pgrp);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
1000378c:	e3450000 	lbui	r26, r5, 0
10003790:	ab5a0005 	xori	r26, r26, 5
10003794:	be3a00ec 	bneid	r26, 236		// 10003880
10003798:	30600001 	addik	r3, r0, 1
        *perr = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
1000379c:	b9f44790 	brlid	r15, 18320	// 10007f2c <OS_CPU_SR_Save>
100037a0:	80000000 	or	r0, r0, r0
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
100037a4:	ead30004 	lwi	r22, r19, 4
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
        *perr = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
100037a8:	13030000 	addk	r24, r3, r0
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
100037ac:	8f56d400 	pcmpne	r26, r22, r26
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
100037b0:	be1b0014 	beqid	r27, 20		// 100037c4
100037b4:	133a0000 	addk	r25, r26, r0
100037b8:	ab7b0001 	xori	r27, r27, 1
100037bc:	bc1b0064 	beqi	r27, 100		// 10003820
100037c0:	b80000b4 	bri	180		// 10003874
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
100037c4:	bc3a0040 	bnei	r26, 64		// 10003804
#if OS_FLAG_NAME_EN > 0u
                 pgrp->OSFlagName     = (INT8U *)"?";
100037c8:	b0001000 	imm	4096
100037cc:	30608af4 	addik	r3, r0, -29964
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
100037d0:	f3530000 	sbi	r26, r19, 0
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
                 OSFlagFreeList       = pgrp;
                 OS_EXIT_CRITICAL();
100037d4:	10b80000 	addk	r5, r24, r0
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
#if OS_FLAG_NAME_EN > 0u
                 pgrp->OSFlagName     = (INT8U *)"?";
100037d8:	f873000c 	swi	r3, r19, 12
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
100037dc:	b0001000 	imm	4096
100037e0:	e860e09c 	lwi	r3, r0, -8036	// 1000e09c <OSFlagFreeList>
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
100037e4:	f7530008 	shi	r26, r19, 8
                 OSFlagFreeList       = pgrp;
100037e8:	b0001000 	imm	4096
100037ec:	fa60e09c 	swi	r19, r0, -8036	// 1000e09c <OSFlagFreeList>
                 OS_EXIT_CRITICAL();
100037f0:	b9f4476c 	brlid	r15, 18284	// 10007f5c <OS_CPU_SR_Restore>
100037f4:	f8730004 	swi	r3, r19, 4
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
100037f8:	127a0000 	addk	r19, r26, r0
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
                 OSFlagFreeList       = pgrp;
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
100037fc:	b8100088 	brid	136		// 10003884
10003800:	f3570000 	sbi	r26, r23, 0
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
10003804:	b9f44758 	brlid	r15, 18264	// 10007f5c <OS_CPU_SR_Restore>
10003808:	10a30000 	addk	r5, r3, r0
                 *perr                = OS_ERR_TASK_WAITING;
1000380c:	b8100074 	brid	116		// 10003880
10003810:	30600049 	addik	r3, r0, 73
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
10003814:	b9f4fd14 	brlid	r15, -748	// 10003528 <OS_FlagTaskRdy>
10003818:	10c00000 	addk	r6, r0, r0
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
1000381c:	ead60000 	lwi	r22, r22, 0
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
10003820:	be36fff4 	bneid	r22, -12		// 10003814
10003824:	10b60000 	addk	r5, r22, r0
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_EN > 0u
             pgrp->OSFlagName     = (INT8U *)"?";
10003828:	b0001000 	imm	4096
1000382c:	30608af4 	addik	r3, r0, -29964
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
10003830:	f2d30000 	sbi	r22, r19, 0
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
             OS_EXIT_CRITICAL();
10003834:	10b80000 	addk	r5, r24, r0
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_EN > 0u
             pgrp->OSFlagName     = (INT8U *)"?";
10003838:	f873000c 	swi	r3, r19, 12
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
1000383c:	b0001000 	imm	4096
10003840:	e860e09c 	lwi	r3, r0, -8036	// 1000e09c <OSFlagFreeList>
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
10003844:	f6d30008 	shi	r22, r19, 8
             }
#if OS_FLAG_NAME_EN > 0u
             pgrp->OSFlagName     = (INT8U *)"?";
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
10003848:	f8730004 	swi	r3, r19, 4
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
1000384c:	b0001000 	imm	4096
10003850:	fa60e09c 	swi	r19, r0, -8036	// 1000e09c <OSFlagFreeList>
             OS_EXIT_CRITICAL();
10003854:	b9f44708 	brlid	r15, 18184	// 10007f5c <OS_CPU_SR_Restore>
10003858:	ab390001 	xori	r25, r25, 1
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
1000385c:	bc39000c 	bnei	r25, 12		// 10003868
                 OS_Sched();                               /* Find highest priority task ready to run  */
10003860:	b9f4ef60 	brlid	r15, -4256	// 100027c0 <OS_Sched>
10003864:	80000000 	or	r0, r0, r0
             }
             *perr = OS_ERR_NONE;
10003868:	f0170000 	sbi	r0, r23, 0
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
             break;
1000386c:	b8100018 	brid	24		// 10003884
10003870:	12600000 	addk	r19, r0, r0

        default:
             OS_EXIT_CRITICAL();
10003874:	b9f446e8 	brlid	r15, 18152	// 10007f5c <OS_CPU_SR_Restore>
10003878:	10a30000 	addk	r5, r3, r0
             *perr                = OS_ERR_INVALID_OPT;
1000387c:	30600007 	addik	r3, r0, 7
10003880:	f0770000 	sbi	r3, r23, 0
             pgrp_return          = pgrp;
             break;
    }
    return (pgrp_return);
}
10003884:	10730000 	addk	r3, r19, r0
10003888:	e9e10000 	lwi	r15, r1, 0
1000388c:	ea61001c 	lwi	r19, r1, 28
10003890:	eac10020 	lwi	r22, r1, 32
10003894:	eae10024 	lwi	r23, r1, 36
10003898:	eb010028 	lwi	r24, r1, 40
1000389c:	eb21002c 	lwi	r25, r1, 44
100038a0:	eb410030 	lwi	r26, r1, 48
100038a4:	eb610034 	lwi	r27, r1, 52
100038a8:	b60f0008 	rtsd	r15, 8
100038ac:	30210038 	addik	r1, r1, 56

100038b0 <OSFlagPend>:
OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp, 
                      OS_FLAGS      flags, 
                      INT8U         wait_type, 
                      INT32U        timeout, 
                      INT8U        *perr)
{
100038b0:	3021ffb0 	addik	r1, r1, -80
100038b4:	fa610030 	swi	r19, r1, 48
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100038b8:	b0001000 	imm	4096
100038bc:	e260d608 	lbui	r19, r0, -10744	// 1000d608 <OSIntNesting>
OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp, 
                      OS_FLAGS      flags, 
                      INT8U         wait_type, 
                      INT32U        timeout, 
                      INT8U        *perr)
{
100038c0:	fac10034 	swi	r22, r1, 52
100038c4:	fae10038 	swi	r23, r1, 56
100038c8:	fb01003c 	swi	r24, r1, 60
100038cc:	fb410044 	swi	r26, r1, 68
100038d0:	fb81004c 	swi	r28, r1, 76
100038d4:	f9e10000 	swi	r15, r1, 0
100038d8:	fb210040 	swi	r25, r1, 64
100038dc:	fb610048 	swi	r27, r1, 72
100038e0:	12c50000 	addk	r22, r5, r0
100038e4:	13060000 	addk	r24, r6, r0
100038e8:	13470000 	addk	r26, r7, r0
100038ec:	13880000 	addk	r28, r8, r0
100038f0:	12e90000 	addk	r23, r9, r0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *perr = OS_ERR_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100038f4:	be3301c4 	bneid	r19, 452		// 10003ab8
100038f8:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
        return ((OS_FLAGS)0);
    }
    if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
100038fc:	b0001000 	imm	4096
10003900:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
10003904:	be2301ac 	bneid	r3, 428		// 10003ab0
10003908:	3080000d 	addik	r4, r0, 13
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
        return ((OS_FLAGS)0);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
1000390c:	e0850000 	lbui	r4, r5, 0
10003910:	a8840005 	xori	r4, r4, 5
10003914:	be040014 	beqid	r4, 20		// 10003928
10003918:	30800001 	addik	r4, r0, 1
        *perr = OS_ERR_EVENT_TYPE;
1000391c:	f0890000 	sbi	r4, r9, 0
        return ((OS_FLAGS)0);
10003920:	b810020c 	brid	524		// 10003b2c
10003924:	12630000 	addk	r19, r3, r0
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
10003928:	a7670080 	andi	r27, r7, 128
1000392c:	a77b00ff 	andi	r27, r27, 255
10003930:	bc1b000c 	beqi	r27, 12		// 1000393c
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
10003934:	a747007f 	andi	r26, r7, 127
        consume    = OS_TRUE;
10003938:	33600001 	addik	r27, r0, 1
    } else {
        consume    = OS_FALSE;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
1000393c:	b9f445f0 	brlid	r15, 17904	// 10007f2c <OS_CPU_SR_Save>
10003940:	80000000 	or	r0, r0, r0
10003944:	13230000 	addk	r25, r3, r0
    switch (wait_type) {
10003948:	a87a0001 	xori	r3, r26, 1
1000394c:	be0300a4 	beqid	r3, 164		// 100039f0
10003950:	30600001 	addik	r3, r0, 1
10003954:	1463d003 	cmpu	r3, r3, r26
10003958:	be430070 	bltid	r3, 112		// 100039c8
1000395c:	a87a0002 	xori	r3, r26, 2
10003960:	be030010 	beqid	r3, 16		// 10003970
10003964:	a87a0003 	xori	r3, r26, 3
10003968:	bc03002c 	beqi	r3, 44		// 10003994
1000396c:	b8000108 	bri	264		// 10003a74
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
10003970:	e4760008 	lhui	r3, r22, 8
10003974:	86781800 	and	r19, r24, r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
10003978:	8893c000 	xor	r4, r19, r24
1000397c:	bc040028 	beqi	r4, 40		// 100039a4
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
10003980:	10b60000 	addk	r5, r22, r0
10003984:	30c1001c 	addik	r6, r1, 28
10003988:	10f80000 	addk	r7, r24, r0
1000398c:	b81000a8 	brid	168		// 10003a34
10003990:	31000002 	addik	r8, r0, 2	// 2 <CPU_IE_BIT>
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
10003994:	e4760008 	lhui	r3, r22, 8
10003998:	86781800 	and	r19, r24, r3
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
1000399c:	be13001c 	beqid	r19, 28		// 100039b8
100039a0:	10b60000 	addk	r5, r22, r0
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
100039a4:	ab7b0001 	xori	r27, r27, 1
100039a8:	be3b006c 	bneid	r27, 108		// 10003a14
100039ac:	a893ffff 	xori	r4, r19, -1
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
100039b0:	b8100060 	brid	96		// 10003a10
100039b4:	84641800 	and	r3, r4, r3
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
100039b8:	30c1001c 	addik	r6, r1, 28
100039bc:	10f80000 	addk	r7, r24, r0
100039c0:	b8100074 	brid	116		// 10003a34
100039c4:	31000003 	addik	r8, r0, 3
             }
             break;

#if OS_FLAG_WAIT_CLR_EN > 0u
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
100039c8:	e4760008 	lhui	r3, r22, 8
100039cc:	aa63ffff 	xori	r19, r3, -1
100039d0:	86789800 	and	r19, r24, r19
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
100039d4:	8893c000 	xor	r4, r19, r24
100039d8:	bc04002c 	beqi	r4, 44		// 10003a04
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
100039dc:	10b60000 	addk	r5, r22, r0
100039e0:	30c1001c 	addik	r6, r1, 28
100039e4:	10f80000 	addk	r7, r24, r0
100039e8:	b810004c 	brid	76		// 10003a34
100039ec:	11000000 	addk	r8, r0, r0
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
100039f0:	e4760008 	lhui	r3, r22, 8
100039f4:	aa63ffff 	xori	r19, r3, -1
100039f8:	86789800 	and	r19, r24, r19
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
100039fc:	be13002c 	beqid	r19, 44		// 10003a28
10003a00:	10b60000 	addk	r5, r22, r0
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
10003a04:	ab7b0001 	xori	r27, r27, 1
10003a08:	be3b000c 	bneid	r27, 12		// 10003a14
10003a0c:	80731800 	or	r3, r19, r3
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
10003a10:	f4760008 	shi	r3, r22, 8
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
10003a14:	b0001000 	imm	4096
10003a18:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
10003a1c:	10b90000 	addk	r5, r25, r0
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
10003a20:	b8100100 	brid	256		// 10003b20
10003a24:	f663002c 	shi	r19, r3, 44
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
10003a28:	10f80000 	addk	r7, r24, r0
10003a2c:	30c1001c 	addik	r6, r1, 28
10003a30:	31000001 	addik	r8, r0, 1
10003a34:	b9f4f5bc 	brlid	r15, -2628	// 10002ff0 <OS_FlagBlock>
10003a38:	113c0000 	addk	r9, r28, r0
                 OS_EXIT_CRITICAL();
10003a3c:	b9f44520 	brlid	r15, 17696	// 10007f5c <OS_CPU_SR_Restore>
10003a40:	10b90000 	addk	r5, r25, r0
             flags_rdy = (OS_FLAGS)0;
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
             return (flags_rdy);
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
10003a44:	b9f4ed7c 	brlid	r15, -4740	// 100027c0 <OS_Sched>
10003a48:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
10003a4c:	b9f444e0 	brlid	r15, 17632	// 10007f2c <OS_CPU_SR_Save>
10003a50:	80000000 	or	r0, r0, r0
10003a54:	13030000 	addk	r24, r3, r0
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
10003a58:	b0001000 	imm	4096
10003a5c:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10003a60:	e2630035 	lbui	r19, r3, 53
10003a64:	be130060 	beqid	r19, 96		// 10003ac4
10003a68:	ab7b0001 	xori	r27, r27, 1
        pend_stat                = OSTCBCur->OSTCBStatPend;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
10003a6c:	b8100018 	brid	24		// 10003a84
10003a70:	f0030035 	sbi	r0, r3, 53
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
10003a74:	b9f444e8 	brlid	r15, 17640	// 10007f5c <OS_CPU_SR_Restore>
10003a78:	10b90000 	addk	r5, r25, r0
             flags_rdy = (OS_FLAGS)0;
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
10003a7c:	b810003c 	brid	60		// 10003ab8
10003a80:	3060006f 	addik	r3, r0, 111
    OS_Sched();                                            /* Find next HPT ready to run               */
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
        pend_stat                = OSTCBCur->OSTCBStatPend;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        OS_FlagUnlink(&node);
10003a84:	b9f4fa74 	brlid	r15, -1420	// 100034f8 <OS_FlagUnlink>
10003a88:	30a1001c 	addik	r5, r1, 28
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
10003a8c:	b0001000 	imm	4096
10003a90:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
        OS_EXIT_CRITICAL();
10003a94:	10b80000 	addk	r5, r24, r0
        flags_rdy                = (OS_FLAGS)0;
        switch (pend_stat) {
10003a98:	aa730002 	xori	r19, r19, 2
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
        pend_stat                = OSTCBCur->OSTCBStatPend;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        OS_FlagUnlink(&node);
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
        OS_EXIT_CRITICAL();
10003a9c:	b9f444c0 	brlid	r15, 17600	// 10007f5c <OS_CPU_SR_Restore>
10003aa0:	f0030034 	sbi	r0, r3, 52
        flags_rdy                = (OS_FLAGS)0;
        switch (pend_stat) {
10003aa4:	be330014 	bneid	r19, 20		// 10003ab8
10003aa8:	3060000a 	addik	r3, r0, 10
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
10003aac:	3080000e 	addik	r4, r0, 14
                 break;
10003ab0:	b810007c 	brid	124		// 10003b2c
10003ab4:	f0970000 	sbi	r4, r23, 0

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
10003ab8:	f0770000 	sbi	r3, r23, 0
                 break;
10003abc:	b8100070 	brid	112		// 10003b2c
10003ac0:	12600000 	addk	r19, r0, r0
        }
        return (flags_rdy);
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
10003ac4:	be3b0058 	bneid	r27, 88		// 10003b1c
10003ac8:	e663002c 	lhui	r19, r3, 44
        switch (wait_type) {
10003acc:	30600001 	addik	r3, r0, 1
10003ad0:	147a1803 	cmpu	r3, r26, r3
10003ad4:	bea30020 	bgeid	r3, 32		// 10003af4
10003ad8:	30600003 	addik	r3, r0, 3
10003adc:	175a1803 	cmpu	r26, r26, r3
10003ae0:	be5a0024 	bltid	r26, 36		// 10003b04
10003ae4:	a873ffff 	xori	r3, r19, -1
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
10003ae8:	e4960008 	lhui	r4, r22, 8
10003aec:	b8100010 	brid	16		// 10003afc
10003af0:	84632000 	and	r3, r3, r4
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0u
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
10003af4:	e4760008 	lhui	r3, r22, 8
10003af8:	80731800 	or	r3, r19, r3
                 break;
10003afc:	b8100020 	brid	32		// 10003b1c
10003b00:	f4760008 	shi	r3, r22, 8
#endif
            default:
                 OS_EXIT_CRITICAL();
10003b04:	10b80000 	addk	r5, r24, r0
10003b08:	b9f44454 	brlid	r15, 17492	// 10007f5c <OS_CPU_SR_Restore>
10003b0c:	127b0000 	addk	r19, r27, r0
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
10003b10:	3080006f 	addik	r4, r0, 111
                 return ((OS_FLAGS)0);
10003b14:	b8100018 	brid	24		// 10003b2c
10003b18:	f0970000 	sbi	r4, r23, 0
        }
    }
    OS_EXIT_CRITICAL();
10003b1c:	10b80000 	addk	r5, r24, r0
10003b20:	b9f4443c 	brlid	r15, 17468	// 10007f5c <OS_CPU_SR_Restore>
10003b24:	80000000 	or	r0, r0, r0
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
10003b28:	f0170000 	sbi	r0, r23, 0
    return (flags_rdy);
}
10003b2c:	10730000 	addk	r3, r19, r0
10003b30:	e9e10000 	lwi	r15, r1, 0
10003b34:	ea610030 	lwi	r19, r1, 48
10003b38:	eac10034 	lwi	r22, r1, 52
10003b3c:	eae10038 	lwi	r23, r1, 56
10003b40:	eb01003c 	lwi	r24, r1, 60
10003b44:	eb210040 	lwi	r25, r1, 64
10003b48:	eb410044 	lwi	r26, r1, 68
10003b4c:	eb610048 	lwi	r27, r1, 72
10003b50:	eb81004c 	lwi	r28, r1, 76
10003b54:	b60f0008 	rtsd	r15, 8
10003b58:	30210050 	addik	r1, r1, 80

10003b5c <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0u
void  *OSMboxAccept (OS_EVENT *pevent)
{
10003b5c:	3021ffd8 	addik	r1, r1, -40
10003b60:	fa61001c 	swi	r19, r1, 28
10003b64:	fac10020 	swi	r22, r1, 32
10003b68:	f9e10000 	swi	r15, r1, 0
10003b6c:	fae10024 	swi	r23, r1, 36
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
10003b70:	e2e50000 	lbui	r23, r5, 0
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0u
void  *OSMboxAccept (OS_EVENT *pevent)
{
10003b74:	12650000 	addk	r19, r5, r0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
10003b78:	aaf70001 	xori	r23, r23, 1
10003b7c:	be370020 	bneid	r23, 32		// 10003b9c
10003b80:	12c00000 	addk	r22, r0, r0
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
10003b84:	b9f443a8 	brlid	r15, 17320	// 10007f2c <OS_CPU_SR_Save>
10003b88:	80000000 	or	r0, r0, r0
    pmsg               = pevent->OSEventPtr;
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    OS_EXIT_CRITICAL();
10003b8c:	10a30000 	addk	r5, r3, r0
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pmsg               = pevent->OSEventPtr;
10003b90:	ead30004 	lwi	r22, r19, 4
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    OS_EXIT_CRITICAL();
10003b94:	b9f443c8 	brlid	r15, 17352	// 10007f5c <OS_CPU_SR_Restore>
10003b98:	faf30004 	swi	r23, r19, 4
    return (pmsg);                                        /* Return the message received (or NULL)     */
}
10003b9c:	10760000 	addk	r3, r22, r0
10003ba0:	e9e10000 	lwi	r15, r1, 0
10003ba4:	ea61001c 	lwi	r19, r1, 28
10003ba8:	eac10020 	lwi	r22, r1, 32
10003bac:	eae10024 	lwi	r23, r1, 36
10003bb0:	b60f0008 	rtsd	r15, 8
10003bb4:	30210028 	addik	r1, r1, 40

10003bb8 <OSMboxCreate>:
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif
                                                           
    if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
10003bb8:	b0001000 	imm	4096
10003bbc:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *pmsg)
{
10003bc0:	3021ffdc 	addik	r1, r1, -36
10003bc4:	fa61001c 	swi	r19, r1, 28
10003bc8:	fac10020 	swi	r22, r1, 32
10003bcc:	f9e10000 	swi	r15, r1, 0
10003bd0:	12c50000 	addk	r22, r5, r0
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif
                                                           
    if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
10003bd4:	be230058 	bneid	r3, 88		// 10003c2c
10003bd8:	12600000 	addk	r19, r0, r0
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
10003bdc:	b9f44350 	brlid	r15, 17232	// 10007f2c <OS_CPU_SR_Save>
10003be0:	80000000 	or	r0, r0, r0
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
10003be4:	b0001000 	imm	4096
10003be8:	ea60d604 	lwi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
10003bec:	bc130010 	beqi	r19, 16		// 10003bfc
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
10003bf0:	e8930004 	lwi	r4, r19, 4
10003bf4:	b0001000 	imm	4096
10003bf8:	f880d604 	swi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
    }
    OS_EXIT_CRITICAL();
10003bfc:	b9f44360 	brlid	r15, 17248	// 10007f5c <OS_CPU_SR_Restore>
10003c00:	10a30000 	addk	r5, r3, r0
    if (pevent != (OS_EVENT *)0) {
10003c04:	be130028 	beqid	r19, 40		// 10003c2c
10003c08:	30600001 	addik	r3, r0, 1
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
10003c0c:	f0730000 	sbi	r3, r19, 0
        pevent->OSEventCnt     = 0u;
        pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
#if OS_EVENT_NAME_EN > 0u
        pevent->OSEventName    = (INT8U *)"?";
10003c10:	b0001000 	imm	4096
10003c14:	30608af8 	addik	r3, r0, -29960
#endif
        OS_EventWaitListInit(pevent);
10003c18:	10b30000 	addk	r5, r19, r0
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
        pevent->OSEventCnt     = 0u;
10003c1c:	f4130008 	shi	r0, r19, 8
        pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
10003c20:	fad30004 	swi	r22, r19, 4
#if OS_EVENT_NAME_EN > 0u
        pevent->OSEventName    = (INT8U *)"?";
#endif
        OS_EventWaitListInit(pevent);
10003c24:	b9f4e8b4 	brlid	r15, -5964	// 100024d8 <OS_EventWaitListInit>
10003c28:	f8730014 	swi	r3, r19, 20
    }
    return (pevent);                             /* Return pointer to event control block              */
}
10003c2c:	10730000 	addk	r3, r19, r0
10003c30:	e9e10000 	lwi	r15, r1, 0
10003c34:	ea61001c 	lwi	r19, r1, 28
10003c38:	eac10020 	lwi	r22, r1, 32
10003c3c:	b60f0008 	rtsd	r15, 8
10003c40:	30210024 	addik	r1, r1, 36

10003c44 <OSMboxDel>:

#if OS_MBOX_DEL_EN > 0u
OS_EVENT  *OSMboxDel (OS_EVENT  *pevent, 
                      INT8U      opt, 
                      INT8U     *perr)
{
10003c44:	3021ffcc 	addik	r1, r1, -52
10003c48:	fa61001c 	swi	r19, r1, 28
10003c4c:	fac10020 	swi	r22, r1, 32
10003c50:	fb410030 	swi	r26, r1, 48
10003c54:	f9e10000 	swi	r15, r1, 0
10003c58:	fae10024 	swi	r23, r1, 36
10003c5c:	fb010028 	swi	r24, r1, 40
10003c60:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
10003c64:	e0650000 	lbui	r3, r5, 0

#if OS_MBOX_DEL_EN > 0u
OS_EVENT  *OSMboxDel (OS_EVENT  *pevent, 
                      INT8U      opt, 
                      INT8U     *perr)
{
10003c68:	12650000 	addk	r19, r5, r0
10003c6c:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
10003c70:	a8630001 	xori	r3, r3, 1
10003c74:	be030010 	beqid	r3, 16		// 10003c84
10003c78:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10003c7c:	b8100104 	brid	260		// 10003d80
10003c80:	30600001 	addik	r3, r0, 1
        return (pevent);
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10003c84:	b0001000 	imm	4096
10003c88:	e300d608 	lbui	r24, r0, -10744	// 1000d608 <OSIntNesting>
10003c8c:	be3800f4 	bneid	r24, 244		// 10003d80
10003c90:	3060000f 	addik	r3, r0, 15
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10003c94:	b9f44298 	brlid	r15, 17048	// 10007f2c <OS_CPU_SR_Save>
10003c98:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10003c9c:	e333000a 	lbui	r25, r19, 10
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10003ca0:	12e30000 	addk	r23, r3, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10003ca4:	8f39c400 	pcmpne	r25, r25, r24
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
10003ca8:	be1a0014 	beqid	r26, 20		// 10003cbc
10003cac:	13190000 	addk	r24, r25, r0
10003cb0:	ab5a0001 	xori	r26, r26, 1
10003cb4:	bc1a0068 	beqi	r26, 104		// 10003d1c
10003cb8:	b80000bc 	bri	188		// 10003d74
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
10003cbc:	bc390040 	bnei	r25, 64		// 10003cfc
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName = (INT8U *)"?";
10003cc0:	b0001000 	imm	4096
10003cc4:	30608af8 	addik	r3, r0, -29960
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
10003cc8:	f3330000 	sbi	r25, r19, 0
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
                 pevent->OSEventCnt  = 0u;
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
10003ccc:	10b70000 	addk	r5, r23, r0
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName = (INT8U *)"?";
10003cd0:	f8730014 	swi	r3, r19, 20
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
10003cd4:	b0001000 	imm	4096
10003cd8:	e860d604 	lwi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
                 pevent->OSEventCnt  = 0u;
10003cdc:	f7330008 	shi	r25, r19, 8
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
10003ce0:	b0001000 	imm	4096
10003ce4:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
                 OS_EXIT_CRITICAL();
10003ce8:	b9f44274 	brlid	r15, 17012	// 10007f5c <OS_CPU_SR_Restore>
10003cec:	f8730004 	swi	r3, r19, 4
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
10003cf0:	12790000 	addk	r19, r25, r0
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
                 pevent->OSEventCnt  = 0u;
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
10003cf4:	b8100090 	brid	144		// 10003d84
10003cf8:	f3360000 	sbi	r25, r22, 0
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
             } else {
                 OS_EXIT_CRITICAL();
10003cfc:	b9f44260 	brlid	r15, 16992	// 10007f5c <OS_CPU_SR_Restore>
10003d00:	10a30000 	addk	r5, r3, r0
                 *perr               = OS_ERR_TASK_WAITING;
10003d04:	b810007c 	brid	124		// 10003d80
10003d08:	30600049 	addik	r3, r0, 73
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
10003d0c:	10b30000 	addk	r5, r19, r0
10003d10:	11060000 	addk	r8, r6, r0
10003d14:	b9f4e6e4 	brlid	r15, -6428	// 100023f8 <OS_EventTaskRdy>
10003d18:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
10003d1c:	e073000a 	lbui	r3, r19, 10
10003d20:	be23ffec 	bneid	r3, -20		// 10003d0c
10003d24:	10c00000 	addk	r6, r0, r0
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
10003d28:	b0001000 	imm	4096
10003d2c:	30808af8 	addik	r4, r0, -29960
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
10003d30:	f0730000 	sbi	r3, r19, 0
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
10003d34:	10b70000 	addk	r5, r23, r0
        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
10003d38:	f8930014 	swi	r4, r19, 20
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
10003d3c:	b0001000 	imm	4096
10003d40:	e880d604 	lwi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
             pevent->OSEventCnt     = 0u;
10003d44:	f4730008 	shi	r3, r19, 8
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
10003d48:	f8930004 	swi	r4, r19, 4
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
10003d4c:	b0001000 	imm	4096
10003d50:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
             OS_EXIT_CRITICAL();
10003d54:	b9f44208 	brlid	r15, 16904	// 10007f5c <OS_CPU_SR_Restore>
10003d58:	ab180001 	xori	r24, r24, 1
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
10003d5c:	bc38000c 	bnei	r24, 12		// 10003d68
                 OS_Sched();                               /* Find highest priority task ready to run  */
10003d60:	b9f4ea60 	brlid	r15, -5536	// 100027c0 <OS_Sched>
10003d64:	80000000 	or	r0, r0, r0
             }
             *perr         = OS_ERR_NONE;
10003d68:	f0160000 	sbi	r0, r22, 0
             pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
             break;
10003d6c:	b8100018 	brid	24		// 10003d84
10003d70:	12600000 	addk	r19, r0, r0

        default:
             OS_EXIT_CRITICAL();
10003d74:	b9f441e8 	brlid	r15, 16872	// 10007f5c <OS_CPU_SR_Restore>
10003d78:	10a30000 	addk	r5, r3, r0
             *perr         = OS_ERR_INVALID_OPT;
10003d7c:	30600007 	addik	r3, r0, 7
10003d80:	f0760000 	sbi	r3, r22, 0
             pevent_return = pevent;
             break;
    }
    return (pevent_return);
}
10003d84:	10730000 	addk	r3, r19, r0
10003d88:	e9e10000 	lwi	r15, r1, 0
10003d8c:	ea61001c 	lwi	r19, r1, 28
10003d90:	eac10020 	lwi	r22, r1, 32
10003d94:	eae10024 	lwi	r23, r1, 36
10003d98:	eb010028 	lwi	r24, r1, 40
10003d9c:	eb21002c 	lwi	r25, r1, 44
10003da0:	eb410030 	lwi	r26, r1, 48
10003da4:	b60f0008 	rtsd	r15, 8
10003da8:	30210034 	addik	r1, r1, 52

10003dac <OSMboxPend>:
*/
/*$PAGE*/
void  *OSMboxPend (OS_EVENT  *pevent, 
                   INT32U     timeout, 
                   INT8U     *perr)
{
10003dac:	3021ffcc 	addik	r1, r1, -52
10003db0:	fac10020 	swi	r22, r1, 32
10003db4:	fae10024 	swi	r23, r1, 36
10003db8:	fb410030 	swi	r26, r1, 48
10003dbc:	f9e10000 	swi	r15, r1, 0
10003dc0:	fa61001c 	swi	r19, r1, 28
10003dc4:	fb010028 	swi	r24, r1, 40
10003dc8:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
10003dcc:	e2650000 	lbui	r19, r5, 0
*/
/*$PAGE*/
void  *OSMboxPend (OS_EVENT  *pevent, 
                   INT32U     timeout, 
                   INT8U     *perr)
{
10003dd0:	12e50000 	addk	r23, r5, r0
10003dd4:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
10003dd8:	aa730001 	xori	r19, r19, 1
10003ddc:	be130018 	beqid	r19, 24		// 10003df4
10003de0:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10003de4:	30600001 	addik	r3, r0, 1
10003de8:	f0670000 	sbi	r3, r7, 0
        return ((void *)0);
10003dec:	b8100110 	brid	272		// 10003efc
10003df0:	12600000 	addk	r19, r0, r0
    }
    if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
10003df4:	b0001000 	imm	4096
10003df8:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10003dfc:	be030010 	beqid	r3, 16		// 10003e0c
10003e00:	30800002 	addik	r4, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
        return ((void *)0);
10003e04:	b81000f8 	brid	248		// 10003efc
10003e08:	f0870000 	sbi	r4, r7, 0
    }
    if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
10003e0c:	b0001000 	imm	4096
10003e10:	e300ce10 	lbui	r24, r0, -12784	// 1000ce10 <OSLockNesting>
10003e14:	be180014 	beqid	r24, 20		// 10003e28
10003e18:	3080000d 	addik	r4, r0, 13
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
10003e1c:	f0870000 	sbi	r4, r7, 0
        return ((void *)0);
10003e20:	b81000dc 	brid	220		// 10003efc
10003e24:	12630000 	addk	r19, r3, r0
    }
    OS_ENTER_CRITICAL();
10003e28:	b9f44104 	brlid	r15, 16644	// 10007f2c <OS_CPU_SR_Save>
10003e2c:	80000000 	or	r0, r0, r0
    pmsg = pevent->OSEventPtr;
10003e30:	ea770004 	lwi	r19, r23, 4
    if (pmsg != (void *)0) {                          /* See if there is already a message             */
10003e34:	be13001c 	beqid	r19, 28		// 10003e50
10003e38:	13230000 	addk	r25, r3, r0
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
        OS_EXIT_CRITICAL();
10003e3c:	10a30000 	addk	r5, r3, r0
10003e40:	b9f4411c 	brlid	r15, 16668	// 10007f5c <OS_CPU_SR_Restore>
10003e44:	fb170004 	swi	r24, r23, 4
        *perr = OS_ERR_NONE;
        return (pmsg);                                /* Return the message received (or NULL)         */
10003e48:	b81000b4 	brid	180		// 10003efc
10003e4c:	f3160000 	sbi	r24, r22, 0
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
10003e50:	b0001000 	imm	4096
10003e54:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10003e58:	10b70000 	addk	r5, r23, r0
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return (pmsg);                                /* Return the message received (or NULL)         */
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
10003e5c:	e0640034 	lbui	r3, r4, 52
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
10003e60:	f2640035 	sbi	r19, r4, 53
    OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
10003e64:	fb440030 	swi	r26, r4, 48
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return (pmsg);                                /* Return the message received (or NULL)         */
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
10003e68:	a0630002 	ori	r3, r3, 2
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10003e6c:	b9f4e3f8 	brlid	r15, -7176	// 10002264 <OS_EventTaskWait>
10003e70:	f0640034 	sbi	r3, r4, 52
    OS_EXIT_CRITICAL();
10003e74:	b9f440e8 	brlid	r15, 16616	// 10007f5c <OS_CPU_SR_Restore>
10003e78:	10b90000 	addk	r5, r25, r0
    OS_Sched();                                       /* Find next highest priority task ready to run  */
10003e7c:	b9f4e944 	brlid	r15, -5820	// 100027c0 <OS_Sched>
10003e80:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
10003e84:	b9f440a8 	brlid	r15, 16552	// 10007f2c <OS_CPU_SR_Save>
10003e88:	80000000 	or	r0, r0, r0
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
10003e8c:	b0001000 	imm	4096
10003e90:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
10003e94:	e0c40035 	lbui	r6, r4, 53
10003e98:	be06001c 	beqid	r6, 28		// 10003eb4
10003e9c:	13030000 	addk	r24, r3, r0
10003ea0:	a8c60002 	xori	r6, r6, 2
10003ea4:	be06001c 	beqid	r6, 28		// 10003ec0
10003ea8:	3060000e 	addik	r3, r0, 14
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
10003eac:	b810001c 	brid	28		// 10003ec8
10003eb0:	10a40000 	addk	r5, r4, r0
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        case OS_STAT_PEND_OK:
             pmsg =  OSTCBCur->OSTCBMsg;
10003eb4:	ea640024 	lwi	r19, r4, 36
            *perr =  OS_ERR_NONE;
             break;
10003eb8:	b8100020 	brid	32		// 10003ed8
10003ebc:	f0d60000 	sbi	r6, r22, 0

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;
10003ec0:	b8100018 	brid	24		// 10003ed8
10003ec4:	f0760000 	sbi	r3, r22, 0

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
10003ec8:	b9f4e4a4 	brlid	r15, -7004	// 1000236c <OS_EventTaskRemove>
10003ecc:	10d70000 	addk	r6, r23, r0
             pmsg = (void *)0;
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
10003ed0:	3080000a 	addik	r4, r0, 10
10003ed4:	f0960000 	sbi	r4, r22, 0
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10003ed8:	b0001000 	imm	4096
10003edc:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    OS_EXIT_CRITICAL();
10003ee0:	10b80000 	addk	r5, r24, r0
             OS_EventTaskRemove(OSTCBCur, pevent);
             pmsg = (void *)0;
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10003ee4:	f0040034 	sbi	r0, r4, 52
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
10003ee8:	f0040035 	sbi	r0, r4, 53
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
10003eec:	f804001c 	swi	r0, r4, 28
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
10003ef0:	f8040020 	swi	r0, r4, 32
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    OS_EXIT_CRITICAL();
10003ef4:	b9f44068 	brlid	r15, 16488	// 10007f5c <OS_CPU_SR_Restore>
10003ef8:	f8040024 	swi	r0, r4, 36
    return (pmsg);                                    /* Return received message                       */
}
10003efc:	10730000 	addk	r3, r19, r0
10003f00:	e9e10000 	lwi	r15, r1, 0
10003f04:	ea61001c 	lwi	r19, r1, 28
10003f08:	eac10020 	lwi	r22, r1, 32
10003f0c:	eae10024 	lwi	r23, r1, 36
10003f10:	eb010028 	lwi	r24, r1, 40
10003f14:	eb21002c 	lwi	r25, r1, 44
10003f18:	eb410030 	lwi	r26, r1, 48
10003f1c:	b60f0008 	rtsd	r15, 8
10003f20:	30210034 	addik	r1, r1, 52

10003f24 <OSMboxPendAbort>:

#if OS_MBOX_PEND_ABORT_EN > 0u
INT8U  OSMboxPendAbort (OS_EVENT  *pevent, 
                        INT8U      opt, 
                        INT8U     *perr)
{
10003f24:	3021ffcc 	addik	r1, r1, -52
10003f28:	fac10020 	swi	r22, r1, 32
10003f2c:	fae10024 	swi	r23, r1, 36
10003f30:	fb410030 	swi	r26, r1, 48
10003f34:	f9e10000 	swi	r15, r1, 0
10003f38:	fa61001c 	swi	r19, r1, 28
10003f3c:	fb010028 	swi	r24, r1, 40
10003f40:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
10003f44:	e3250000 	lbui	r25, r5, 0

#if OS_MBOX_PEND_ABORT_EN > 0u
INT8U  OSMboxPendAbort (OS_EVENT  *pevent, 
                        INT8U      opt, 
                        INT8U     *perr)
{
10003f48:	12c50000 	addk	r22, r5, r0
10003f4c:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
10003f50:	ab390001 	xori	r25, r25, 1
10003f54:	be190018 	beqid	r25, 24		// 10003f6c
10003f58:	12e70000 	addk	r23, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10003f5c:	30600001 	addik	r3, r0, 1
10003f60:	f0670000 	sbi	r3, r7, 0
        return (0u);
10003f64:	b8100090 	brid	144		// 10003ff4
10003f68:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
10003f6c:	b9f43fc0 	brlid	r15, 16320	// 10007f2c <OS_CPU_SR_Save>
10003f70:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
10003f74:	e276000a 	lbui	r19, r22, 10
10003f78:	be130070 	beqid	r19, 112		// 10003fe8
10003f7c:	13030000 	addk	r24, r3, r0
        nbr_tasks = 0u;
        switch (opt) {
10003f80:	aa7a0001 	xori	r19, r26, 1
10003f84:	be130028 	beqid	r19, 40		// 10003fac
10003f88:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
                 }
                 break;
             
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on mailbox  */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
10003f8c:	b8100030 	brid	48		// 10003fbc
10003f90:	10b60000 	addk	r5, r22, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
10003f94:	10b60000 	addk	r5, r22, r0
10003f98:	11070000 	addk	r8, r7, r0
10003f9c:	10c00000 	addk	r6, r0, r0
10003fa0:	b9f4e458 	brlid	r15, -7080	// 100023f8 <OS_EventTaskRdy>
10003fa4:	32730001 	addik	r19, r19, 1
                     nbr_tasks++;
10003fa8:	a67300ff 	andi	r19, r19, 255
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
10003fac:	e076000a 	lbui	r3, r22, 10
10003fb0:	be23ffe4 	bneid	r3, -28		// 10003f94
10003fb4:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
10003fb8:	b8000014 	bri	20		// 10003fcc
                 }
                 break;
             
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on mailbox  */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
10003fbc:	10d90000 	addk	r6, r25, r0
10003fc0:	11070000 	addk	r8, r7, r0
10003fc4:	b9f4e434 	brlid	r15, -7116	// 100023f8 <OS_EventTaskRdy>
10003fc8:	32600001 	addik	r19, r0, 1
                 nbr_tasks++;
                 break;
        }
        OS_EXIT_CRITICAL();
10003fcc:	b9f43f90 	brlid	r15, 16272	// 10007f5c <OS_CPU_SR_Restore>
10003fd0:	10b80000 	addk	r5, r24, r0
        OS_Sched();                                        /* Find HPT ready to run                    */
10003fd4:	b9f4e7ec 	brlid	r15, -6164	// 100027c0 <OS_Sched>
10003fd8:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_PEND_ABORT;
10003fdc:	3060000e 	addik	r3, r0, 14
        return (nbr_tasks);
10003fe0:	b8100014 	brid	20		// 10003ff4
10003fe4:	f0770000 	sbi	r3, r23, 0
    }
    OS_EXIT_CRITICAL();
10003fe8:	b9f43f74 	brlid	r15, 16244	// 10007f5c <OS_CPU_SR_Restore>
10003fec:	10a30000 	addk	r5, r3, r0
    *perr = OS_ERR_NONE;
10003ff0:	f2770000 	sbi	r19, r23, 0
    return (0u);                                           /* No tasks waiting on mailbox              */
}
10003ff4:	10730000 	addk	r3, r19, r0
10003ff8:	e9e10000 	lwi	r15, r1, 0
10003ffc:	ea61001c 	lwi	r19, r1, 28
10004000:	eac10020 	lwi	r22, r1, 32
10004004:	eae10024 	lwi	r23, r1, 36
10004008:	eb010028 	lwi	r24, r1, 40
1000400c:	eb21002c 	lwi	r25, r1, 44
10004010:	eb410030 	lwi	r26, r1, 48
10004014:	b60f0008 	rtsd	r15, 8
10004018:	30210034 	addik	r1, r1, 52

1000401c <OSMboxPost>:
*/

#if OS_MBOX_POST_EN > 0u
INT8U  OSMboxPost (OS_EVENT  *pevent, 
                   void      *pmsg)
{
1000401c:	3021ffd4 	addik	r1, r1, -44
10004020:	fa610020 	swi	r19, r1, 32
10004024:	f9e10000 	swi	r15, r1, 0
10004028:	fac10024 	swi	r22, r1, 36
1000402c:	fae10028 	swi	r23, r1, 40
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
10004030:	e2e50000 	lbui	r23, r5, 0
*/

#if OS_MBOX_POST_EN > 0u
INT8U  OSMboxPost (OS_EVENT  *pevent, 
                   void      *pmsg)
{
10004034:	12650000 	addk	r19, r5, r0
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
10004038:	aaf70001 	xori	r23, r23, 1
1000403c:	be370070 	bneid	r23, 112		// 100040ac
10004040:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10004044:	b9f43ee8 	brlid	r15, 16104	// 10007f2c <OS_CPU_SR_Save>
10004048:	f8c1001c 	swi	r6, r1, 28
1000404c:	12c30000 	addk	r22, r3, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
10004050:	e073000a 	lbui	r3, r19, 10
10004054:	be030030 	beqid	r3, 48		// 10004084
10004058:	e8c1001c 	lwi	r6, r1, 28
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
1000405c:	10b30000 	addk	r5, r19, r0
10004060:	11170000 	addk	r8, r23, r0
10004064:	b9f4e394 	brlid	r15, -7276	// 100023f8 <OS_EventTaskRdy>
10004068:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
        OS_EXIT_CRITICAL();
1000406c:	b9f43ef0 	brlid	r15, 16112	// 10007f5c <OS_CPU_SR_Restore>
10004070:	10b60000 	addk	r5, r22, r0
        OS_Sched();                                   /* Find highest priority task ready to run       */
10004074:	b9f4e74c 	brlid	r15, -6324	// 100027c0 <OS_Sched>
10004078:	80000000 	or	r0, r0, r0
        OS_EXIT_CRITICAL();
        return (OS_ERR_MBOX_FULL);
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
1000407c:	b8100030 	brid	48		// 100040ac
10004080:	10770000 	addk	r3, r23, r0
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
        return (OS_ERR_NONE);
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
10004084:	eaf30004 	lwi	r23, r19, 4
10004088:	be170018 	beqid	r23, 24		// 100040a0
1000408c:	10b60000 	addk	r5, r22, r0
        OS_EXIT_CRITICAL();
10004090:	b9f43ecc 	brlid	r15, 16076	// 10007f5c <OS_CPU_SR_Restore>
10004094:	10b60000 	addk	r5, r22, r0
        return (OS_ERR_MBOX_FULL);
10004098:	b8100014 	brid	20		// 100040ac
1000409c:	30600014 	addik	r3, r0, 20	// 14 <STK_OFFSET_R06>
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
100040a0:	b9f43ebc 	brlid	r15, 16060	// 10007f5c <OS_CPU_SR_Restore>
100040a4:	f8d30004 	swi	r6, r19, 4
    return (OS_ERR_NONE);
100040a8:	10770000 	addk	r3, r23, r0
}
100040ac:	e9e10000 	lwi	r15, r1, 0
100040b0:	ea610020 	lwi	r19, r1, 32
100040b4:	eac10024 	lwi	r22, r1, 36
100040b8:	eae10028 	lwi	r23, r1, 40
100040bc:	b60f0008 	rtsd	r15, 8
100040c0:	3021002c 	addik	r1, r1, 44

100040c4 <OSMboxPostOpt>:

#if OS_MBOX_POST_OPT_EN > 0u
INT8U  OSMboxPostOpt (OS_EVENT  *pevent, 
                      void      *pmsg, 
                      INT8U      opt)
{
100040c4:	3021ffd0 	addik	r1, r1, -48
100040c8:	fa61001c 	swi	r19, r1, 28
100040cc:	fac10020 	swi	r22, r1, 32
100040d0:	fb010028 	swi	r24, r1, 40
100040d4:	fb21002c 	swi	r25, r1, 44
100040d8:	f9e10000 	swi	r15, r1, 0
100040dc:	fae10024 	swi	r23, r1, 36
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
100040e0:	e0650000 	lbui	r3, r5, 0

#if OS_MBOX_POST_OPT_EN > 0u
INT8U  OSMboxPostOpt (OS_EVENT  *pevent, 
                      void      *pmsg, 
                      INT8U      opt)
{
100040e4:	12650000 	addk	r19, r5, r0
100040e8:	13060000 	addk	r24, r6, r0
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
100040ec:	a8630001 	xori	r3, r3, 1

#if OS_MBOX_POST_OPT_EN > 0u
INT8U  OSMboxPostOpt (OS_EVENT  *pevent, 
                      void      *pmsg, 
                      INT8U      opt)
{
100040f0:	13270000 	addk	r25, r7, r0
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
100040f4:	be2300a4 	bneid	r3, 164		// 10004198
100040f8:	32c00001 	addik	r22, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
100040fc:	b9f43e30 	brlid	r15, 15920	// 10007f2c <OS_CPU_SR_Save>
10004100:	80000000 	or	r0, r0, r0
10004104:	12e30000 	addk	r23, r3, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
10004108:	e073000a 	lbui	r3, r19, 10
1000410c:	be030068 	beqid	r3, 104		// 10004174
10004110:	8519b000 	and	r8, r25, r22
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
10004114:	be280024 	bneid	r8, 36		// 10004138
10004118:	10b30000 	addk	r5, r19, r0
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
1000411c:	b810002c 	brid	44		// 10004148
10004120:	10d80000 	addk	r6, r24, r0
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
10004124:	10b30000 	addk	r5, r19, r0
10004128:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
1000412c:	b9f4e2cc 	brlid	r15, -7476	// 100023f8 <OS_EventTaskRdy>
10004130:	11000000 	addk	r8, r0, r0
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
10004134:	e073000a 	lbui	r3, r19, 10
10004138:	be23ffec 	bneid	r3, -20		// 10004124
1000413c:	10d80000 	addk	r6, r24, r0
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
        }
        OS_EXIT_CRITICAL();
10004140:	b8100014 	brid	20		// 10004154
10004144:	10b70000 	addk	r5, r23, r0
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
10004148:	b9f4e2b0 	brlid	r15, -7504	// 100023f8 <OS_EventTaskRdy>
1000414c:	30e00002 	addik	r7, r0, 2	// 2 <CPU_IE_BIT>
        }
        OS_EXIT_CRITICAL();
10004150:	10b70000 	addk	r5, r23, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
10004154:	a7390004 	andi	r25, r25, 4
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
        }
        OS_EXIT_CRITICAL();
10004158:	b9f43e04 	brlid	r15, 15876	// 10007f5c <OS_CPU_SR_Restore>
1000415c:	12c00000 	addk	r22, r0, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
10004160:	bc390038 	bnei	r25, 56		// 10004198
            OS_Sched();                               /* Find HPT ready to run                         */
10004164:	b9f4e65c 	brlid	r15, -6564	// 100027c0 <OS_Sched>
10004168:	80000000 	or	r0, r0, r0
        return (OS_ERR_MBOX_FULL);
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
1000416c:	b8100030 	brid	48		// 1000419c
10004170:	10760000 	addk	r3, r22, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
            OS_Sched();                               /* Find HPT ready to run                         */
        }
        return (OS_ERR_NONE);
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
10004174:	ead30004 	lwi	r22, r19, 4
10004178:	be160018 	beqid	r22, 24		// 10004190
1000417c:	10b70000 	addk	r5, r23, r0
        OS_EXIT_CRITICAL();
10004180:	b9f43ddc 	brlid	r15, 15836	// 10007f5c <OS_CPU_SR_Restore>
10004184:	32c00014 	addik	r22, r0, 20	// 14 <STK_OFFSET_R06>
        return (OS_ERR_MBOX_FULL);
10004188:	b8100014 	brid	20		// 1000419c
1000418c:	10760000 	addk	r3, r22, r0
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    OS_EXIT_CRITICAL();
10004190:	b9f43dcc 	brlid	r15, 15820	// 10007f5c <OS_CPU_SR_Restore>
10004194:	fb130004 	swi	r24, r19, 4
    return (OS_ERR_NONE);
}
10004198:	10760000 	addk	r3, r22, r0
1000419c:	e9e10000 	lwi	r15, r1, 0
100041a0:	ea61001c 	lwi	r19, r1, 28
100041a4:	eac10020 	lwi	r22, r1, 32
100041a8:	eae10024 	lwi	r23, r1, 36
100041ac:	eb010028 	lwi	r24, r1, 40
100041b0:	eb21002c 	lwi	r25, r1, 44
100041b4:	b60f0008 	rtsd	r15, 8
100041b8:	30210030 	addik	r1, r1, 48

100041bc <OSMboxQuery>:
*/

#if OS_MBOX_QUERY_EN > 0u
INT8U  OSMboxQuery (OS_EVENT      *pevent, 
                    OS_MBOX_DATA  *p_mbox_data)
{
100041bc:	3021ffd8 	addik	r1, r1, -40
100041c0:	fa61001c 	swi	r19, r1, 28
100041c4:	fac10020 	swi	r22, r1, 32
100041c8:	f9e10000 	swi	r15, r1, 0
100041cc:	fae10024 	swi	r23, r1, 36
    }
    if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
100041d0:	e2e50000 	lbui	r23, r5, 0
*/

#if OS_MBOX_QUERY_EN > 0u
INT8U  OSMboxQuery (OS_EVENT      *pevent, 
                    OS_MBOX_DATA  *p_mbox_data)
{
100041d4:	12650000 	addk	r19, r5, r0
100041d8:	12c60000 	addk	r22, r6, r0
    }
    if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
100041dc:	aaf70001 	xori	r23, r23, 1
100041e0:	be37004c 	bneid	r23, 76		// 1000422c
100041e4:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
100041e8:	b9f43d44 	brlid	r15, 15684	// 10007f2c <OS_CPU_SR_Save>
100041ec:	80000000 	or	r0, r0, r0
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
100041f0:	e093000a 	lbui	r4, r19, 10
    psrc                    = &pevent->OSEventTbl[0];
100041f4:	30d3000b 	addik	r6, r19, 11
    pdest                   = &p_mbox_data->OSEventTbl[0];
100041f8:	30b60004 	addik	r5, r22, 4
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
100041fc:	f096000c 	sbi	r4, r22, 12
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
10004200:	10970000 	addk	r4, r23, r0
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
10004204:	c0e43000 	lbu	r7, r4, r6
10004208:	d0e42800 	sb	r7, r4, r5
1000420c:	30840001 	addik	r4, r4, 1
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
10004210:	aae40008 	xori	r23, r4, 8
10004214:	bc37fff0 	bnei	r23, -16		// 10004204
        *pdest++ = *psrc++;
    }
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
10004218:	e8930004 	lwi	r4, r19, 4
    OS_EXIT_CRITICAL();
1000421c:	10a30000 	addk	r5, r3, r0
10004220:	b9f43d3c 	brlid	r15, 15676	// 10007f5c <OS_CPU_SR_Restore>
10004224:	f8960000 	swi	r4, r22, 0
    return (OS_ERR_NONE);
10004228:	10770000 	addk	r3, r23, r0
}
1000422c:	e9e10000 	lwi	r15, r1, 0
10004230:	ea61001c 	lwi	r19, r1, 28
10004234:	eac10020 	lwi	r22, r1, 32
10004238:	eae10024 	lwi	r23, r1, 36
1000423c:	b60f0008 	rtsd	r15, 8
10004240:	30210028 	addik	r1, r1, 40

10004244 <OSMemCreate>:

OS_MEM  *OSMemCreate (void   *addr,
                      INT32U  nblks,
                      INT32U  blksize,
                      INT8U  *perr)
{
10004244:	3021ffd0 	addik	r1, r1, -48
10004248:	fa61001c 	swi	r19, r1, 28
1000424c:	fac10020 	swi	r22, r1, 32
10004250:	fae10024 	swi	r23, r1, 36
10004254:	fb010028 	swi	r24, r1, 40
10004258:	fb21002c 	swi	r25, r1, 44
1000425c:	f9e10000 	swi	r15, r1, 0
10004260:	12c50000 	addk	r22, r5, r0
10004264:	13060000 	addk	r24, r6, r0
10004268:	12e70000 	addk	r23, r7, r0
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
        *perr = OS_ERR_MEM_INVALID_SIZE;
        return ((OS_MEM *)0);
    }
#endif
    OS_ENTER_CRITICAL();
1000426c:	b9f43cc0 	brlid	r15, 15552	// 10007f2c <OS_CPU_SR_Save>
10004270:	13280000 	addk	r25, r8, r0
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
10004274:	b0001000 	imm	4096
10004278:	ea60d38c 	lwi	r19, r0, -11380	// 1000d38c <OSMemFreeList>
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
1000427c:	bc130010 	beqi	r19, 16		// 1000428c
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
10004280:	e8930004 	lwi	r4, r19, 4
10004284:	b0001000 	imm	4096
10004288:	f880d38c 	swi	r4, r0, -11380	// 1000d38c <OSMemFreeList>
    }
    OS_EXIT_CRITICAL();
1000428c:	b9f43cd0 	brlid	r15, 15568	// 10007f5c <OS_CPU_SR_Restore>
10004290:	10a30000 	addk	r5, r3, r0
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
10004294:	be330014 	bneid	r19, 20		// 100042a8
10004298:	1076b800 	addk	r3, r22, r23
        *perr = OS_ERR_MEM_INVALID_PART;
1000429c:	3060005a 	addik	r3, r0, 90
        return ((OS_MEM *)0);
100042a0:	b810004c 	brid	76		// 100042ec
100042a4:	f0790000 	sbi	r3, r25, 0
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
100042a8:	10960000 	addk	r4, r22, r0
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0u; i < (nblks - 1u); i++) {
100042ac:	10a00000 	addk	r5, r0, r0
100042b0:	b8100018 	brid	24		// 100042c8
100042b4:	30d8ffff 	addik	r6, r24, -1
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
100042b8:	f8640000 	swi	r3, r4, 0
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0u; i < (nblks - 1u); i++) {
100042bc:	30a50001 	addik	r5, r5, 1
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
100042c0:	10830000 	addk	r4, r3, r0
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
100042c4:	1063b800 	addk	r3, r3, r23
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0u; i < (nblks - 1u); i++) {
100042c8:	14e62803 	cmpu	r7, r6, r5
100042cc:	bc47ffec 	blti	r7, -20		// 100042b8
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
100042d0:	f8040000 	swi	r0, r4, 0
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
100042d4:	fad30000 	swi	r22, r19, 0
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
100042d8:	fad30004 	swi	r22, r19, 4
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
100042dc:	fb130010 	swi	r24, r19, 16
    pmem->OSMemNBlks    = nblks;
100042e0:	fb13000c 	swi	r24, r19, 12
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
100042e4:	faf30008 	swi	r23, r19, 8
    *perr               = OS_ERR_NONE;
100042e8:	f0190000 	sbi	r0, r25, 0
    return (pmem);
}
100042ec:	10730000 	addk	r3, r19, r0
100042f0:	e9e10000 	lwi	r15, r1, 0
100042f4:	ea61001c 	lwi	r19, r1, 28
100042f8:	eac10020 	lwi	r22, r1, 32
100042fc:	eae10024 	lwi	r23, r1, 36
10004300:	eb010028 	lwi	r24, r1, 40
10004304:	eb21002c 	lwi	r25, r1, 44
10004308:	b60f0008 	rtsd	r15, 8
1000430c:	30210030 	addik	r1, r1, 48

10004310 <OSMemGet>:
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM  *pmem,
                 INT8U   *perr)
{
10004310:	3021ffd4 	addik	r1, r1, -44
10004314:	fac10020 	swi	r22, r1, 32
10004318:	12c50000 	addk	r22, r5, r0
1000431c:	fae10024 	swi	r23, r1, 36
10004320:	fb010028 	swi	r24, r1, 40
10004324:	f9e10000 	swi	r15, r1, 0
10004328:	fa61001c 	swi	r19, r1, 28
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
        *perr = OS_ERR_MEM_INVALID_PMEM;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
1000432c:	b9f43c00 	brlid	r15, 15360	// 10007f2c <OS_CPU_SR_Save>
10004330:	13060000 	addk	r24, r6, r0
    if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
10004334:	eaf60010 	lwi	r23, r22, 16
10004338:	be170028 	beqid	r23, 40		// 10004360
1000433c:	10a30000 	addk	r5, r3, r0
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
10004340:	ea760004 	lwi	r19, r22, 4
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
10004344:	32f7ffff 	addik	r23, r23, -1
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
10004348:	e8730000 	lwi	r3, r19, 0
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
1000434c:	faf60010 	swi	r23, r22, 16
        OS_EXIT_CRITICAL();
10004350:	b9f43c0c 	brlid	r15, 15372	// 10007f5c <OS_CPU_SR_Restore>
10004354:	f8760004 	swi	r3, r22, 4
        *perr = OS_ERR_NONE;                          /*      No error                                 */
        return (pblk);                                /*      Return memory block to caller            */
10004358:	b8100018 	brid	24		// 10004370
1000435c:	f0180000 	sbi	r0, r24, 0
    }
    OS_EXIT_CRITICAL();
10004360:	b9f43bfc 	brlid	r15, 15356	// 10007f5c <OS_CPU_SR_Restore>
10004364:	12770000 	addk	r19, r23, r0
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
10004368:	3060005d 	addik	r3, r0, 93
1000436c:	f0780000 	sbi	r3, r24, 0
    return ((void *)0);                               /*      Return NULL pointer to caller            */
}
10004370:	10730000 	addk	r3, r19, r0
10004374:	e9e10000 	lwi	r15, r1, 0
10004378:	ea61001c 	lwi	r19, r1, 28
1000437c:	eac10020 	lwi	r22, r1, 32
10004380:	eae10024 	lwi	r23, r1, 36
10004384:	eb010028 	lwi	r24, r1, 40
10004388:	b60f0008 	rtsd	r15, 8
1000438c:	3021002c 	addik	r1, r1, 44

10004390 <OSMemNameGet>:

#if OS_MEM_NAME_EN > 0u
INT8U  OSMemNameGet (OS_MEM   *pmem,
                     INT8U   **pname,
                     INT8U    *perr)
{
10004390:	3021ffd0 	addik	r1, r1, -48
10004394:	fae10024 	swi	r23, r1, 36
    if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10004398:	b0001000 	imm	4096
1000439c:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_MEM_NAME_EN > 0u
INT8U  OSMemNameGet (OS_MEM   *pmem,
                     INT8U   **pname,
                     INT8U    *perr)
{
100043a0:	fa61001c 	swi	r19, r1, 28
100043a4:	fac10020 	swi	r22, r1, 32
100043a8:	fb21002c 	swi	r25, r1, 44
100043ac:	f9e10000 	swi	r15, r1, 0
100043b0:	fb010028 	swi	r24, r1, 40
100043b4:	13250000 	addk	r25, r5, r0
100043b8:	12660000 	addk	r19, r6, r0
    if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
100043bc:	be170018 	beqid	r23, 24		// 100043d4
100043c0:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_NAME_GET_ISR;
100043c4:	30600011 	addik	r3, r0, 17
100043c8:	f0670000 	sbi	r3, r7, 0
        return (0u);
100043cc:	b8100034 	brid	52		// 10004400
100043d0:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
100043d4:	b9f43b58 	brlid	r15, 15192	// 10007f2c <OS_CPU_SR_Save>
100043d8:	80000000 	or	r0, r0, r0
    *pname = pmem->OSMemName;
100043dc:	e8990014 	lwi	r4, r25, 20
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
        *perr = OS_ERR_NAME_GET_ISR;
        return (0u);
    }
    OS_ENTER_CRITICAL();
100043e0:	13030000 	addk	r24, r3, r0
    *pname = pmem->OSMemName;
    len    = OS_StrLen(*pname);
100043e4:	10a40000 	addk	r5, r4, r0
100043e8:	b9f4e83c 	brlid	r15, -6084	// 10002c24 <OS_StrLen>
100043ec:	f8930000 	swi	r4, r19, 0
    OS_EXIT_CRITICAL();
100043f0:	10b80000 	addk	r5, r24, r0
100043f4:	b9f43b68 	brlid	r15, 15208	// 10007f5c <OS_CPU_SR_Restore>
100043f8:	12630000 	addk	r19, r3, r0
    *perr  = OS_ERR_NONE;
100043fc:	f2f60000 	sbi	r23, r22, 0
    return (len);
}
10004400:	10730000 	addk	r3, r19, r0
10004404:	e9e10000 	lwi	r15, r1, 0
10004408:	ea61001c 	lwi	r19, r1, 28
1000440c:	eac10020 	lwi	r22, r1, 32
10004410:	eae10024 	lwi	r23, r1, 36
10004414:	eb010028 	lwi	r24, r1, 40
10004418:	eb21002c 	lwi	r25, r1, 44
1000441c:	b60f0008 	rtsd	r15, 8
10004420:	30210030 	addik	r1, r1, 48

10004424 <OSMemNameSet>:

#if OS_MEM_NAME_EN > 0u
void  OSMemNameSet (OS_MEM  *pmem,
                    INT8U   *pname,
                    INT8U   *perr)
{
10004424:	3021ffd4 	addik	r1, r1, -44
10004428:	fac10020 	swi	r22, r1, 32
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
1000442c:	b0001000 	imm	4096
10004430:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_MEM_NAME_EN > 0u
void  OSMemNameSet (OS_MEM  *pmem,
                    INT8U   *pname,
                    INT8U   *perr)
{
10004434:	fa61001c 	swi	r19, r1, 28
10004438:	fae10024 	swi	r23, r1, 36
1000443c:	fb010028 	swi	r24, r1, 40
10004440:	f9e10000 	swi	r15, r1, 0
10004444:	12e50000 	addk	r23, r5, r0
10004448:	13060000 	addk	r24, r6, r0
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
        *perr = OS_ERR_PNAME_NULL;
        return;
    }
#endif
    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
1000444c:	be160014 	beqid	r22, 20		// 10004460
10004450:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_NAME_SET_ISR;
10004454:	30600012 	addik	r3, r0, 18
        return;
10004458:	b8100020 	brid	32		// 10004478
1000445c:	f0670000 	sbi	r3, r7, 0
    }
    OS_ENTER_CRITICAL();
10004460:	b9f43acc 	brlid	r15, 15052	// 10007f2c <OS_CPU_SR_Save>
10004464:	80000000 	or	r0, r0, r0
    pmem->OSMemName = pname;
    OS_EXIT_CRITICAL();
10004468:	10a30000 	addk	r5, r3, r0
1000446c:	b9f43af0 	brlid	r15, 15088	// 10007f5c <OS_CPU_SR_Restore>
10004470:	fb170014 	swi	r24, r23, 20
    *perr           = OS_ERR_NONE;
10004474:	f2d30000 	sbi	r22, r19, 0
}
10004478:	e9e10000 	lwi	r15, r1, 0
1000447c:	ea61001c 	lwi	r19, r1, 28
10004480:	eac10020 	lwi	r22, r1, 32
10004484:	eae10024 	lwi	r23, r1, 36
10004488:	eb010028 	lwi	r24, r1, 40
1000448c:	b60f0008 	rtsd	r15, 8
10004490:	3021002c 	addik	r1, r1, 44

10004494 <OSMemPut>:
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM  *pmem,
                 void    *pblk)
{
10004494:	3021ffdc 	addik	r1, r1, -36
10004498:	fa61001c 	swi	r19, r1, 28
1000449c:	12650000 	addk	r19, r5, r0
100044a0:	fac10020 	swi	r22, r1, 32
100044a4:	f9e10000 	swi	r15, r1, 0
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
        return (OS_ERR_MEM_INVALID_PBLK);
    }
#endif
    OS_ENTER_CRITICAL();
100044a8:	b9f43a84 	brlid	r15, 14980	// 10007f2c <OS_CPU_SR_Save>
100044ac:	12c60000 	addk	r22, r6, r0
100044b0:	10a30000 	addk	r5, r3, r0
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
100044b4:	e893000c 	lwi	r4, r19, 12
100044b8:	e8730010 	lwi	r3, r19, 16
100044bc:	14841803 	cmpu	r4, r4, r3
100044c0:	bc440014 	blti	r4, 20		// 100044d4
        OS_EXIT_CRITICAL();
100044c4:	b9f43a98 	brlid	r15, 15000	// 10007f5c <OS_CPU_SR_Restore>
100044c8:	80000000 	or	r0, r0, r0
        return (OS_ERR_MEM_FULL);
100044cc:	b8100024 	brid	36		// 100044f0
100044d0:	3060005e 	addik	r3, r0, 94
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
100044d4:	e8930004 	lwi	r4, r19, 4
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
100044d8:	30630001 	addik	r3, r3, 1
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
100044dc:	f8960000 	swi	r4, r22, 0
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
100044e0:	f8730010 	swi	r3, r19, 16
    OS_EXIT_CRITICAL();
100044e4:	b9f43a78 	brlid	r15, 14968	// 10007f5c <OS_CPU_SR_Restore>
100044e8:	fad30004 	swi	r22, r19, 4
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
100044ec:	10600000 	addk	r3, r0, r0
}
100044f0:	e9e10000 	lwi	r15, r1, 0
100044f4:	ea61001c 	lwi	r19, r1, 28
100044f8:	eac10020 	lwi	r22, r1, 32
100044fc:	b60f0008 	rtsd	r15, 8
10004500:	30210024 	addik	r1, r1, 36

10004504 <OSMemQuery>:
*/

#if OS_MEM_QUERY_EN > 0u
INT8U  OSMemQuery (OS_MEM       *pmem,
                   OS_MEM_DATA  *p_mem_data)
{
10004504:	3021ffdc 	addik	r1, r1, -36
10004508:	fac10020 	swi	r22, r1, 32
1000450c:	12c50000 	addk	r22, r5, r0
10004510:	f9e10000 	swi	r15, r1, 0
10004514:	fa61001c 	swi	r19, r1, 28
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_ERR_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
10004518:	b9f43a14 	brlid	r15, 14868	// 10007f2c <OS_CPU_SR_Save>
1000451c:	12660000 	addk	r19, r6, r0
    p_mem_data->OSAddr     = pmem->OSMemAddr;
10004520:	e8960000 	lwi	r4, r22, 0
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    p_mem_data->OSNFree    = pmem->OSMemNFree;
    OS_EXIT_CRITICAL();
10004524:	10a30000 	addk	r5, r3, r0
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_ERR_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
10004528:	f8930000 	swi	r4, r19, 0
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
1000452c:	e8960004 	lwi	r4, r22, 4
10004530:	f8930004 	swi	r4, r19, 4
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
10004534:	e8960008 	lwi	r4, r22, 8
10004538:	f8930008 	swi	r4, r19, 8
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
1000453c:	e896000c 	lwi	r4, r22, 12
10004540:	f893000c 	swi	r4, r19, 12
    p_mem_data->OSNFree    = pmem->OSMemNFree;
10004544:	e8960010 	lwi	r4, r22, 16
    OS_EXIT_CRITICAL();
10004548:	b9f43a14 	brlid	r15, 14868	// 10007f5c <OS_CPU_SR_Restore>
1000454c:	f8930010 	swi	r4, r19, 16
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
10004550:	e893000c 	lwi	r4, r19, 12
10004554:	e8730010 	lwi	r3, r19, 16
10004558:	14632000 	rsubk	r3, r3, r4
1000455c:	f8730014 	swi	r3, r19, 20
    return (OS_ERR_NONE);
}
10004560:	e9e10000 	lwi	r15, r1, 0
10004564:	ea61001c 	lwi	r19, r1, 28
10004568:	eac10020 	lwi	r22, r1, 32
1000456c:	10600000 	addk	r3, r0, r0
10004570:	b60f0008 	rtsd	r15, 8
10004574:	30210024 	addik	r1, r1, 36

10004578 <OS_MemInit>:
#if OS_MAX_MEM_PART >= 2u
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
10004578:	b0001000 	imm	4096
1000457c:	30a0d0fc 	addik	r5, r0, -12036	// 1000d0fc <OSMemTbl>
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
10004580:	3021ffe4 	addik	r1, r1, -28
10004584:	f9e10000 	swi	r15, r1, 0
#if OS_MAX_MEM_PART >= 2u
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
10004588:	b9f4df74 	brlid	r15, -8332	// 100024fc <OS_MemClr>
1000458c:	30c00078 	addik	r6, r0, 120	// 78 <STK_CTX_SIZE>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
10004590:	b0001000 	imm	4096
10004594:	3100d0fc 	addik	r8, r0, -12036	// 1000d0fc <OSMemTbl>
#if OS_MEM_NAME_EN > 0u
        pmem->OSMemName  = (INT8U *)"?";
10004598:	b0001000 	imm	4096
1000459c:	30e08afc 	addik	r7, r0, -29956
#if OS_MAX_MEM_PART >= 2u
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
100045a0:	30800001 	addik	r4, r0, 1
100045a4:	10600000 	addk	r3, r0, r0
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
100045a8:	60c40018 	muli	r6, r4, 24
#if OS_MEM_NAME_EN > 0u
        pmem->OSMemName  = (INT8U *)"?";
100045ac:	30840001 	addik	r4, r4, 1


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
100045b0:	10c64000 	addk	r6, r6, r8
100045b4:	b0001000 	imm	4096
100045b8:	f8c3d100 	swi	r6, r3, -12032
#if OS_MEM_NAME_EN > 0u
        pmem->OSMemName  = (INT8U *)"?";
100045bc:	b0001000 	imm	4096
100045c0:	f8e3d110 	swi	r7, r3, -12016
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
100045c4:	a8c40005 	xori	r6, r4, 5
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
100045c8:	b0001000 	imm	4096
100045cc:	30a0d0fc 	addik	r5, r0, -12036	// 1000d0fc <OSMemTbl>
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
100045d0:	be26ffd8 	bneid	r6, -40		// 100045a8
100045d4:	30630018 	addik	r3, r3, 24
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
#if OS_MEM_NAME_EN > 0u
    pmem->OSMemName = (INT8U *)"?";
100045d8:	b0001000 	imm	4096
100045dc:	30608afc 	addik	r3, r0, -29956
#if OS_MEM_NAME_EN > 0u
        pmem->OSMemName  = (INT8U *)"?";
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
100045e0:	f8c50064 	swi	r6, r5, 100
#if OS_MEM_NAME_EN > 0u
    pmem->OSMemName = (INT8U *)"?";
#endif

    OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
100045e4:	b0001000 	imm	4096
100045e8:	f8a0d38c 	swi	r5, r0, -11380	// 1000d38c <OSMemFreeList>
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
#if OS_MEM_NAME_EN > 0u
    pmem->OSMemName = (INT8U *)"?";
100045ec:	f8650074 	swi	r3, r5, 116
#endif

    OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
#endif
}
100045f0:	e9e10000 	lwi	r15, r1, 0
100045f4:	b60f0008 	rtsd	r15, 8
100045f8:	3021001c 	addik	r1, r1, 28

100045fc <OSMutex_RdyAtPrio>:
{
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
100045fc:	e0850038 	lbui	r4, r5, 56
10004600:	e0650039 	lbui	r3, r5, 57
10004604:	b0001000 	imm	4096
10004608:	e0e4d3fc 	lbui	r7, r4, -11268
1000460c:	a863ffff 	xori	r3, r3, -1
10004610:	84633800 	and	r3, r3, r7
10004614:	b0001000 	imm	4096
10004618:	f064d3fc 	sbi	r3, r4, -11268
    if (OSRdyTbl[y] == 0u) {
1000461c:	be230028 	bneid	r3, 40		// 10004644
10004620:	64660003 	bsrli	r3, r6, 3
        OSRdyGrp &= ~ptcb->OSTCBBitY;
10004624:	e065003a 	lbui	r3, r5, 58
10004628:	b0001000 	imm	4096
1000462c:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10004630:	a863ffff 	xori	r3, r3, -1
10004634:	84632000 	and	r3, r3, r4
10004638:	b0001000 	imm	4096
1000463c:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
    }
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
10004640:	64660003 	bsrli	r3, r6, 3
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
10004644:	a4860007 	andi	r4, r6, 7
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
10004648:	a4630007 	andi	r3, r3, 7
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
    ptcb->OSTCBBitY         = (INT8U)(1u << ptcb->OSTCBY);
1000464c:	31000001 	addik	r8, r0, 1
    }
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
10004650:	f0850037 	sbi	r4, r5, 55
    ptcb->OSTCBBitY         = (INT8U)(1u << ptcb->OSTCBY);
10004654:	44e81c00 	bsll	r7, r8, r3
    ptcb->OSTCBBitX         = (INT8U)(1u << ptcb->OSTCBX);
10004658:	44882400 	bsll	r4, r8, r4
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1u << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1u << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
1000465c:	b0001000 	imm	4096
10004660:	e100d3f8 	lbui	r8, r0, -11272	// 1000d3f8 <OSRdyGrp>
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
    ptcb->OSTCBBitY         = (INT8U)(1u << ptcb->OSTCBY);
10004664:	a4e700ff 	andi	r7, r7, 255
    ptcb->OSTCBBitX         = (INT8U)(1u << ptcb->OSTCBX);
10004668:	a48400ff 	andi	r4, r4, 255
    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0u) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
1000466c:	f0c50036 	sbi	r6, r5, 54
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
    ptcb->OSTCBBitY         = (INT8U)(1u << ptcb->OSTCBY);
10004670:	f0e5003a 	sbi	r7, r5, 58
    ptcb->OSTCBBitX         = (INT8U)(1u << ptcb->OSTCBX);
10004674:	f0850039 	sbi	r4, r5, 57
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
#if OS_LOWEST_PRIO <= 63u
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
10004678:	f0650038 	sbi	r3, r5, 56
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1u << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1u << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
1000467c:	80e74000 	or	r7, r7, r8
10004680:	b0001000 	imm	4096
10004684:	f0e0d3f8 	sbi	r7, r0, -11272	// 1000d3f8 <OSRdyGrp>
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10004688:	b0001000 	imm	4096
1000468c:	e0e3d3fc 	lbui	r7, r3, -11268
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    if (OSRdyTbl[y] == 0u) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBPrio         = prio;
    OSPrioCur               = prio;                        /* The current task is now at this priority */
10004690:	b0001000 	imm	4096
10004694:	f0c0d0f4 	sbi	r6, r0, -12044	// 1000d0f4 <OSPrioCur>
    ptcb->OSTCBBitY         = (INT16U)(1u << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1u << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    OSTCBPrioTbl[prio]      = ptcb;
10004698:	64c60402 	bslli	r6, r6, 2
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1u << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1u << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
1000469c:	80843800 	or	r4, r4, r7
100046a0:	b0001000 	imm	4096
100046a4:	f083d3fc 	sbi	r4, r3, -11268
    OSTCBPrioTbl[prio]      = ptcb;
100046a8:	b0001000 	imm	4096
100046ac:	f8a6e0a4 	swi	r5, r6, -8028
    
}
100046b0:	b60f0008 	rtsd	r15, 8
100046b4:	80000000 	or	r0, r0, r0

100046b8 <OSMutexAccept>:
*/

#if OS_MUTEX_ACCEPT_EN > 0u
BOOLEAN  OSMutexAccept (OS_EVENT  *pevent, 
                        INT8U     *perr)
{
100046b8:	3021ffd4 	addik	r1, r1, -44
100046bc:	fa61001c 	swi	r19, r1, 28
100046c0:	fac10020 	swi	r22, r1, 32
100046c4:	f9e10000 	swi	r15, r1, 0
100046c8:	fae10024 	swi	r23, r1, 36
100046cc:	fb010028 	swi	r24, r1, 40
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        *perr = OS_ERR_PEVENT_NULL;
        return (OS_FALSE);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
100046d0:	e0650000 	lbui	r3, r5, 0
*/

#if OS_MUTEX_ACCEPT_EN > 0u
BOOLEAN  OSMutexAccept (OS_EVENT  *pevent, 
                        INT8U     *perr)
{
100046d4:	12c50000 	addk	r22, r5, r0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        *perr = OS_ERR_PEVENT_NULL;
        return (OS_FALSE);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
100046d8:	a8630004 	xori	r3, r3, 4
100046dc:	be030018 	beqid	r3, 24		// 100046f4
100046e0:	12660000 	addk	r19, r6, r0
        *perr = OS_ERR_EVENT_TYPE;
100046e4:	30600001 	addik	r3, r0, 1
100046e8:	f0660000 	sbi	r3, r6, 0
        return (OS_FALSE);
100046ec:	b81000a8 	brid	168		// 10004794
100046f0:	10600000 	addk	r3, r0, r0
    }
    if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
100046f4:	b0001000 	imm	4096
100046f8:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>
100046fc:	be170010 	beqid	r23, 16		// 1000470c
10004700:	30800002 	addik	r4, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;
        return (OS_FALSE);
10004704:	b8100090 	brid	144		// 10004794
10004708:	f0860000 	sbi	r4, r6, 0
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
1000470c:	b9f43820 	brlid	r15, 14368	// 10007f2c <OS_CPU_SR_Save>
10004710:	80000000 	or	r0, r0, r0
10004714:	10a30000 	addk	r5, r3, r0
    pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
10004718:	e4760008 	lhui	r3, r22, 8
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
1000471c:	a70300ff 	andi	r24, r3, 255
10004720:	ab1800ff 	xori	r24, r24, 255
10004724:	bc380060 	bnei	r24, 96		// 10004784
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
10004728:	b0001000 	imm	4096
1000472c:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
        return (OS_FALSE);
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
    pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
10004730:	b0000000 	imm	0
10004734:	a4c3ff00 	andi	r6, r3, -256
10004738:	f4d60008 	shi	r6, r22, 8
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
1000473c:	e0e40036 	lbui	r7, r4, 54
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
10004740:	f8960004 	swi	r4, r22, 4
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
10004744:	64630008 	bsrli	r3, r3, 8
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
    pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
10004748:	80c63800 	or	r6, r6, r7
1000474c:	f4d60008 	shi	r6, r22, 8
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
10004750:	e0840036 	lbui	r4, r4, 54
10004754:	14641803 	cmpu	r3, r4, r3
10004758:	bc430018 	blti	r3, 24		// 10004770
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
1000475c:	b9f43800 	brlid	r15, 14336	// 10007f5c <OS_CPU_SR_Restore>
10004760:	80000000 	or	r0, r0, r0
            *perr = OS_ERR_PIP_LOWER;
10004764:	30600078 	addik	r3, r0, 120	// 78 <STK_CTX_SIZE>
10004768:	b8100014 	brid	20		// 1000477c
1000476c:	f0730000 	sbi	r3, r19, 0
        } else {
            OS_EXIT_CRITICAL();
10004770:	b9f437ec 	brlid	r15, 14316	// 10007f5c <OS_CPU_SR_Restore>
10004774:	80000000 	or	r0, r0, r0
            *perr = OS_ERR_NONE;
10004778:	f3130000 	sbi	r24, r19, 0
        }
        return (OS_TRUE);
1000477c:	b8100018 	brid	24		// 10004794
10004780:	30600001 	addik	r3, r0, 1
    }
    OS_EXIT_CRITICAL();
10004784:	b9f437d8 	brlid	r15, 14296	// 10007f5c <OS_CPU_SR_Restore>
10004788:	80000000 	or	r0, r0, r0
    *perr = OS_ERR_NONE;
    return (OS_FALSE);
1000478c:	10770000 	addk	r3, r23, r0
            *perr = OS_ERR_NONE;
        }
        return (OS_TRUE);
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
10004790:	f2f30000 	sbi	r23, r19, 0
    return (OS_FALSE);
}
10004794:	e9e10000 	lwi	r15, r1, 0
10004798:	ea61001c 	lwi	r19, r1, 28
1000479c:	eac10020 	lwi	r22, r1, 32
100047a0:	eae10024 	lwi	r23, r1, 36
100047a4:	eb010028 	lwi	r24, r1, 40
100047a8:	b60f0008 	rtsd	r15, 8
100047ac:	3021002c 	addik	r1, r1, 44

100047b0 <OSMutexCreate>:
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U   prio, 
                          INT8U  *perr)
{
100047b0:	3021ffd4 	addik	r1, r1, -44
100047b4:	fa61001c 	swi	r19, r1, 28
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
        *perr = OS_ERR_PRIO_INVALID;
        return ((OS_EVENT *)0);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100047b8:	b0001000 	imm	4096
100047bc:	e260d608 	lbui	r19, r0, -10744	// 1000d608 <OSIntNesting>
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U   prio, 
                          INT8U  *perr)
{
100047c0:	fac10020 	swi	r22, r1, 32
100047c4:	fb010028 	swi	r24, r1, 40
100047c8:	f9e10000 	swi	r15, r1, 0
100047cc:	fae10024 	swi	r23, r1, 36
100047d0:	13050000 	addk	r24, r5, r0
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
        *perr = OS_ERR_PRIO_INVALID;
        return ((OS_EVENT *)0);
    }
#endif
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100047d4:	be130018 	beqid	r19, 24		// 100047ec
100047d8:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
100047dc:	30600010 	addik	r3, r0, 16	// 10 <STK_OFFSET_R05>
100047e0:	f0660000 	sbi	r3, r6, 0
        return ((OS_EVENT *)0);
100047e4:	b81000a8 	brid	168		// 1000488c
100047e8:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
100047ec:	b9f43740 	brlid	r15, 14144	// 10007f2c <OS_CPU_SR_Save>
100047f0:	80000000 	or	r0, r0, r0
100047f4:	10a30000 	addk	r5, r3, r0
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
100047f8:	64780402 	bslli	r3, r24, 2
100047fc:	b0001000 	imm	4096
10004800:	eae3e0a4 	lwi	r23, r3, -8028
10004804:	be170018 	beqid	r23, 24		// 1000481c
10004808:	30800001 	addik	r4, r0, 1
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
1000480c:	b9f43750 	brlid	r15, 14160	// 10007f5c <OS_CPU_SR_Restore>
10004810:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
10004814:	b8100030 	brid	48		// 10004844
10004818:	30600028 	addik	r3, r0, 40	// 28 <STK_OFFSET_R11>
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
1000481c:	b0001000 	imm	4096
10004820:	ea60d604 	lwi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
        return ((OS_EVENT *)0);
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
10004824:	b0001000 	imm	4096
10004828:	f883e0a4 	swi	r4, r3, -8028
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
1000482c:	bc330020 	bnei	r19, 32		// 1000484c
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
10004830:	b0001000 	imm	4096
10004834:	fa63e0a4 	swi	r19, r3, -8028
        OS_EXIT_CRITICAL();
10004838:	b9f43724 	brlid	r15, 14116	// 10007f5c <OS_CPU_SR_Restore>
1000483c:	80000000 	or	r0, r0, r0
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
10004840:	30600004 	addik	r3, r0, 4	// 4 <STK_OFFSET_R02>
        return (pevent);
10004844:	b8100048 	brid	72		// 1000488c
10004848:	f0760000 	sbi	r3, r22, 0
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
1000484c:	e8730004 	lwi	r3, r19, 4
10004850:	b0001000 	imm	4096
10004854:	f860d604 	swi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
    OS_EXIT_CRITICAL();
10004858:	b9f43704 	brlid	r15, 14084	// 10007f5c <OS_CPU_SR_Restore>
1000485c:	67180408 	bslli	r24, r24, 8
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
10004860:	30600004 	addik	r3, r0, 4	// 4 <STK_OFFSET_R02>
10004864:	f0730000 	sbi	r3, r19, 0
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
#if OS_EVENT_NAME_EN > 0u
    pevent->OSEventName    = (INT8U *)"?";
10004868:	b0001000 	imm	4096
1000486c:	30608b00 	addik	r3, r0, -29952
#endif
    OS_EventWaitListInit(pevent);
10004870:	10b30000 	addk	r5, r19, r0
        return (pevent);
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
10004874:	a31800ff 	ori	r24, r24, 255
10004878:	f7130008 	shi	r24, r19, 8
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
1000487c:	faf30004 	swi	r23, r19, 4
#if OS_EVENT_NAME_EN > 0u
    pevent->OSEventName    = (INT8U *)"?";
#endif
    OS_EventWaitListInit(pevent);
10004880:	b9f4dc58 	brlid	r15, -9128	// 100024d8 <OS_EventWaitListInit>
10004884:	f8730014 	swi	r3, r19, 20
    *perr                  = OS_ERR_NONE;
10004888:	f2f60000 	sbi	r23, r22, 0
    return (pevent);
}
1000488c:	10730000 	addk	r3, r19, r0
10004890:	e9e10000 	lwi	r15, r1, 0
10004894:	ea61001c 	lwi	r19, r1, 28
10004898:	eac10020 	lwi	r22, r1, 32
1000489c:	eae10024 	lwi	r23, r1, 36
100048a0:	eb010028 	lwi	r24, r1, 40
100048a4:	b60f0008 	rtsd	r15, 8
100048a8:	3021002c 	addik	r1, r1, 44

100048ac <OSMutexDel>:

#if OS_MUTEX_DEL_EN > 0u
OS_EVENT  *OSMutexDel (OS_EVENT  *pevent, 
                       INT8U      opt, 
                       INT8U     *perr)
{
100048ac:	3021ffcc 	addik	r1, r1, -52
100048b0:	fa61001c 	swi	r19, r1, 28
100048b4:	fac10020 	swi	r22, r1, 32
100048b8:	fb410030 	swi	r26, r1, 48
100048bc:	f9e10000 	swi	r15, r1, 0
100048c0:	fae10024 	swi	r23, r1, 36
100048c4:	fb010028 	swi	r24, r1, 40
100048c8:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
100048cc:	e0650000 	lbui	r3, r5, 0

#if OS_MUTEX_DEL_EN > 0u
OS_EVENT  *OSMutexDel (OS_EVENT  *pevent, 
                       INT8U      opt, 
                       INT8U     *perr)
{
100048d0:	12650000 	addk	r19, r5, r0
100048d4:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
100048d8:	a8630004 	xori	r3, r3, 4
100048dc:	be030010 	beqid	r3, 16		// 100048ec
100048e0:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
100048e4:	b8100158 	brid	344		// 10004a3c
100048e8:	30600001 	addik	r3, r0, 1
        return (pevent);
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100048ec:	b0001000 	imm	4096
100048f0:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>
100048f4:	be370148 	bneid	r23, 328		// 10004a3c
100048f8:	3060000f 	addik	r3, r0, 15
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
100048fc:	b9f43630 	brlid	r15, 13872	// 10007f2c <OS_CPU_SR_Save>
10004900:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10004904:	e333000a 	lbui	r25, r19, 10
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10004908:	13030000 	addk	r24, r3, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
1000490c:	8f39bc00 	pcmpne	r25, r25, r23
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
10004910:	be1a0014 	beqid	r26, 20		// 10004924
10004914:	12f90000 	addk	r23, r25, r0
10004918:	ab5a0001 	xori	r26, r26, 1
1000491c:	bc1a006c 	beqi	r26, 108		// 10004988
10004920:	b8000110 	bri	272		// 10004a30
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
10004924:	bc390054 	bnei	r25, 84		// 10004978
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName = (INT8U *)"?";
10004928:	b0001000 	imm	4096
1000492c:	30608b00 	addik	r3, r0, -29952
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
                 pevent->OSEventCnt  = 0u;
                 OSEventFreeList     = pevent;
                 OS_EXIT_CRITICAL();
10004930:	10b80000 	addk	r5, r24, r0
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName = (INT8U *)"?";
10004934:	f8730014 	swi	r3, r19, 20
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
10004938:	e4730008 	lhui	r3, r19, 8
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
1000493c:	64630008 	bsrli	r3, r3, 8
10004940:	64630402 	bslli	r3, r3, 2
10004944:	b0001000 	imm	4096
10004948:	fb23e0a4 	swi	r25, r3, -8028
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
1000494c:	f3330000 	sbi	r25, r19, 0
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
10004950:	b0001000 	imm	4096
10004954:	e860d604 	lwi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
                 pevent->OSEventCnt  = 0u;
10004958:	f7330008 	shi	r25, r19, 8
                 OSEventFreeList     = pevent;
1000495c:	b0001000 	imm	4096
10004960:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
                 OS_EXIT_CRITICAL();
10004964:	b9f435f8 	brlid	r15, 13816	// 10007f5c <OS_CPU_SR_Restore>
10004968:	f8730004 	swi	r3, r19, 4
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
1000496c:	12790000 	addk	r19, r25, r0
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
                 pevent->OSEventCnt  = 0u;
                 OSEventFreeList     = pevent;
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
10004970:	b81000d0 	brid	208		// 10004a40
10004974:	f3360000 	sbi	r25, r22, 0
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
10004978:	b9f435e4 	brlid	r15, 13796	// 10007f5c <OS_CPU_SR_Restore>
1000497c:	10a30000 	addk	r5, r3, r0
                 *perr               = OS_ERR_TASK_WAITING;
10004980:	b81000bc 	brid	188		// 10004a3c
10004984:	30600049 	addik	r3, r0, 73
             break;

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8u);                    /* Get PIP of mutex          */
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
             ptcb = (OS_TCB *)pevent->OSEventPtr;
10004988:	e8b30004 	lwi	r5, r19, 4
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
1000498c:	be050038 	beqid	r5, 56		// 100049c4
10004990:	e4d30008 	lhui	r6, r19, 8
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
10004994:	e0850036 	lbui	r4, r5, 54
10004998:	64660008 	bsrli	r3, r6, 8
1000499c:	88641800 	xor	r3, r4, r3
100049a0:	bc230024 	bnei	r3, 36		// 100049c4
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
100049a4:	b9f4fc58 	brlid	r15, -936	// 100045fc <OSMutex_RdyAtPrio>
100049a8:	a4c600ff 	andi	r6, r6, 255
                 }
             }
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
100049ac:	b810001c 	brid	28		// 100049c8
100049b0:	e073000a 	lbui	r3, r19, 10
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
100049b4:	10b30000 	addk	r5, r19, r0
100049b8:	11060000 	addk	r8, r6, r0
100049bc:	b9f4da3c 	brlid	r15, -9668	// 100023f8 <OS_EventTaskRdy>
100049c0:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
100049c4:	e073000a 	lbui	r3, r19, 10
100049c8:	be23ffec 	bneid	r3, -20		// 100049b4
100049cc:	10c00000 	addk	r6, r0, r0
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName = (INT8U *)"?";
100049d0:	b0001000 	imm	4096
100049d4:	30808b00 	addik	r4, r0, -29952
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
             pevent->OSEventCnt  = 0u;
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
             OS_EXIT_CRITICAL();
100049d8:	10b80000 	addk	r5, r24, r0
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
100049dc:	aaf70001 	xori	r23, r23, 1
             }
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName = (INT8U *)"?";
100049e0:	f8930014 	swi	r4, r19, 20
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
100049e4:	e4930008 	lhui	r4, r19, 8
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
100049e8:	64840008 	bsrli	r4, r4, 8
100049ec:	64840402 	bslli	r4, r4, 2
100049f0:	b0001000 	imm	4096
100049f4:	f864e0a4 	swi	r3, r4, -8028
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
100049f8:	f0730000 	sbi	r3, r19, 0
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
100049fc:	b0001000 	imm	4096
10004a00:	e880d604 	lwi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
             pevent->OSEventCnt  = 0u;
10004a04:	f4730008 	shi	r3, r19, 8
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
10004a08:	b0001000 	imm	4096
10004a0c:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
             OS_EXIT_CRITICAL();
10004a10:	b9f4354c 	brlid	r15, 13644	// 10007f5c <OS_CPU_SR_Restore>
10004a14:	f8930004 	swi	r4, r19, 4
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
10004a18:	bc37000c 	bnei	r23, 12		// 10004a24
                 OS_Sched();                               /* Find highest priority task ready to run  */
10004a1c:	b9f4dda4 	brlid	r15, -8796	// 100027c0 <OS_Sched>
10004a20:	80000000 	or	r0, r0, r0
             }
             *perr         = OS_ERR_NONE;
10004a24:	f0160000 	sbi	r0, r22, 0
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
             break;
10004a28:	b8100018 	brid	24		// 10004a40
10004a2c:	12600000 	addk	r19, r0, r0

        default:
             OS_EXIT_CRITICAL();
10004a30:	b9f4352c 	brlid	r15, 13612	// 10007f5c <OS_CPU_SR_Restore>
10004a34:	10a30000 	addk	r5, r3, r0
             *perr         = OS_ERR_INVALID_OPT;
10004a38:	30600007 	addik	r3, r0, 7
10004a3c:	f0760000 	sbi	r3, r22, 0
             pevent_return = pevent;
             break;
    }
    return (pevent_return);
}
10004a40:	10730000 	addk	r3, r19, r0
10004a44:	e9e10000 	lwi	r15, r1, 0
10004a48:	ea61001c 	lwi	r19, r1, 28
10004a4c:	eac10020 	lwi	r22, r1, 32
10004a50:	eae10024 	lwi	r23, r1, 36
10004a54:	eb010028 	lwi	r24, r1, 40
10004a58:	eb21002c 	lwi	r25, r1, 44
10004a5c:	eb410030 	lwi	r26, r1, 48
10004a60:	b60f0008 	rtsd	r15, 8
10004a64:	30210034 	addik	r1, r1, 52

10004a68 <OSMutexPend>:
*/

void  OSMutexPend (OS_EVENT  *pevent, 
                   INT32U     timeout, 
                   INT8U     *perr)
{
10004a68:	3021ffd0 	addik	r1, r1, -48
10004a6c:	fa61001c 	swi	r19, r1, 28
10004a70:	fac10020 	swi	r22, r1, 32
10004a74:	fb21002c 	swi	r25, r1, 44
10004a78:	f9e10000 	swi	r15, r1, 0
10004a7c:	fae10024 	swi	r23, r1, 36
10004a80:	fb010028 	swi	r24, r1, 40
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
10004a84:	e0650000 	lbui	r3, r5, 0
*/

void  OSMutexPend (OS_EVENT  *pevent, 
                   INT32U     timeout, 
                   INT8U     *perr)
{
10004a88:	12c50000 	addk	r22, r5, r0
10004a8c:	13260000 	addk	r25, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
10004a90:	a8630004 	xori	r3, r3, 4
10004a94:	be030010 	beqid	r3, 16		// 10004aa4
10004a98:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10004a9c:	b810008c 	brid	140		// 10004b28
10004aa0:	30600001 	addik	r3, r0, 1
        return;
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10004aa4:	b0001000 	imm	4096
10004aa8:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10004aac:	be23007c 	bneid	r3, 124		// 10004b28
10004ab0:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
        return;
    }
    if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
10004ab4:	b0001000 	imm	4096
10004ab8:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
10004abc:	be23006c 	bneid	r3, 108		// 10004b28
10004ac0:	3060000d 	addik	r3, r0, 13
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
        return;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
10004ac4:	b9f43468 	brlid	r15, 13416	// 10007f2c <OS_CPU_SR_Save>
10004ac8:	80000000 	or	r0, r0, r0
    pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
10004acc:	e4960008 	lhui	r4, r22, 8
    if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
        return;
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
10004ad0:	12e30000 	addk	r23, r3, r0
10004ad4:	b0001000 	imm	4096
10004ad8:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
    pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
10004adc:	65440008 	bsrli	r10, r4, 8
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
10004ae0:	a4a400ff 	andi	r5, r4, 255
10004ae4:	ab0500ff 	xori	r24, r5, 255
10004ae8:	be380058 	bneid	r24, 88		// 10004b40
10004aec:	a50a00ff 	andi	r8, r10, 255
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
10004af0:	b0000000 	imm	0
10004af4:	a484ff00 	andi	r4, r4, -256
10004af8:	f4960008 	shi	r4, r22, 8
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
10004afc:	e0a30036 	lbui	r5, r3, 54
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
10004b00:	f8760004 	swi	r3, r22, 4
    OS_ENTER_CRITICAL();
    pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
10004b04:	80842800 	or	r4, r4, r5
10004b08:	f4960008 	shi	r4, r22, 8
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
10004b0c:	e0630036 	lbui	r3, r3, 54
10004b10:	15034003 	cmpu	r8, r3, r8
10004b14:	be48001c 	bltid	r8, 28		// 10004b30
10004b18:	10b70000 	addk	r5, r23, r0
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
10004b1c:	b9f43440 	brlid	r15, 13376	// 10007f5c <OS_CPU_SR_Restore>
10004b20:	80000000 	or	r0, r0, r0
            *perr = OS_ERR_PIP_LOWER;
10004b24:	30600078 	addik	r3, r0, 120	// 78 <STK_CTX_SIZE>
10004b28:	b81001fc 	brid	508		// 10004d24
10004b2c:	f0730000 	sbi	r3, r19, 0
        } else {
            OS_EXIT_CRITICAL();
10004b30:	b9f4342c 	brlid	r15, 13356	// 10007f5c <OS_CPU_SR_Restore>
10004b34:	80000000 	or	r0, r0, r0
            *perr = OS_ERR_NONE;
10004b38:	b81001ec 	brid	492		// 10004d24
10004b3c:	f3130000 	sbi	r24, r19, 0
        }
        return;
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
10004b40:	e8960004 	lwi	r4, r22, 4
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
10004b44:	e0c40036 	lbui	r6, r4, 54
10004b48:	14c64003 	cmpu	r6, r6, r8
10004b4c:	bca60140 	bgei	r6, 320		// 10004c8c
        if (mprio > OSTCBCur->OSTCBPrio) {
10004b50:	e0630036 	lbui	r3, r3, 54
10004b54:	14a51803 	cmpu	r5, r5, r3
10004b58:	bca50134 	bgei	r5, 308		// 10004c8c
            y = ptcb->OSTCBY;
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {          /*     See if mutex owner is ready   */
10004b5c:	e0a40038 	lbui	r5, r4, 56
10004b60:	e0640039 	lbui	r3, r4, 57
10004b64:	b0001000 	imm	4096
10004b68:	e0e5d3fc 	lbui	r7, r5, -11268
10004b6c:	85671800 	and	r11, r7, r3
10004b70:	bc0b0040 	beqi	r11, 64		// 10004bb0
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
10004b74:	a863ffff 	xori	r3, r3, -1
10004b78:	84671800 	and	r3, r7, r3
10004b7c:	b0001000 	imm	4096
10004b80:	f065d3fc 	sbi	r3, r5, -11268
                if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
10004b84:	be230068 	bneid	r3, 104		// 10004bec
10004b88:	30e00001 	addik	r7, r0, 1
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
10004b8c:	e064003a 	lbui	r3, r4, 58
10004b90:	b0001000 	imm	4096
10004b94:	e0a0d3f8 	lbui	r5, r0, -11272	// 1000d3f8 <OSRdyGrp>
10004b98:	a863ffff 	xori	r3, r3, -1
10004b9c:	84632800 	and	r3, r3, r5
10004ba0:	b0001000 	imm	4096
10004ba4:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
10004ba8:	b8100048 	brid	72		// 10004bf0
10004bac:	65280003 	bsrli	r9, r8, 3
                if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
                }
                rdy = OS_TRUE;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
10004bb0:	e8e4001c 	lwi	r7, r4, 28
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
10004bb4:	be070038 	beqid	r7, 56		// 10004bec
10004bb8:	11270000 	addk	r9, r7, r0
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
10004bbc:	10e72800 	addk	r7, r7, r5
10004bc0:	e0a7000b 	lbui	r5, r7, 11
10004bc4:	a863ffff 	xori	r3, r3, -1
10004bc8:	84632800 	and	r3, r3, r5
10004bcc:	f067000b 	sbi	r3, r7, 11
10004bd0:	be23001c 	bneid	r3, 28		// 10004bec
10004bd4:	10eb0000 	addk	r7, r11, r0
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
10004bd8:	e064003a 	lbui	r3, r4, 58
10004bdc:	e0a9000a 	lbui	r5, r9, 10
10004be0:	a863ffff 	xori	r3, r3, -1
10004be4:	84632800 	and	r3, r3, r5
10004be8:	f069000a 	sbi	r3, r9, 10
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
10004bec:	65280003 	bsrli	r9, r8, 3
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
10004bf0:	a4a80007 	andi	r5, r8, 7
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
10004bf4:	f1440036 	sbi	r10, r4, 54
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
            ptcb->OSTCBBitY = (INT8U)(1u << ptcb->OSTCBY);
10004bf8:	31400001 	addik	r10, r0, 1
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
10004bfc:	f0a40037 	sbi	r5, r4, 55
            ptcb->OSTCBBitY = (INT8U)(1u << ptcb->OSTCBY);
10004c00:	446a4c00 	bsll	r3, r10, r9
            ptcb->OSTCBBitX = (INT8U)(1u << ptcb->OSTCBX);
10004c04:	44aa2c00 	bsll	r5, r10, r5
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
            ptcb->OSTCBBitY = (INT8U)(1u << ptcb->OSTCBY);
10004c08:	a46300ff 	andi	r3, r3, 255
            ptcb->OSTCBBitX = (INT8U)(1u << ptcb->OSTCBX);
10004c0c:	a4a500ff 	andi	r5, r5, 255
                }
                rdy = OS_FALSE;                            /* No                                       */
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
#if OS_LOWEST_PRIO <= 63u
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
10004c10:	f1240038 	sbi	r9, r4, 56
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
            ptcb->OSTCBBitY = (INT8U)(1u << ptcb->OSTCBY);
10004c14:	f064003a 	sbi	r3, r4, 58
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4u) & 0xFFu);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
            ptcb->OSTCBBitY = (INT16U)(1u << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1u << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
10004c18:	88e75000 	xor	r7, r7, r10
10004c1c:	be270038 	bneid	r7, 56		// 10004c54
10004c20:	f0a40039 	sbi	r5, r4, 57
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
10004c24:	b0001000 	imm	4096
10004c28:	e0c0d3f8 	lbui	r6, r0, -11272	// 1000d3f8 <OSRdyGrp>
10004c2c:	80633000 	or	r3, r3, r6
10004c30:	b0001000 	imm	4096
10004c34:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10004c38:	b0001000 	imm	4096
10004c3c:	e069d3fc 	lbui	r3, r9, -11268
10004c40:	80a51800 	or	r5, r5, r3
10004c44:	b0001000 	imm	4096
10004c48:	f0a9d3fc 	sbi	r5, r9, -11268
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
10004c4c:	b8100038 	brid	56		// 10004c84
10004c50:	65080402 	bslli	r8, r8, 2
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
10004c54:	e8e4001c 	lwi	r7, r4, 28
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
10004c58:	bc070028 	beqi	r7, 40		// 10004c80
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
10004c5c:	e0a7000a 	lbui	r5, r7, 10
10004c60:	80632800 	or	r3, r3, r5
10004c64:	f067000a 	sbi	r3, r7, 10
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10004c68:	e0640038 	lbui	r3, r4, 56
10004c6c:	10e71800 	addk	r7, r7, r3
10004c70:	e0a7000b 	lbui	r5, r7, 11
10004c74:	e0640039 	lbui	r3, r4, 57
10004c78:	80651800 	or	r3, r5, r3
10004c7c:	f067000b 	sbi	r3, r7, 11
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
10004c80:	65080402 	bslli	r8, r8, 2
10004c84:	b0001000 	imm	4096
10004c88:	f888e0a4 	swi	r4, r8, -8028
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
10004c8c:	b0001000 	imm	4096
10004c90:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10004c94:	10b60000 	addk	r5, r22, r0
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
10004c98:	e0830034 	lbui	r4, r3, 52
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
10004c9c:	f0030035 	sbi	r0, r3, 53
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
10004ca0:	fb230030 	swi	r25, r3, 48
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
10004ca4:	a0840010 	ori	r4, r4, 16
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10004ca8:	b9f4d5bc 	brlid	r15, -10820	// 10002264 <OS_EventTaskWait>
10004cac:	f0830034 	sbi	r4, r3, 52
    OS_EXIT_CRITICAL();
10004cb0:	b9f432ac 	brlid	r15, 12972	// 10007f5c <OS_CPU_SR_Restore>
10004cb4:	10b70000 	addk	r5, r23, r0
    OS_Sched();                                       /* Find next highest priority task ready         */
10004cb8:	b9f4db08 	brlid	r15, -9464	// 100027c0 <OS_Sched>
10004cbc:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
10004cc0:	b9f4326c 	brlid	r15, 12908	// 10007f2c <OS_CPU_SR_Save>
10004cc4:	80000000 	or	r0, r0, r0
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
10004cc8:	b0001000 	imm	4096
10004ccc:	e8a0d60c 	lwi	r5, r0, -10740	// 1000d60c <OSTCBCur>
10004cd0:	e0850035 	lbui	r4, r5, 53
10004cd4:	be040018 	beqid	r4, 24		// 10004cec
10004cd8:	12e30000 	addk	r23, r3, r0
10004cdc:	a8840002 	xori	r4, r4, 2
10004ce0:	be040020 	beqid	r4, 32		// 10004d00
10004ce4:	3060000e 	addik	r3, r0, 14
10004ce8:	b800000c 	bri	12		// 10004cf4
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
             break;
10004cec:	b8100018 	brid	24		// 10004d04
10004cf0:	f0930000 	sbi	r4, r19, 0
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
             break;
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
10004cf4:	b9f4d678 	brlid	r15, -10632	// 1000236c <OS_EventTaskRemove>
10004cf8:	10d60000 	addk	r6, r22, r0
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
10004cfc:	3060000a 	addik	r3, r0, 10
10004d00:	f0730000 	sbi	r3, r19, 0
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10004d04:	b0001000 	imm	4096
10004d08:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
10004d0c:	10b70000 	addk	r5, r23, r0
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10004d10:	f0040034 	sbi	r0, r4, 52
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
10004d14:	f0040035 	sbi	r0, r4, 53
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
10004d18:	f804001c 	swi	r0, r4, 28
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
10004d1c:	b9f43240 	brlid	r15, 12864	// 10007f5c <OS_CPU_SR_Restore>
10004d20:	f8040020 	swi	r0, r4, 32
}
10004d24:	e9e10000 	lwi	r15, r1, 0
10004d28:	ea61001c 	lwi	r19, r1, 28
10004d2c:	eac10020 	lwi	r22, r1, 32
10004d30:	eae10024 	lwi	r23, r1, 36
10004d34:	eb010028 	lwi	r24, r1, 40
10004d38:	eb21002c 	lwi	r25, r1, 44
10004d3c:	b60f0008 	rtsd	r15, 8
10004d40:	30210030 	addik	r1, r1, 48

10004d44 <OSMutexPost>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
10004d44:	b0001000 	imm	4096
10004d48:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
10004d4c:	3021ffd4 	addik	r1, r1, -44
10004d50:	fa61001c 	swi	r19, r1, 28
10004d54:	f9e10000 	swi	r15, r1, 0
10004d58:	fac10020 	swi	r22, r1, 32
10004d5c:	fae10024 	swi	r23, r1, 36
10004d60:	fb010028 	swi	r24, r1, 40
10004d64:	12650000 	addk	r19, r5, r0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
10004d68:	be24010c 	bneid	r4, 268		// 10004e74
10004d6c:	30600005 	addik	r3, r0, 5
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
10004d70:	e0850000 	lbui	r4, r5, 0
10004d74:	a8840004 	xori	r4, r4, 4
10004d78:	be2400fc 	bneid	r4, 252		// 10004e74
10004d7c:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10004d80:	b9f431ac 	brlid	r15, 12716	// 10007f2c <OS_CPU_SR_Save>
10004d84:	80000000 	or	r0, r0, r0
10004d88:	12c30000 	addk	r22, r3, r0
    pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
10004d8c:	b0001000 	imm	4096
10004d90:	e8a0d60c 	lwi	r5, r0, -10740	// 1000d60c <OSTCBCur>
10004d94:	e8730004 	lwi	r3, r19, 4
10004d98:	88651800 	xor	r3, r5, r3
10004d9c:	be030018 	beqid	r3, 24		// 10004db4
10004da0:	e4d30008 	lhui	r6, r19, 8
        OS_EXIT_CRITICAL();
10004da4:	b9f431b8 	brlid	r15, 12728	// 10007f5c <OS_CPU_SR_Restore>
10004da8:	10b60000 	addk	r5, r22, r0
        return (OS_ERR_NOT_MUTEX_OWNER);
10004dac:	b81000c8 	brid	200		// 10004e74
10004db0:	30600064 	addik	r3, r0, 100	// 64 <STK_OFFSET_R27>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
10004db4:	e0650036 	lbui	r3, r5, 54
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
10004db8:	67060008 	bsrli	r24, r6, 8
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
10004dbc:	8863c000 	xor	r3, r3, r24
10004dc0:	be230014 	bneid	r3, 20		// 10004dd4
10004dc4:	64780402 	bslli	r3, r24, 2
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
10004dc8:	b9f4f834 	brlid	r15, -1996	// 100045fc <OSMutex_RdyAtPrio>
10004dcc:	a4c600ff 	andi	r6, r6, 255
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
10004dd0:	64780402 	bslli	r3, r24, 2
10004dd4:	30800001 	addik	r4, r0, 1
10004dd8:	b0001000 	imm	4096
10004ddc:	f883e0a4 	swi	r4, r3, -8028
    if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
10004de0:	e2f3000a 	lbui	r23, r19, 10
10004de4:	be170078 	beqid	r23, 120		// 10004e5c
10004de8:	10b60000 	addk	r5, r22, r0
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
10004dec:	10c00000 	addk	r6, r0, r0
10004df0:	10b30000 	addk	r5, r19, r0
10004df4:	11060000 	addk	r8, r6, r0
10004df8:	b9f4d600 	brlid	r15, -10752	// 100023f8 <OS_EventTaskRdy>
10004dfc:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
10004e00:	e4930008 	lhui	r4, r19, 8
        pevent->OSEventCnt |= prio;
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
10004e04:	10b60000 	addk	r5, r22, r0
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
    if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
10004e08:	a484ff00 	andi	r4, r4, -256
        pevent->OSEventCnt |= prio;
10004e0c:	80832000 	or	r4, r3, r4
10004e10:	f4930008 	shi	r4, r19, 8
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
10004e14:	64830402 	bslli	r4, r3, 2
10004e18:	b0001000 	imm	4096
10004e1c:	e884e0a4 	lwi	r4, r4, -8028
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
10004e20:	1463c003 	cmpu	r3, r3, r24
10004e24:	be430020 	bltid	r3, 32		// 10004e44
10004e28:	f8930004 	swi	r4, r19, 4
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
10004e2c:	b9f43130 	brlid	r15, 12592	// 10007f5c <OS_CPU_SR_Restore>
10004e30:	80000000 	or	r0, r0, r0
            OS_Sched();                               /*      Find highest priority task ready to run  */
10004e34:	b9f4d98c 	brlid	r15, -9844	// 100027c0 <OS_Sched>
10004e38:	80000000 	or	r0, r0, r0
            return (OS_ERR_PIP_LOWER);
10004e3c:	b8100038 	brid	56		// 10004e74
10004e40:	30600078 	addik	r3, r0, 120	// 78 <STK_CTX_SIZE>
        } else {
            OS_EXIT_CRITICAL();
10004e44:	b9f43118 	brlid	r15, 12568	// 10007f5c <OS_CPU_SR_Restore>
10004e48:	80000000 	or	r0, r0, r0
            OS_Sched();                               /*      Find highest priority task ready to run  */
10004e4c:	b9f4d974 	brlid	r15, -9868	// 100027c0 <OS_Sched>
10004e50:	80000000 	or	r0, r0, r0
            return (OS_ERR_NONE);
10004e54:	b8100020 	brid	32		// 10004e74
10004e58:	10600000 	addk	r3, r0, r0
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
10004e5c:	e4730008 	lhui	r3, r19, 8
    pevent->OSEventPtr  = (void *)0;
10004e60:	faf30004 	swi	r23, r19, 4
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
            return (OS_ERR_NONE);
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
10004e64:	a06300ff 	ori	r3, r3, 255
    pevent->OSEventPtr  = (void *)0;
    OS_EXIT_CRITICAL();
10004e68:	b9f430f4 	brlid	r15, 12532	// 10007f5c <OS_CPU_SR_Restore>
10004e6c:	f4730008 	shi	r3, r19, 8
    return (OS_ERR_NONE);
10004e70:	10770000 	addk	r3, r23, r0
}
10004e74:	e9e10000 	lwi	r15, r1, 0
10004e78:	ea61001c 	lwi	r19, r1, 28
10004e7c:	eac10020 	lwi	r22, r1, 32
10004e80:	eae10024 	lwi	r23, r1, 36
10004e84:	eb010028 	lwi	r24, r1, 40
10004e88:	b60f0008 	rtsd	r15, 8
10004e8c:	3021002c 	addik	r1, r1, 44

10004e90 <OSMutexQuery>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10004e90:	b0001000 	imm	4096
10004e94:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
*/

#if OS_MUTEX_QUERY_EN > 0u
INT8U  OSMutexQuery (OS_EVENT       *pevent, 
                     OS_MUTEX_DATA  *p_mutex_data)
{
10004e98:	3021ffd8 	addik	r1, r1, -40
10004e9c:	fa61001c 	swi	r19, r1, 28
10004ea0:	fac10020 	swi	r22, r1, 32
10004ea4:	f9e10000 	swi	r15, r1, 0
10004ea8:	fae10024 	swi	r23, r1, 36
10004eac:	12650000 	addk	r19, r5, r0
10004eb0:	12c60000 	addk	r22, r6, r0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10004eb4:	be240070 	bneid	r4, 112		// 10004f24
10004eb8:	30600006 	addik	r3, r0, 6
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
10004ebc:	e2e50000 	lbui	r23, r5, 0
10004ec0:	aaf70004 	xori	r23, r23, 4
10004ec4:	be370060 	bneid	r23, 96		// 10004f24
10004ec8:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10004ecc:	b9f43060 	brlid	r15, 12384	// 10007f2c <OS_CPU_SR_Save>
10004ed0:	80000000 	or	r0, r0, r0
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8u);
10004ed4:	e4930008 	lhui	r4, r19, 8
10004ed8:	64840008 	bsrli	r4, r4, 8
10004edc:	f096000b 	sbi	r4, r22, 11
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
10004ee0:	e0930009 	lbui	r4, r19, 9
10004ee4:	f096000a 	sbi	r4, r22, 10
    if (p_mutex_data->OSOwnerPrio == 0xFFu) {
10004ee8:	a88400ff 	xori	r4, r4, 255
        p_mutex_data->OSValue = OS_TRUE;
10004eec:	8884bc00 	pcmpeq	r4, r4, r23
10004ef0:	f0960009 	sbi	r4, r22, 9
    } else {
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
10004ef4:	e093000a 	lbui	r4, r19, 10
    psrc                      = &pevent->OSEventTbl[0];
10004ef8:	3273000b 	addik	r19, r19, 11
    if (p_mutex_data->OSOwnerPrio == 0xFFu) {
        p_mutex_data->OSValue = OS_TRUE;
    } else {
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
10004efc:	f0960008 	sbi	r4, r22, 8
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
10004f00:	10970000 	addk	r4, r23, r0
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
10004f04:	c0a49800 	lbu	r5, r4, r19
10004f08:	d0a4b000 	sb	r5, r4, r22
10004f0c:	30840001 	addik	r4, r4, 1
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
10004f10:	aae40008 	xori	r23, r4, 8
10004f14:	bc37fff0 	bnei	r23, -16		// 10004f04
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
10004f18:	b9f43044 	brlid	r15, 12356	// 10007f5c <OS_CPU_SR_Restore>
10004f1c:	10a30000 	addk	r5, r3, r0
    return (OS_ERR_NONE);
10004f20:	10770000 	addk	r3, r23, r0
}
10004f24:	e9e10000 	lwi	r15, r1, 0
10004f28:	ea61001c 	lwi	r19, r1, 28
10004f2c:	eac10020 	lwi	r22, r1, 32
10004f30:	eae10024 	lwi	r23, r1, 36
10004f34:	b60f0008 	rtsd	r15, 8
10004f38:	30210028 	addik	r1, r1, 40

10004f3c <OSQAccept>:
*/

#if OS_Q_ACCEPT_EN > 0u
void  *OSQAccept (OS_EVENT  *pevent, 
                  INT8U     *perr)
{
10004f3c:	3021ffdc 	addik	r1, r1, -36
10004f40:	fa61001c 	swi	r19, r1, 28
10004f44:	fac10020 	swi	r22, r1, 32
10004f48:	f9e10000 	swi	r15, r1, 0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
10004f4c:	e0650000 	lbui	r3, r5, 0
*/

#if OS_Q_ACCEPT_EN > 0u
void  *OSQAccept (OS_EVENT  *pevent, 
                  INT8U     *perr)
{
10004f50:	12650000 	addk	r19, r5, r0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
10004f54:	a8630002 	xori	r3, r3, 2
10004f58:	be030018 	beqid	r3, 24		// 10004f70
10004f5c:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_EVENT_TYPE;
10004f60:	30600001 	addik	r3, r0, 1
10004f64:	f0660000 	sbi	r3, r6, 0
        return ((void *)0);
10004f68:	b8100064 	brid	100		// 10004fcc
10004f6c:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
10004f70:	b9f42fbc 	brlid	r15, 12220	// 10007f2c <OS_CPU_SR_Save>
10004f74:	80000000 	or	r0, r0, r0
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
10004f78:	e8930004 	lwi	r4, r19, 4
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
10004f7c:	e4e40016 	lhui	r7, r4, 22
10004f80:	be07003c 	beqid	r7, 60		// 10004fbc
10004f84:	12670000 	addk	r19, r7, r0
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
10004f88:	e8a40010 	lwi	r5, r4, 16
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
10004f8c:	e8c40008 	lwi	r6, r4, 8
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
10004f90:	30e7ffff 	addik	r7, r7, -1
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
10004f94:	ea650000 	lwi	r19, r5, 0
10004f98:	30a50004 	addik	r5, r5, 4
10004f9c:	f8a40010 	swi	r5, r4, 16
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
10004fa0:	88a53000 	xor	r5, r5, r6
10004fa4:	be250010 	bneid	r5, 16		// 10004fb4
10004fa8:	f4e40016 	shi	r7, r4, 22
            pq->OSQOut = pq->OSQStart;
10004fac:	e8a40004 	lwi	r5, r4, 4
10004fb0:	f8a40010 	swi	r5, r4, 16
        }
        *perr = OS_ERR_NONE;
10004fb4:	b8100010 	brid	16		// 10004fc4
10004fb8:	f0160000 	sbi	r0, r22, 0
    } else {
        *perr = OS_ERR_Q_EMPTY;
10004fbc:	3080001f 	addik	r4, r0, 31
10004fc0:	f0960000 	sbi	r4, r22, 0
        pmsg  = (void *)0;                       /* Queue is empty                                     */
    }
    OS_EXIT_CRITICAL();
10004fc4:	b9f42f98 	brlid	r15, 12184	// 10007f5c <OS_CPU_SR_Restore>
10004fc8:	10a30000 	addk	r5, r3, r0
    return (pmsg);                               /* Return message received (or NULL)                  */
}
10004fcc:	10730000 	addk	r3, r19, r0
10004fd0:	e9e10000 	lwi	r15, r1, 0
10004fd4:	ea61001c 	lwi	r19, r1, 28
10004fd8:	eac10020 	lwi	r22, r1, 32
10004fdc:	b60f0008 	rtsd	r15, 8
10004fe0:	30210024 	addik	r1, r1, 36

10004fe4 <OSQCreate>:
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif

    if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
10004fe4:	b0001000 	imm	4096
10004fe8:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void    **start,
                      INT16U    size)
{
10004fec:	3021ffd4 	addik	r1, r1, -44
10004ff0:	fa61001c 	swi	r19, r1, 28
10004ff4:	fae10024 	swi	r23, r1, 36
10004ff8:	fb010028 	swi	r24, r1, 40
10004ffc:	f9e10000 	swi	r15, r1, 0
10005000:	fac10020 	swi	r22, r1, 32
10005004:	12e50000 	addk	r23, r5, r0
10005008:	13060000 	addk	r24, r6, r0
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif

    if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
1000500c:	be2300cc 	bneid	r3, 204		// 100050d8
10005010:	12600000 	addk	r19, r0, r0
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
10005014:	b9f42f18 	brlid	r15, 12056	// 10007f2c <OS_CPU_SR_Save>
10005018:	80000000 	or	r0, r0, r0
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
1000501c:	b0001000 	imm	4096
10005020:	ea60d604 	lwi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
10005024:	bc130010 	beqi	r19, 16		// 10005034
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
10005028:	e8930004 	lwi	r4, r19, 4
1000502c:	b0001000 	imm	4096
10005030:	f880d604 	swi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
    }
    OS_EXIT_CRITICAL();
10005034:	b9f42f28 	brlid	r15, 12072	// 10007f5c <OS_CPU_SR_Restore>
10005038:	10a30000 	addk	r5, r3, r0
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
1000503c:	be1300a0 	beqid	r19, 160		// 100050dc
10005040:	10730000 	addk	r3, r19, r0
        OS_ENTER_CRITICAL();
10005044:	b9f42ee8 	brlid	r15, 12008	// 10007f2c <OS_CPU_SR_Save>
10005048:	80000000 	or	r0, r0, r0
        pq = OSQFreeList;                        /* Get a free queue control block                     */
1000504c:	b0001000 	imm	4096
10005050:	eac0d3f4 	lwi	r22, r0, -11276	// 1000d3f4 <OSQFreeList>
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
10005054:	be160068 	beqid	r22, 104		// 100050bc
10005058:	10a30000 	addk	r5, r3, r0
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
1000505c:	e8760000 	lwi	r3, r22, 0
10005060:	b0001000 	imm	4096
10005064:	f860d3f4 	swi	r3, r0, -11276	// 1000d3f4 <OSQFreeList>
            OS_EXIT_CRITICAL();
10005068:	b9f42ef4 	brlid	r15, 12020	// 10007f5c <OS_CPU_SR_Restore>
1000506c:	80000000 	or	r0, r0, r0
            pq->OSQStart           = start;               /*      Initialize the queue                 */
            pq->OSQEnd             = &start[size];
10005070:	64780402 	bslli	r3, r24, 2
10005074:	10771800 	addk	r3, r23, r3
10005078:	f8760008 	swi	r3, r22, 8
        OS_ENTER_CRITICAL();
        pq = OSQFreeList;                        /* Get a free queue control block                     */
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
1000507c:	faf60004 	swi	r23, r22, 4
            pq->OSQEnd             = &start[size];
            pq->OSQIn              = start;
10005080:	faf6000c 	swi	r23, r22, 12
            pq->OSQOut             = start;
10005084:	faf60010 	swi	r23, r22, 16
            pq->OSQSize            = size;
10005088:	f7160014 	shi	r24, r22, 20
            pq->OSQEntries         = 0u;
1000508c:	f4160016 	shi	r0, r22, 22
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
10005090:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
10005094:	f0730000 	sbi	r3, r19, 0
            pevent->OSEventCnt     = 0u;
            pevent->OSEventPtr     = pq;
#if OS_EVENT_NAME_EN > 0u
            pevent->OSEventName    = (INT8U *)"?";
10005098:	b0001000 	imm	4096
1000509c:	30608b04 	addik	r3, r0, -29948
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
100050a0:	10b30000 	addk	r5, r19, r0
            pq->OSQIn              = start;
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0u;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
            pevent->OSEventCnt     = 0u;
100050a4:	f4130008 	shi	r0, r19, 8
            pevent->OSEventPtr     = pq;
100050a8:	fad30004 	swi	r22, r19, 4
#if OS_EVENT_NAME_EN > 0u
            pevent->OSEventName    = (INT8U *)"?";
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
100050ac:	b9f4d42c 	brlid	r15, -11220	// 100024d8 <OS_EventWaitListInit>
100050b0:	f8730014 	swi	r3, r19, 20
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
        }
    }
    return (pevent);
}
100050b4:	b8100028 	brid	40		// 100050dc
100050b8:	10730000 	addk	r3, r19, r0
#if OS_EVENT_NAME_EN > 0u
            pevent->OSEventName    = (INT8U *)"?";
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
100050bc:	b0001000 	imm	4096
100050c0:	e860d604 	lwi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
            OSEventFreeList    = pevent;
100050c4:	b0001000 	imm	4096
100050c8:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
#if OS_EVENT_NAME_EN > 0u
            pevent->OSEventName    = (INT8U *)"?";
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
100050cc:	f8730004 	swi	r3, r19, 4
            OSEventFreeList    = pevent;
            OS_EXIT_CRITICAL();
100050d0:	b9f42e8c 	brlid	r15, 11916	// 10007f5c <OS_CPU_SR_Restore>
100050d4:	12760000 	addk	r19, r22, r0
            pevent = (OS_EVENT *)0;
        }
    }
    return (pevent);
}
100050d8:	10730000 	addk	r3, r19, r0
100050dc:	e9e10000 	lwi	r15, r1, 0
100050e0:	ea61001c 	lwi	r19, r1, 28
100050e4:	eac10020 	lwi	r22, r1, 32
100050e8:	eae10024 	lwi	r23, r1, 36
100050ec:	eb010028 	lwi	r24, r1, 40
100050f0:	b60f0008 	rtsd	r15, 8
100050f4:	3021002c 	addik	r1, r1, 44

100050f8 <OSQDel>:

#if OS_Q_DEL_EN > 0u
OS_EVENT  *OSQDel (OS_EVENT  *pevent, 
                   INT8U      opt, 
                   INT8U     *perr)
{
100050f8:	3021ffcc 	addik	r1, r1, -52
100050fc:	fa61001c 	swi	r19, r1, 28
10005100:	fac10020 	swi	r22, r1, 32
10005104:	fb410030 	swi	r26, r1, 48
10005108:	f9e10000 	swi	r15, r1, 0
1000510c:	fae10024 	swi	r23, r1, 36
10005110:	fb010028 	swi	r24, r1, 40
10005114:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
10005118:	e0650000 	lbui	r3, r5, 0

#if OS_Q_DEL_EN > 0u
OS_EVENT  *OSQDel (OS_EVENT  *pevent, 
                   INT8U      opt, 
                   INT8U     *perr)
{
1000511c:	12650000 	addk	r19, r5, r0
10005120:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
10005124:	a8630002 	xori	r3, r3, 2
10005128:	be030010 	beqid	r3, 16		// 10005138
1000512c:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10005130:	b8100134 	brid	308		// 10005264
10005134:	30600001 	addik	r3, r0, 1
        return (pevent);
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10005138:	b0001000 	imm	4096
1000513c:	e300d608 	lbui	r24, r0, -10744	// 1000d608 <OSIntNesting>
10005140:	be380124 	bneid	r24, 292		// 10005264
10005144:	3060000f 	addik	r3, r0, 15
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10005148:	b9f42de4 	brlid	r15, 11748	// 10007f2c <OS_CPU_SR_Save>
1000514c:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10005150:	e333000a 	lbui	r25, r19, 10
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10005154:	12e30000 	addk	r23, r3, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10005158:	8f39c400 	pcmpne	r25, r25, r24
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
1000515c:	be1a0014 	beqid	r26, 20		// 10005170
10005160:	13190000 	addk	r24, r25, r0
10005164:	ab5a0001 	xori	r26, r26, 1
10005168:	bc1a0080 	beqi	r26, 128		// 100051e8
1000516c:	b80000ec 	bri	236		// 10005258
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
10005170:	bc390058 	bnei	r25, 88		// 100051c8
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName    = (INT8U *)"?";
10005174:	b0001000 	imm	4096
10005178:	30608b04 	addik	r3, r0, -29948
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
1000517c:	b0001000 	imm	4096
10005180:	e880d3f4 	lwi	r4, r0, -11276	// 1000d3f4 <OSQFreeList>
                 OSQFreeList            = pq;
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
                 pevent->OSEventCnt     = 0u;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
10005184:	10b70000 	addk	r5, r23, r0
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName    = (INT8U *)"?";
10005188:	f8730014 	swi	r3, r19, 20
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
1000518c:	e8730004 	lwi	r3, r19, 4
                 pq->OSQPtr             = OSQFreeList;
10005190:	f8830000 	swi	r4, r3, 0
                 OSQFreeList            = pq;
10005194:	b0001000 	imm	4096
10005198:	f860d3f4 	swi	r3, r0, -11276	// 1000d3f4 <OSQFreeList>
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
1000519c:	f3330000 	sbi	r25, r19, 0
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
100051a0:	b0001000 	imm	4096
100051a4:	e860d604 	lwi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
                 pevent->OSEventCnt     = 0u;
100051a8:	f7330008 	shi	r25, r19, 8
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
100051ac:	b0001000 	imm	4096
100051b0:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
                 OS_EXIT_CRITICAL();
100051b4:	b9f42da8 	brlid	r15, 11688	// 10007f5c <OS_CPU_SR_Restore>
100051b8:	f8730004 	swi	r3, r19, 4
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
100051bc:	12790000 	addk	r19, r25, r0
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
                 pevent->OSEventCnt     = 0u;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
100051c0:	b81000a8 	brid	168		// 10005268
100051c4:	f3360000 	sbi	r25, r22, 0
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
100051c8:	b9f42d94 	brlid	r15, 11668	// 10007f5c <OS_CPU_SR_Restore>
100051cc:	10a30000 	addk	r5, r3, r0
                 *perr                  = OS_ERR_TASK_WAITING;
100051d0:	b8100094 	brid	148		// 10005264
100051d4:	30600049 	addik	r3, r0, 73
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
100051d8:	10b30000 	addk	r5, r19, r0
100051dc:	11060000 	addk	r8, r6, r0
100051e0:	b9f4d218 	brlid	r15, -11752	// 100023f8 <OS_EventTaskRdy>
100051e4:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
100051e8:	e073000a 	lbui	r3, r19, 10
100051ec:	be23ffec 	bneid	r3, -20		// 100051d8
100051f0:	10c00000 	addk	r6, r0, r0
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
100051f4:	b0001000 	imm	4096
100051f8:	30808b04 	addik	r4, r0, -29948
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
100051fc:	b0001000 	imm	4096
10005200:	e8a0d3f4 	lwi	r5, r0, -11276	// 1000d3f4 <OSQFreeList>
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
10005204:	ab180001 	xori	r24, r24, 1
        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
10005208:	f8930014 	swi	r4, r19, 20
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
1000520c:	e8930004 	lwi	r4, r19, 4
             pq->OSQPtr             = OSQFreeList;
10005210:	f8a40000 	swi	r5, r4, 0
             OSQFreeList            = pq;
10005214:	b0001000 	imm	4096
10005218:	f880d3f4 	swi	r4, r0, -11276	// 1000d3f4 <OSQFreeList>
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
1000521c:	f0730000 	sbi	r3, r19, 0
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
10005220:	b0001000 	imm	4096
10005224:	e880d604 	lwi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
             pevent->OSEventCnt     = 0u;
10005228:	f4730008 	shi	r3, r19, 8
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
1000522c:	f8930004 	swi	r4, r19, 4
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
10005230:	b0001000 	imm	4096
10005234:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
             OS_EXIT_CRITICAL();
10005238:	b9f42d24 	brlid	r15, 11556	// 10007f5c <OS_CPU_SR_Restore>
1000523c:	10b70000 	addk	r5, r23, r0
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
10005240:	bc38000c 	bnei	r24, 12		// 1000524c
                 OS_Sched();                               /* Find highest priority task ready to run  */
10005244:	b9f4d57c 	brlid	r15, -10884	// 100027c0 <OS_Sched>
10005248:	80000000 	or	r0, r0, r0
             }
             *perr                  = OS_ERR_NONE;
1000524c:	f0160000 	sbi	r0, r22, 0
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
             break;
10005250:	b8100018 	brid	24		// 10005268
10005254:	12600000 	addk	r19, r0, r0

        default:
             OS_EXIT_CRITICAL();
10005258:	b9f42d04 	brlid	r15, 11524	// 10007f5c <OS_CPU_SR_Restore>
1000525c:	10a30000 	addk	r5, r3, r0
             *perr                  = OS_ERR_INVALID_OPT;
10005260:	30600007 	addik	r3, r0, 7
10005264:	f0760000 	sbi	r3, r22, 0
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
10005268:	10730000 	addk	r3, r19, r0
1000526c:	e9e10000 	lwi	r15, r1, 0
10005270:	ea61001c 	lwi	r19, r1, 28
10005274:	eac10020 	lwi	r22, r1, 32
10005278:	eae10024 	lwi	r23, r1, 36
1000527c:	eb010028 	lwi	r24, r1, 40
10005280:	eb21002c 	lwi	r25, r1, 44
10005284:	eb410030 	lwi	r26, r1, 48
10005288:	b60f0008 	rtsd	r15, 8
1000528c:	30210034 	addik	r1, r1, 52

10005290 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0u
INT8U  OSQFlush (OS_EVENT *pevent)
{
10005290:	3021ffe0 	addik	r1, r1, -32
10005294:	fa61001c 	swi	r19, r1, 28
10005298:	f9e10000 	swi	r15, r1, 0
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
1000529c:	b9f42c90 	brlid	r15, 11408	// 10007f2c <OS_CPU_SR_Save>
100052a0:	12650000 	addk	r19, r5, r0
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
100052a4:	e8930004 	lwi	r4, r19, 4
    pq->OSQIn      = pq->OSQStart;
100052a8:	e8a40004 	lwi	r5, r4, 4
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0u;
100052ac:	f4040016 	shi	r0, r4, 22
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    pq->OSQIn      = pq->OSQStart;
100052b0:	f8a4000c 	swi	r5, r4, 12
    pq->OSQOut     = pq->OSQStart;
100052b4:	f8a40010 	swi	r5, r4, 16
    pq->OSQEntries = 0u;
    OS_EXIT_CRITICAL();
100052b8:	b9f42ca4 	brlid	r15, 11428	// 10007f5c <OS_CPU_SR_Restore>
100052bc:	10a30000 	addk	r5, r3, r0
    return (OS_ERR_NONE);
}
100052c0:	e9e10000 	lwi	r15, r1, 0
100052c4:	ea61001c 	lwi	r19, r1, 28
100052c8:	10600000 	addk	r3, r0, r0
100052cc:	b60f0008 	rtsd	r15, 8
100052d0:	30210020 	addik	r1, r1, 32

100052d4 <OSQPend>:
*/

void  *OSQPend (OS_EVENT  *pevent, 
                INT32U     timeout, 
                INT8U     *perr)
{
100052d4:	3021ffcc 	addik	r1, r1, -52
100052d8:	fac10020 	swi	r22, r1, 32
100052dc:	fb010028 	swi	r24, r1, 40
100052e0:	fb410030 	swi	r26, r1, 48
100052e4:	f9e10000 	swi	r15, r1, 0
100052e8:	fa61001c 	swi	r19, r1, 28
100052ec:	fae10024 	swi	r23, r1, 36
100052f0:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
100052f4:	e2650000 	lbui	r19, r5, 0
*/

void  *OSQPend (OS_EVENT  *pevent, 
                INT32U     timeout, 
                INT8U     *perr)
{
100052f8:	13050000 	addk	r24, r5, r0
100052fc:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *perr = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
10005300:	aa730002 	xori	r19, r19, 2
10005304:	be130018 	beqid	r19, 24		// 1000531c
10005308:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
1000530c:	30600001 	addik	r3, r0, 1
10005310:	f0670000 	sbi	r3, r7, 0
        return ((void *)0);
10005314:	b8100140 	brid	320		// 10005454
10005318:	12600000 	addk	r19, r0, r0
    }
    if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
1000531c:	b0001000 	imm	4096
10005320:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10005324:	be030010 	beqid	r3, 16		// 10005334
10005328:	30800002 	addik	r4, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
        return ((void *)0);
1000532c:	b8100128 	brid	296		// 10005454
10005330:	f0870000 	sbi	r4, r7, 0
    }
    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
10005334:	b0001000 	imm	4096
10005338:	e080ce10 	lbui	r4, r0, -12784	// 1000ce10 <OSLockNesting>
1000533c:	be040014 	beqid	r4, 20		// 10005350
10005340:	3080000d 	addik	r4, r0, 13
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
10005344:	f0870000 	sbi	r4, r7, 0
        return ((void *)0);
10005348:	b810010c 	brid	268		// 10005454
1000534c:	12630000 	addk	r19, r3, r0
    }
    OS_ENTER_CRITICAL();
10005350:	b9f42bdc 	brlid	r15, 11228	// 10007f2c <OS_CPU_SR_Save>
10005354:	80000000 	or	r0, r0, r0
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
10005358:	e8980004 	lwi	r4, r24, 4
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
1000535c:	e6e40016 	lhui	r23, r4, 22
10005360:	be170044 	beqid	r23, 68		// 100053a4
10005364:	13230000 	addk	r25, r3, r0
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
10005368:	e8640010 	lwi	r3, r4, 16
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
1000536c:	e8a40008 	lwi	r5, r4, 8
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
10005370:	32f7ffff 	addik	r23, r23, -1
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
10005374:	ea630000 	lwi	r19, r3, 0
10005378:	30630004 	addik	r3, r3, 4
1000537c:	f8640010 	swi	r3, r4, 16
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
10005380:	88632800 	xor	r3, r3, r5
10005384:	be230010 	bneid	r3, 16		// 10005394
10005388:	f6e40016 	shi	r23, r4, 22
            pq->OSQOut = pq->OSQStart;
1000538c:	e8640004 	lwi	r3, r4, 4
10005390:	f8640010 	swi	r3, r4, 16
        }
        OS_EXIT_CRITICAL();
10005394:	b9f42bc8 	brlid	r15, 11208	// 10007f5c <OS_CPU_SR_Restore>
10005398:	10b90000 	addk	r5, r25, r0
        *perr = OS_ERR_NONE;
        return (pmsg);                           /* Return message received                            */
1000539c:	b81000b8 	brid	184		// 10005454
100053a0:	f0160000 	sbi	r0, r22, 0
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
100053a4:	b0001000 	imm	4096
100053a8:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
100053ac:	10b80000 	addk	r5, r24, r0
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return (pmsg);                           /* Return message received                            */
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
100053b0:	e0640034 	lbui	r3, r4, 52
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
100053b4:	f2e40035 	sbi	r23, r4, 53
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
100053b8:	fb440030 	swi	r26, r4, 48
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return (pmsg);                           /* Return message received                            */
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
100053bc:	a0630004 	ori	r3, r3, 4
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
100053c0:	b9f4cea4 	brlid	r15, -12636	// 10002264 <OS_EventTaskWait>
100053c4:	f0640034 	sbi	r3, r4, 52
    OS_EXIT_CRITICAL();
100053c8:	b9f42b94 	brlid	r15, 11156	// 10007f5c <OS_CPU_SR_Restore>
100053cc:	10b90000 	addk	r5, r25, r0
    OS_Sched();                                  /* Find next highest priority task ready to run       */
100053d0:	b9f4d3f0 	brlid	r15, -11280	// 100027c0 <OS_Sched>
100053d4:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
100053d8:	b9f42b54 	brlid	r15, 11092	// 10007f2c <OS_CPU_SR_Save>
100053dc:	80000000 	or	r0, r0, r0
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
100053e0:	b0001000 	imm	4096
100053e4:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
100053e8:	e0c40035 	lbui	r6, r4, 53
100053ec:	be06001c 	beqid	r6, 28		// 10005408
100053f0:	13230000 	addk	r25, r3, r0
100053f4:	aa660002 	xori	r19, r6, 2
100053f8:	be13001c 	beqid	r19, 28		// 10005414
100053fc:	3060000e 	addik	r3, r0, 14
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
10005400:	b810001c 	brid	28		// 1000541c
10005404:	10a40000 	addk	r5, r4, r0
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
10005408:	ea640024 	lwi	r19, r4, 36
            *perr =  OS_ERR_NONE;
             break;
1000540c:	b8100024 	brid	36		// 10005430
10005410:	f0d60000 	sbi	r6, r22, 0

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;
10005414:	b810001c 	brid	28		// 10005430
10005418:	f0760000 	sbi	r3, r22, 0

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
1000541c:	10d80000 	addk	r6, r24, r0
10005420:	b9f4cf4c 	brlid	r15, -12468	// 1000236c <OS_EventTaskRemove>
10005424:	12770000 	addk	r19, r23, r0
             pmsg = (void *)0;
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
10005428:	3080000a 	addik	r4, r0, 10
1000542c:	f0960000 	sbi	r4, r22, 0
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10005430:	b0001000 	imm	4096
10005434:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    OS_EXIT_CRITICAL();
10005438:	10b90000 	addk	r5, r25, r0
             OS_EventTaskRemove(OSTCBCur, pevent);
             pmsg = (void *)0;
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
1000543c:	f0040034 	sbi	r0, r4, 52
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
10005440:	f0040035 	sbi	r0, r4, 53
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
10005444:	f804001c 	swi	r0, r4, 28
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
10005448:	f8040020 	swi	r0, r4, 32
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    OS_EXIT_CRITICAL();
1000544c:	b9f42b10 	brlid	r15, 11024	// 10007f5c <OS_CPU_SR_Restore>
10005450:	f8040024 	swi	r0, r4, 36
    return (pmsg);                                    /* Return received message                       */
}
10005454:	10730000 	addk	r3, r19, r0
10005458:	e9e10000 	lwi	r15, r1, 0
1000545c:	ea61001c 	lwi	r19, r1, 28
10005460:	eac10020 	lwi	r22, r1, 32
10005464:	eae10024 	lwi	r23, r1, 36
10005468:	eb010028 	lwi	r24, r1, 40
1000546c:	eb21002c 	lwi	r25, r1, 44
10005470:	eb410030 	lwi	r26, r1, 48
10005474:	b60f0008 	rtsd	r15, 8
10005478:	30210034 	addik	r1, r1, 52

1000547c <OSQPendAbort>:

#if OS_Q_PEND_ABORT_EN > 0u
INT8U  OSQPendAbort (OS_EVENT  *pevent, 
                     INT8U      opt, 
                     INT8U     *perr)
{
1000547c:	3021ffcc 	addik	r1, r1, -52
10005480:	fac10020 	swi	r22, r1, 32
10005484:	fae10024 	swi	r23, r1, 36
10005488:	fb410030 	swi	r26, r1, 48
1000548c:	f9e10000 	swi	r15, r1, 0
10005490:	fa61001c 	swi	r19, r1, 28
10005494:	fb010028 	swi	r24, r1, 40
10005498:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
1000549c:	e3250000 	lbui	r25, r5, 0

#if OS_Q_PEND_ABORT_EN > 0u
INT8U  OSQPendAbort (OS_EVENT  *pevent, 
                     INT8U      opt, 
                     INT8U     *perr)
{
100054a0:	12c50000 	addk	r22, r5, r0
100054a4:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
100054a8:	ab390002 	xori	r25, r25, 2
100054ac:	be190018 	beqid	r25, 24		// 100054c4
100054b0:	12e70000 	addk	r23, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
100054b4:	30600001 	addik	r3, r0, 1
100054b8:	f0670000 	sbi	r3, r7, 0
        return (0u);
100054bc:	b8100090 	brid	144		// 1000554c
100054c0:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
100054c4:	b9f42a68 	brlid	r15, 10856	// 10007f2c <OS_CPU_SR_Save>
100054c8:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
100054cc:	e276000a 	lbui	r19, r22, 10
100054d0:	be130070 	beqid	r19, 112		// 10005540
100054d4:	13030000 	addk	r24, r3, r0
        nbr_tasks = 0u;
        switch (opt) {
100054d8:	aa7a0001 	xori	r19, r26, 1
100054dc:	be130028 	beqid	r19, 40		// 10005504
100054e0:	10b60000 	addk	r5, r22, r0
                 }
                 break;
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
100054e4:	b8100030 	brid	48		// 10005514
100054e8:	10d90000 	addk	r6, r25, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
100054ec:	10b60000 	addk	r5, r22, r0
100054f0:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
100054f4:	31000002 	addik	r8, r0, 2	// 2 <CPU_IE_BIT>
100054f8:	b9f4cf00 	brlid	r15, -12544	// 100023f8 <OS_EventTaskRdy>
100054fc:	32730001 	addik	r19, r19, 1
                     nbr_tasks++;
10005500:	a67300ff 	andi	r19, r19, 255
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
10005504:	e076000a 	lbui	r3, r22, 10
10005508:	be23ffe4 	bneid	r3, -28		// 100054ec
1000550c:	10c00000 	addk	r6, r0, r0
10005510:	b8000014 	bri	20		// 10005524
                 }
                 break;
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
10005514:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
10005518:	b9f4cee0 	brlid	r15, -12576	// 100023f8 <OS_EventTaskRdy>
1000551c:	31000002 	addik	r8, r0, 2	// 2 <CPU_IE_BIT>
                 nbr_tasks++;
10005520:	32600001 	addik	r19, r0, 1
                 break;
        }
        OS_EXIT_CRITICAL();
10005524:	b9f42a38 	brlid	r15, 10808	// 10007f5c <OS_CPU_SR_Restore>
10005528:	10b80000 	addk	r5, r24, r0
        OS_Sched();                                        /* Find HPT ready to run                    */
1000552c:	b9f4d294 	brlid	r15, -11628	// 100027c0 <OS_Sched>
10005530:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_PEND_ABORT;
10005534:	3060000e 	addik	r3, r0, 14
        return (nbr_tasks);
10005538:	b8100014 	brid	20		// 1000554c
1000553c:	f0770000 	sbi	r3, r23, 0
    }
    OS_EXIT_CRITICAL();
10005540:	b9f42a1c 	brlid	r15, 10780	// 10007f5c <OS_CPU_SR_Restore>
10005544:	10a30000 	addk	r5, r3, r0
    *perr = OS_ERR_NONE;
10005548:	f2770000 	sbi	r19, r23, 0
    return (0u);                                           /* No tasks waiting on queue                */
}
1000554c:	10730000 	addk	r3, r19, r0
10005550:	e9e10000 	lwi	r15, r1, 0
10005554:	ea61001c 	lwi	r19, r1, 28
10005558:	eac10020 	lwi	r22, r1, 32
1000555c:	eae10024 	lwi	r23, r1, 36
10005560:	eb010028 	lwi	r24, r1, 40
10005564:	eb21002c 	lwi	r25, r1, 44
10005568:	eb410030 	lwi	r26, r1, 48
1000556c:	b60f0008 	rtsd	r15, 8
10005570:	30210034 	addik	r1, r1, 52

10005574 <OSQPost>:
*/

#if OS_Q_POST_EN > 0u
INT8U  OSQPost (OS_EVENT  *pevent, 
                void      *pmsg)
{
10005574:	3021ffd4 	addik	r1, r1, -44
10005578:	f9e10000 	swi	r15, r1, 0
1000557c:	fa610024 	swi	r19, r1, 36
10005580:	fac10028 	swi	r22, r1, 40
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
10005584:	e2c50000 	lbui	r22, r5, 0
10005588:	aad60002 	xori	r22, r22, 2
1000558c:	be3600a8 	bneid	r22, 168		// 10005634
10005590:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005594:	f8a1001c 	swi	r5, r1, 28
10005598:	b9f42994 	brlid	r15, 10644	// 10007f2c <OS_CPU_SR_Save>
1000559c:	f8c10020 	swi	r6, r1, 32
    if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
100055a0:	e8a1001c 	lwi	r5, r1, 28
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
100055a4:	12630000 	addk	r19, r3, r0
    if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
100055a8:	e065000a 	lbui	r3, r5, 10
100055ac:	be03002c 	beqid	r3, 44		// 100055d8
100055b0:	e8c10020 	lwi	r6, r1, 32
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
100055b4:	11160000 	addk	r8, r22, r0
100055b8:	b9f4ce40 	brlid	r15, -12736	// 100023f8 <OS_EventTaskRdy>
100055bc:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
        OS_EXIT_CRITICAL();
100055c0:	b9f4299c 	brlid	r15, 10652	// 10007f5c <OS_CPU_SR_Restore>
100055c4:	10b30000 	addk	r5, r19, r0
        OS_Sched();                                    /* Find highest priority task ready to run      */
100055c8:	b9f4d1f8 	brlid	r15, -11784	// 100027c0 <OS_Sched>
100055cc:	80000000 	or	r0, r0, r0
        return (OS_ERR_NONE);
100055d0:	b8100064 	brid	100		// 10005634
100055d4:	10760000 	addk	r3, r22, r0
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
100055d8:	e8850004 	lwi	r4, r5, 4
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
100055dc:	e4a40016 	lhui	r5, r4, 22
100055e0:	e4640014 	lhui	r3, r4, 20
100055e4:	14632803 	cmpu	r3, r3, r5
100055e8:	bc430014 	blti	r3, 20		// 100055fc
        OS_EXIT_CRITICAL();
100055ec:	b9f42970 	brlid	r15, 10608	// 10007f5c <OS_CPU_SR_Restore>
100055f0:	10b30000 	addk	r5, r19, r0
        return (OS_ERR_Q_FULL);
100055f4:	b8100040 	brid	64		// 10005634
100055f8:	3060001e 	addik	r3, r0, 30
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
100055fc:	e864000c 	lwi	r3, r4, 12
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
10005600:	30a50001 	addik	r5, r5, 1
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
10005604:	f8c30000 	swi	r6, r3, 0
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
10005608:	f4a40016 	shi	r5, r4, 22
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
1000560c:	e8a40008 	lwi	r5, r4, 8
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
10005610:	30630004 	addik	r3, r3, 4
10005614:	f864000c 	swi	r3, r4, 12
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
10005618:	88632800 	xor	r3, r3, r5
1000561c:	bc23000c 	bnei	r3, 12		// 10005628
        pq->OSQIn = pq->OSQStart;
10005620:	e8640004 	lwi	r3, r4, 4
10005624:	f864000c 	swi	r3, r4, 12
    }
    OS_EXIT_CRITICAL();
10005628:	b9f42934 	brlid	r15, 10548	// 10007f5c <OS_CPU_SR_Restore>
1000562c:	10b30000 	addk	r5, r19, r0
    return (OS_ERR_NONE);
10005630:	10600000 	addk	r3, r0, r0
}
10005634:	e9e10000 	lwi	r15, r1, 0
10005638:	ea610024 	lwi	r19, r1, 36
1000563c:	eac10028 	lwi	r22, r1, 40
10005640:	b60f0008 	rtsd	r15, 8
10005644:	3021002c 	addik	r1, r1, 44

10005648 <OSQPostFront>:
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT  *pevent, 
                     void      *pmsg)
{
10005648:	3021ffd4 	addik	r1, r1, -44
1000564c:	f9e10000 	swi	r15, r1, 0
10005650:	fa610024 	swi	r19, r1, 36
10005654:	fac10028 	swi	r22, r1, 40
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
10005658:	e2c50000 	lbui	r22, r5, 0
1000565c:	aad60002 	xori	r22, r22, 2
10005660:	be3600ac 	bneid	r22, 172		// 1000570c
10005664:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005668:	f8a1001c 	swi	r5, r1, 28
1000566c:	b9f428c0 	brlid	r15, 10432	// 10007f2c <OS_CPU_SR_Save>
10005670:	f8c10020 	swi	r6, r1, 32
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
10005674:	e8a1001c 	lwi	r5, r1, 28
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005678:	12630000 	addk	r19, r3, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
1000567c:	e065000a 	lbui	r3, r5, 10
10005680:	be03002c 	beqid	r3, 44		// 100056ac
10005684:	e8c10020 	lwi	r6, r1, 32
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
10005688:	11160000 	addk	r8, r22, r0
1000568c:	b9f4cd6c 	brlid	r15, -12948	// 100023f8 <OS_EventTaskRdy>
10005690:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
        OS_EXIT_CRITICAL();
10005694:	b9f428c8 	brlid	r15, 10440	// 10007f5c <OS_CPU_SR_Restore>
10005698:	10b30000 	addk	r5, r19, r0
        OS_Sched();                                   /* Find highest priority task ready to run       */
1000569c:	b9f4d124 	brlid	r15, -11996	// 100027c0 <OS_Sched>
100056a0:	80000000 	or	r0, r0, r0
        return (OS_ERR_NONE);
100056a4:	b8100068 	brid	104		// 1000570c
100056a8:	10760000 	addk	r3, r22, r0
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
100056ac:	e8850004 	lwi	r4, r5, 4
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
100056b0:	e4640016 	lhui	r3, r4, 22
100056b4:	e4a40014 	lhui	r5, r4, 20
100056b8:	14a51803 	cmpu	r5, r5, r3
100056bc:	bc450014 	blti	r5, 20		// 100056d0
        OS_EXIT_CRITICAL();
100056c0:	b9f4289c 	brlid	r15, 10396	// 10007f5c <OS_CPU_SR_Restore>
100056c4:	10b30000 	addk	r5, r19, r0
        return (OS_ERR_Q_FULL);
100056c8:	b8100044 	brid	68		// 1000570c
100056cc:	3060001e 	addik	r3, r0, 30
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
100056d0:	e8e40010 	lwi	r7, r4, 16
100056d4:	e8a40004 	lwi	r5, r4, 4
100056d8:	88a72800 	xor	r5, r7, r5
100056dc:	bc25000c 	bnei	r5, 12		// 100056e8
        pq->OSQOut = pq->OSQEnd;
100056e0:	e8a40008 	lwi	r5, r4, 8
100056e4:	f8a40010 	swi	r5, r4, 16
    }
    pq->OSQOut--;
100056e8:	e8a40010 	lwi	r5, r4, 16
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
100056ec:	30630001 	addik	r3, r3, 1
        return (OS_ERR_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
        pq->OSQOut = pq->OSQEnd;
    }
    pq->OSQOut--;
100056f0:	30e5fffc 	addik	r7, r5, -4
100056f4:	f8e40010 	swi	r7, r4, 16
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
100056f8:	f8c5fffc 	swi	r6, r5, -4
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
100056fc:	10b30000 	addk	r5, r19, r0
10005700:	b9f4285c 	brlid	r15, 10332	// 10007f5c <OS_CPU_SR_Restore>
10005704:	f4640016 	shi	r3, r4, 22
    return (OS_ERR_NONE);
10005708:	10600000 	addk	r3, r0, r0
}
1000570c:	e9e10000 	lwi	r15, r1, 0
10005710:	ea610024 	lwi	r19, r1, 36
10005714:	eac10028 	lwi	r22, r1, 40
10005718:	b60f0008 	rtsd	r15, 8
1000571c:	3021002c 	addik	r1, r1, 44

10005720 <OSQPostOpt>:

#if OS_Q_POST_OPT_EN > 0u
INT8U  OSQPostOpt (OS_EVENT  *pevent, 
                   void      *pmsg, 
                   INT8U      opt)
{
10005720:	3021ffd4 	addik	r1, r1, -44
10005724:	fa61001c 	swi	r19, r1, 28
10005728:	fac10020 	swi	r22, r1, 32
1000572c:	fae10024 	swi	r23, r1, 36
10005730:	fb010028 	swi	r24, r1, 40
10005734:	f9e10000 	swi	r15, r1, 0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
10005738:	e0650000 	lbui	r3, r5, 0

#if OS_Q_POST_OPT_EN > 0u
INT8U  OSQPostOpt (OS_EVENT  *pevent, 
                   void      *pmsg, 
                   INT8U      opt)
{
1000573c:	12650000 	addk	r19, r5, r0
10005740:	12e60000 	addk	r23, r6, r0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
10005744:	a8630002 	xori	r3, r3, 2

#if OS_Q_POST_OPT_EN > 0u
INT8U  OSQPostOpt (OS_EVENT  *pevent, 
                   void      *pmsg, 
                   INT8U      opt)
{
10005748:	13070000 	addk	r24, r7, r0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
1000574c:	be230118 	bneid	r3, 280		// 10005864
10005750:	32c00001 	addik	r22, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005754:	b9f427d8 	brlid	r15, 10200	// 10007f2c <OS_CPU_SR_Save>
10005758:	80000000 	or	r0, r0, r0
1000575c:	12c30000 	addk	r22, r3, r0
    if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
10005760:	e073000a 	lbui	r3, r19, 10
10005764:	be030068 	beqid	r3, 104		// 100057cc
10005768:	a5180001 	andi	r8, r24, 1
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
1000576c:	be280024 	bneid	r8, 36		// 10005790
10005770:	10b30000 	addk	r5, r19, r0
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
10005774:	b810002c 	brid	44		// 100057a0
10005778:	10d70000 	addk	r6, r23, r0
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
1000577c:	10b30000 	addk	r5, r19, r0
10005780:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
10005784:	b9f4cc74 	brlid	r15, -13196	// 100023f8 <OS_EventTaskRdy>
10005788:	11000000 	addk	r8, r0, r0
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
1000578c:	e073000a 	lbui	r3, r19, 10
10005790:	be23ffec 	bneid	r3, -20		// 1000577c
10005794:	10d70000 	addk	r6, r23, r0
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
        }
        OS_EXIT_CRITICAL();
10005798:	b8100014 	brid	20		// 100057ac
1000579c:	10b60000 	addk	r5, r22, r0
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
100057a0:	b9f4cc58 	brlid	r15, -13224	// 100023f8 <OS_EventTaskRdy>
100057a4:	30e00004 	addik	r7, r0, 4	// 4 <STK_OFFSET_R02>
        }
        OS_EXIT_CRITICAL();
100057a8:	10b60000 	addk	r5, r22, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
100057ac:	a7180004 	andi	r24, r24, 4
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
        }
        OS_EXIT_CRITICAL();
100057b0:	b9f427ac 	brlid	r15, 10156	// 10007f5c <OS_CPU_SR_Restore>
100057b4:	12c00000 	addk	r22, r0, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
100057b8:	bc3800ac 	bnei	r24, 172		// 10005864
            OS_Sched();                               /* Find highest priority task ready to run       */
100057bc:	b9f4d004 	brlid	r15, -12284	// 100027c0 <OS_Sched>
100057c0:	80000000 	or	r0, r0, r0
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
100057c4:	b81000a4 	brid	164		// 10005868
100057c8:	10760000 	addk	r3, r22, r0
        if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
            OS_Sched();                               /* Find highest priority task ready to run       */
        }
        return (OS_ERR_NONE);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
100057cc:	e8930004 	lwi	r4, r19, 4
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
100057d0:	e4640016 	lhui	r3, r4, 22
100057d4:	e4a40014 	lhui	r5, r4, 20
100057d8:	14a51803 	cmpu	r5, r5, r3
100057dc:	be45001c 	bltid	r5, 28		// 100057f8
100057e0:	a7180002 	andi	r24, r24, 2
        OS_EXIT_CRITICAL();
100057e4:	10b60000 	addk	r5, r22, r0
100057e8:	b9f42774 	brlid	r15, 10100	// 10007f5c <OS_CPU_SR_Restore>
100057ec:	32c0001e 	addik	r22, r0, 30
        return (OS_ERR_Q_FULL);
100057f0:	b8100078 	brid	120		// 10005868
100057f4:	10760000 	addk	r3, r22, r0
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
100057f8:	bc180030 	beqi	r24, 48		// 10005828
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
100057fc:	e8c40010 	lwi	r6, r4, 16
10005800:	e8a40004 	lwi	r5, r4, 4
10005804:	88a62800 	xor	r5, r6, r5
10005808:	bc25000c 	bnei	r5, 12		// 10005814
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
1000580c:	e8a40008 	lwi	r5, r4, 8
10005810:	f8a40010 	swi	r5, r4, 16
        }
        pq->OSQOut--;
10005814:	e8a40010 	lwi	r5, r4, 16
10005818:	30c5fffc 	addik	r6, r5, -4
1000581c:	f8c40010 	swi	r6, r4, 16
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
10005820:	b8100030 	brid	48		// 10005850
10005824:	fae5fffc 	swi	r23, r5, -4
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
10005828:	e8a4000c 	lwi	r5, r4, 12
1000582c:	fae50000 	swi	r23, r5, 0
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
10005830:	e8c40008 	lwi	r6, r4, 8
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        }
        pq->OSQOut--;
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
10005834:	30a50004 	addik	r5, r5, 4
10005838:	f8a4000c 	swi	r5, r4, 12
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
1000583c:	88a53000 	xor	r5, r5, r6
10005840:	be250014 	bneid	r5, 20		// 10005854
10005844:	10b60000 	addk	r5, r22, r0
            pq->OSQIn = pq->OSQStart;
10005848:	e8a40004 	lwi	r5, r4, 4
1000584c:	f8a4000c 	swi	r5, r4, 12
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
10005850:	10b60000 	addk	r5, r22, r0
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
            pq->OSQIn = pq->OSQStart;
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
10005854:	30630001 	addik	r3, r3, 1
    OS_EXIT_CRITICAL();
10005858:	b9f42704 	brlid	r15, 9988	// 10007f5c <OS_CPU_SR_Restore>
1000585c:	f4640016 	shi	r3, r4, 22
    return (OS_ERR_NONE);
10005860:	12c00000 	addk	r22, r0, r0
}
10005864:	10760000 	addk	r3, r22, r0
10005868:	e9e10000 	lwi	r15, r1, 0
1000586c:	ea61001c 	lwi	r19, r1, 28
10005870:	eac10020 	lwi	r22, r1, 32
10005874:	eae10024 	lwi	r23, r1, 36
10005878:	eb010028 	lwi	r24, r1, 40
1000587c:	b60f0008 	rtsd	r15, 8
10005880:	3021002c 	addik	r1, r1, 44

10005884 <OSQQuery>:
*/

#if OS_Q_QUERY_EN > 0u
INT8U  OSQQuery (OS_EVENT  *pevent, 
                 OS_Q_DATA *p_q_data)
{
10005884:	3021ffd8 	addik	r1, r1, -40
10005888:	fa61001c 	swi	r19, r1, 28
1000588c:	fac10020 	swi	r22, r1, 32
10005890:	f9e10000 	swi	r15, r1, 0
10005894:	fae10024 	swi	r23, r1, 36
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
10005898:	e2e50000 	lbui	r23, r5, 0
*/

#if OS_Q_QUERY_EN > 0u
INT8U  OSQQuery (OS_EVENT  *pevent, 
                 OS_Q_DATA *p_q_data)
{
1000589c:	12c50000 	addk	r22, r5, r0
100058a0:	12660000 	addk	r19, r6, r0
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
100058a4:	aaf70002 	xori	r23, r23, 2
100058a8:	be370070 	bneid	r23, 112		// 10005918
100058ac:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
100058b0:	b9f4267c 	brlid	r15, 9852	// 10007f2c <OS_CPU_SR_Save>
100058b4:	80000000 	or	r0, r0, r0
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
100058b8:	e096000a 	lbui	r4, r22, 10
    psrc                 = &pevent->OSEventTbl[0];
100058bc:	30d6000b 	addik	r6, r22, 11
    pdest                = &p_q_data->OSEventTbl[0];
100058c0:	30b30008 	addik	r5, r19, 8
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
100058c4:	f0930010 	sbi	r4, r19, 16
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
100058c8:	10970000 	addk	r4, r23, r0
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
100058cc:	c0e43000 	lbu	r7, r4, r6
100058d0:	d0e42800 	sb	r7, r4, r5
100058d4:	30840001 	addik	r4, r4, 1
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
100058d8:	a8e40008 	xori	r7, r4, 8
100058dc:	bc27fff0 	bnei	r7, -16		// 100058cc
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
100058e0:	e8960004 	lwi	r4, r22, 4
    if (pq->OSQEntries > 0u) {
100058e4:	e4c40016 	lhui	r6, r4, 22
100058e8:	bc060014 	beqi	r6, 20		// 100058fc
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
100058ec:	e8a40010 	lwi	r5, r4, 16
100058f0:	e8a50000 	lwi	r5, r5, 0
100058f4:	b810000c 	brid	12		// 10005900
100058f8:	f8b30000 	swi	r5, r19, 0
    } else {
        p_q_data->OSMsg = (void *)0;
100058fc:	f8d30000 	swi	r6, r19, 0
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
10005900:	e4840014 	lhui	r4, r4, 20
    OS_EXIT_CRITICAL();
10005904:	10a30000 	addk	r5, r3, r0
    if (pq->OSQEntries > 0u) {
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
    } else {
        p_q_data->OSMsg = (void *)0;
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
10005908:	f4d30004 	shi	r6, r19, 4
    p_q_data->OSQSize = pq->OSQSize;
    OS_EXIT_CRITICAL();
1000590c:	b9f42650 	brlid	r15, 9808	// 10007f5c <OS_CPU_SR_Restore>
10005910:	f4930006 	shi	r4, r19, 6
    return (OS_ERR_NONE);
10005914:	10600000 	addk	r3, r0, r0
}
10005918:	e9e10000 	lwi	r15, r1, 0
1000591c:	ea61001c 	lwi	r19, r1, 28
10005920:	eac10020 	lwi	r22, r1, 32
10005924:	eae10024 	lwi	r23, r1, 36
10005928:	b60f0008 	rtsd	r15, 8
1000592c:	30210028 	addik	r1, r1, 40

10005930 <OS_QInit>:
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
10005930:	b0001000 	imm	4096
10005934:	30a0d390 	addik	r5, r0, -11376	// 1000d390 <OSQTbl>
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
10005938:	3021ffe4 	addik	r1, r1, -28
1000593c:	f9e10000 	swi	r15, r1, 0
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
10005940:	b9f4cbbc 	brlid	r15, -13380	// 100024fc <OS_MemClr>
10005944:	30c00060 	addik	r6, r0, 96	// 60 <STK_OFFSET_R26>
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0u; i < (OS_MAX_QS - 1u); i++) {        /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
10005948:	b0001000 	imm	4096
1000594c:	3060d390 	addik	r3, r0, -11376	// 1000d390 <OSQTbl>
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    OSQFreeList = &OSQTbl[0];
#endif
}
10005950:	e9e10000 	lwi	r15, r1, 0
    for (i = 0u; i < (OS_MAX_QS - 1u); i++) {        /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
10005954:	b0001000 	imm	4096
10005958:	f800d3d8 	swi	r0, r0, -11304

    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0u; i < (OS_MAX_QS - 1u); i++) {        /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
1000595c:	30830018 	addik	r4, r3, 24
10005960:	b0001000 	imm	4096
10005964:	f880d390 	swi	r4, r0, -11376	// 1000d390 <OSQTbl>
10005968:	30830030 	addik	r4, r3, 48
1000596c:	b0001000 	imm	4096
10005970:	f880d3a8 	swi	r4, r0, -11352
10005974:	30830048 	addik	r4, r3, 72
10005978:	b0001000 	imm	4096
1000597c:	f880d3c0 	swi	r4, r0, -11328
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    OSQFreeList = &OSQTbl[0];
10005980:	b0001000 	imm	4096
10005984:	f860d3f4 	swi	r3, r0, -11276	// 1000d3f4 <OSQFreeList>
#endif
}
10005988:	b60f0008 	rtsd	r15, 8
1000598c:	3021001c 	addik	r1, r1, 28

10005990 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0u
INT16U  OSSemAccept (OS_EVENT *pevent)
{
10005990:	3021ffdc 	addik	r1, r1, -36
10005994:	fa61001c 	swi	r19, r1, 28
10005998:	fac10020 	swi	r22, r1, 32
1000599c:	f9e10000 	swi	r15, r1, 0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
100059a0:	e0650000 	lbui	r3, r5, 0
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0u
INT16U  OSSemAccept (OS_EVENT *pevent)
{
100059a4:	12c50000 	addk	r22, r5, r0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
100059a8:	a8630003 	xori	r3, r3, 3
100059ac:	be230028 	bneid	r3, 40		// 100059d4
100059b0:	12600000 	addk	r19, r0, r0
        return (0u);
    }
    OS_ENTER_CRITICAL();
100059b4:	b9f42578 	brlid	r15, 9592	// 10007f2c <OS_CPU_SR_Save>
100059b8:	80000000 	or	r0, r0, r0
    cnt = pevent->OSEventCnt;
100059bc:	e6760008 	lhui	r19, r22, 8
    if (cnt > 0u) {                                   /* See if resource is available                  */
100059c0:	be13000c 	beqid	r19, 12		// 100059cc
100059c4:	3093ffff 	addik	r4, r19, -1
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
100059c8:	f4960008 	shi	r4, r22, 8
    }
    OS_EXIT_CRITICAL();
100059cc:	b9f42590 	brlid	r15, 9616	// 10007f5c <OS_CPU_SR_Restore>
100059d0:	10a30000 	addk	r5, r3, r0
    return (cnt);                                     /* Return semaphore count                        */
}
100059d4:	10730000 	addk	r3, r19, r0
100059d8:	e9e10000 	lwi	r15, r1, 0
100059dc:	ea61001c 	lwi	r19, r1, 28
100059e0:	eac10020 	lwi	r22, r1, 32
100059e4:	b60f0008 	rtsd	r15, 8
100059e8:	30210024 	addik	r1, r1, 36

100059ec <OSSemCreate>:
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif

    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
100059ec:	b0001000 	imm	4096
100059f0:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
100059f4:	3021ffdc 	addik	r1, r1, -36
100059f8:	fa61001c 	swi	r19, r1, 28
100059fc:	fac10020 	swi	r22, r1, 32
10005a00:	f9e10000 	swi	r15, r1, 0
10005a04:	12c50000 	addk	r22, r5, r0
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
    }
#endif

    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10005a08:	be230058 	bneid	r3, 88		// 10005a60
10005a0c:	12600000 	addk	r19, r0, r0
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    }
    OS_ENTER_CRITICAL();
10005a10:	b9f4251c 	brlid	r15, 9500	// 10007f2c <OS_CPU_SR_Save>
10005a14:	80000000 	or	r0, r0, r0
    pevent = OSEventFreeList;                              /* Get next free event control block        */
10005a18:	b0001000 	imm	4096
10005a1c:	ea60d604 	lwi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
10005a20:	bc130010 	beqi	r19, 16		// 10005a30
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
10005a24:	e8930004 	lwi	r4, r19, 4
10005a28:	b0001000 	imm	4096
10005a2c:	f880d604 	swi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
    }
    OS_EXIT_CRITICAL();
10005a30:	b9f4252c 	brlid	r15, 9516	// 10007f5c <OS_CPU_SR_Restore>
10005a34:	10a30000 	addk	r5, r3, r0
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
10005a38:	be130028 	beqid	r19, 40		// 10005a60
10005a3c:	30600003 	addik	r3, r0, 3
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
10005a40:	f0730000 	sbi	r3, r19, 0
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
#if OS_EVENT_NAME_EN > 0u
        pevent->OSEventName    = (INT8U *)"?";
10005a44:	b0001000 	imm	4096
10005a48:	30608b08 	addik	r3, r0, -29944
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
10005a4c:	10b30000 	addk	r5, r19, r0
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
10005a50:	f6d30008 	shi	r22, r19, 8
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
10005a54:	f8130004 	swi	r0, r19, 4
#if OS_EVENT_NAME_EN > 0u
        pevent->OSEventName    = (INT8U *)"?";
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
10005a58:	b9f4ca80 	brlid	r15, -13696	// 100024d8 <OS_EventWaitListInit>
10005a5c:	f8730014 	swi	r3, r19, 20
    }
    return (pevent);
}
10005a60:	10730000 	addk	r3, r19, r0
10005a64:	e9e10000 	lwi	r15, r1, 0
10005a68:	ea61001c 	lwi	r19, r1, 28
10005a6c:	eac10020 	lwi	r22, r1, 32
10005a70:	b60f0008 	rtsd	r15, 8
10005a74:	30210024 	addik	r1, r1, 36

10005a78 <OSSemDel>:

#if OS_SEM_DEL_EN > 0u
OS_EVENT  *OSSemDel (OS_EVENT  *pevent, 
                     INT8U      opt, 
                     INT8U     *perr)
{
10005a78:	3021ffcc 	addik	r1, r1, -52
10005a7c:	fa61001c 	swi	r19, r1, 28
10005a80:	fac10020 	swi	r22, r1, 32
10005a84:	fb410030 	swi	r26, r1, 48
10005a88:	f9e10000 	swi	r15, r1, 0
10005a8c:	fae10024 	swi	r23, r1, 36
10005a90:	fb010028 	swi	r24, r1, 40
10005a94:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
10005a98:	e0650000 	lbui	r3, r5, 0

#if OS_SEM_DEL_EN > 0u
OS_EVENT  *OSSemDel (OS_EVENT  *pevent, 
                     INT8U      opt, 
                     INT8U     *perr)
{
10005a9c:	12650000 	addk	r19, r5, r0
10005aa0:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        *perr = OS_ERR_PEVENT_NULL;
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
10005aa4:	a8630003 	xori	r3, r3, 3
10005aa8:	be030010 	beqid	r3, 16		// 10005ab8
10005aac:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10005ab0:	b8100104 	brid	260		// 10005bb4
10005ab4:	30600001 	addik	r3, r0, 1
        return (pevent);
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
10005ab8:	b0001000 	imm	4096
10005abc:	e300d608 	lbui	r24, r0, -10744	// 1000d608 <OSIntNesting>
10005ac0:	be3800f4 	bneid	r24, 244		// 10005bb4
10005ac4:	3060000f 	addik	r3, r0, 15
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10005ac8:	b9f42464 	brlid	r15, 9316	// 10007f2c <OS_CPU_SR_Save>
10005acc:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10005ad0:	e333000a 	lbui	r25, r19, 10
    }
    if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
10005ad4:	12e30000 	addk	r23, r3, r0
    if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
10005ad8:	8f39c400 	pcmpne	r25, r25, r24
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
10005adc:	be1a0014 	beqid	r26, 20		// 10005af0
10005ae0:	13190000 	addk	r24, r25, r0
10005ae4:	ab5a0001 	xori	r26, r26, 1
10005ae8:	bc1a0068 	beqi	r26, 104		// 10005b50
10005aec:	b80000bc 	bri	188		// 10005ba8
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
10005af0:	bc390040 	bnei	r25, 64		// 10005b30
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName    = (INT8U *)"?";
10005af4:	b0001000 	imm	4096
10005af8:	30608b08 	addik	r3, r0, -29944
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
10005afc:	f3330000 	sbi	r25, r19, 0
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
                 pevent->OSEventCnt     = 0u;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
10005b00:	10b70000 	addk	r5, r23, r0
    }
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_EN > 0u
                 pevent->OSEventName    = (INT8U *)"?";
10005b04:	f8730014 	swi	r3, r19, 20
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
10005b08:	b0001000 	imm	4096
10005b0c:	e860d604 	lwi	r3, r0, -10748	// 1000d604 <OSEventFreeList>
                 pevent->OSEventCnt     = 0u;
10005b10:	f7330008 	shi	r25, r19, 8
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
10005b14:	b0001000 	imm	4096
10005b18:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
                 OS_EXIT_CRITICAL();
10005b1c:	b9f42440 	brlid	r15, 9280	// 10007f5c <OS_CPU_SR_Restore>
10005b20:	f8730004 	swi	r3, r19, 4
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
10005b24:	12790000 	addk	r19, r25, r0
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
                 pevent->OSEventCnt     = 0u;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
10005b28:	b8100090 	brid	144		// 10005bb8
10005b2c:	f3360000 	sbi	r25, r22, 0
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
10005b30:	b9f4242c 	brlid	r15, 9260	// 10007f5c <OS_CPU_SR_Restore>
10005b34:	10a30000 	addk	r5, r3, r0
                 *perr                  = OS_ERR_TASK_WAITING;
10005b38:	b810007c 	brid	124		// 10005bb4
10005b3c:	30600049 	addik	r3, r0, 73
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
10005b40:	10b30000 	addk	r5, r19, r0
10005b44:	11060000 	addk	r8, r6, r0
10005b48:	b9f4c8b0 	brlid	r15, -14160	// 100023f8 <OS_EventTaskRdy>
10005b4c:	30e00001 	addik	r7, r0, 1
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
10005b50:	e073000a 	lbui	r3, r19, 10
10005b54:	be23ffec 	bneid	r3, -20		// 10005b40
10005b58:	10c00000 	addk	r6, r0, r0
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
10005b5c:	b0001000 	imm	4096
10005b60:	30808b08 	addik	r4, r0, -29944
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
10005b64:	f0730000 	sbi	r3, r19, 0
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
10005b68:	10b70000 	addk	r5, r23, r0
        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
10005b6c:	f8930014 	swi	r4, r19, 20
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
10005b70:	b0001000 	imm	4096
10005b74:	e880d604 	lwi	r4, r0, -10748	// 1000d604 <OSEventFreeList>
             pevent->OSEventCnt     = 0u;
10005b78:	f4730008 	shi	r3, r19, 8
             }
#if OS_EVENT_NAME_EN > 0u
             pevent->OSEventName    = (INT8U *)"?";
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
10005b7c:	f8930004 	swi	r4, r19, 4
             pevent->OSEventCnt     = 0u;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
10005b80:	b0001000 	imm	4096
10005b84:	fa60d604 	swi	r19, r0, -10748	// 1000d604 <OSEventFreeList>
             OS_EXIT_CRITICAL();
10005b88:	b9f423d4 	brlid	r15, 9172	// 10007f5c <OS_CPU_SR_Restore>
10005b8c:	ab180001 	xori	r24, r24, 1
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
10005b90:	bc38000c 	bnei	r24, 12		// 10005b9c
                 OS_Sched();                               /* Find highest priority task ready to run  */
10005b94:	b9f4cc2c 	brlid	r15, -13268	// 100027c0 <OS_Sched>
10005b98:	80000000 	or	r0, r0, r0
             }
             *perr                  = OS_ERR_NONE;
10005b9c:	f0160000 	sbi	r0, r22, 0
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
             break;
10005ba0:	b8100018 	brid	24		// 10005bb8
10005ba4:	12600000 	addk	r19, r0, r0

        default:
             OS_EXIT_CRITICAL();
10005ba8:	b9f423b4 	brlid	r15, 9140	// 10007f5c <OS_CPU_SR_Restore>
10005bac:	10a30000 	addk	r5, r3, r0
             *perr                  = OS_ERR_INVALID_OPT;
10005bb0:	30600007 	addik	r3, r0, 7
10005bb4:	f0760000 	sbi	r3, r22, 0
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
10005bb8:	10730000 	addk	r3, r19, r0
10005bbc:	e9e10000 	lwi	r15, r1, 0
10005bc0:	ea61001c 	lwi	r19, r1, 28
10005bc4:	eac10020 	lwi	r22, r1, 32
10005bc8:	eae10024 	lwi	r23, r1, 36
10005bcc:	eb010028 	lwi	r24, r1, 40
10005bd0:	eb21002c 	lwi	r25, r1, 44
10005bd4:	eb410030 	lwi	r26, r1, 48
10005bd8:	b60f0008 	rtsd	r15, 8
10005bdc:	30210034 	addik	r1, r1, 52

10005be0 <OSSemPend>:
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT  *pevent, 
                 INT32U     timeout, 
                 INT8U     *perr)
{
10005be0:	3021ffd0 	addik	r1, r1, -48
10005be4:	fa61001c 	swi	r19, r1, 28
10005be8:	fac10020 	swi	r22, r1, 32
10005bec:	fb21002c 	swi	r25, r1, 44
10005bf0:	f9e10000 	swi	r15, r1, 0
10005bf4:	fae10024 	swi	r23, r1, 36
10005bf8:	fb010028 	swi	r24, r1, 40
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005bfc:	e0650000 	lbui	r3, r5, 0
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT  *pevent, 
                 INT32U     timeout, 
                 INT8U     *perr)
{
10005c00:	12c50000 	addk	r22, r5, r0
10005c04:	13260000 	addk	r25, r6, r0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005c08:	a8630003 	xori	r3, r3, 3
10005c0c:	be030010 	beqid	r3, 16		// 10005c1c
10005c10:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10005c14:	b8100028 	brid	40		// 10005c3c
10005c18:	30600001 	addik	r3, r0, 1
        return;
    }
    if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
10005c1c:	b0001000 	imm	4096
10005c20:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
10005c24:	be230018 	bneid	r3, 24		// 10005c3c
10005c28:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
        return;
    }
    if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
10005c2c:	b0001000 	imm	4096
10005c30:	e300ce10 	lbui	r24, r0, -12784	// 1000ce10 <OSLockNesting>
10005c34:	be180010 	beqid	r24, 16		// 10005c44
10005c38:	3060000d 	addik	r3, r0, 13
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
        return;
10005c3c:	b81000cc 	brid	204		// 10005d08
10005c40:	f0730000 	sbi	r3, r19, 0
    }
    OS_ENTER_CRITICAL();
10005c44:	b9f422e8 	brlid	r15, 8936	// 10007f2c <OS_CPU_SR_Save>
10005c48:	80000000 	or	r0, r0, r0
    if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
10005c4c:	e4f60008 	lhui	r7, r22, 8
10005c50:	be070020 	beqid	r7, 32		// 10005c70
10005c54:	12e30000 	addk	r23, r3, r0
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
        OS_EXIT_CRITICAL();
10005c58:	10a30000 	addk	r5, r3, r0
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
        return;
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
10005c5c:	30e7ffff 	addik	r7, r7, -1
        OS_EXIT_CRITICAL();
10005c60:	b9f422fc 	brlid	r15, 8956	// 10007f5c <OS_CPU_SR_Restore>
10005c64:	f4f60008 	shi	r7, r22, 8
        *perr = OS_ERR_NONE;
        return;
10005c68:	b81000a0 	brid	160		// 10005d08
10005c6c:	f3130000 	sbi	r24, r19, 0
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
10005c70:	b0001000 	imm	4096
10005c74:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10005c78:	10b60000 	addk	r5, r22, r0
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
10005c7c:	e0640034 	lbui	r3, r4, 52
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
10005c80:	f0e40035 	sbi	r7, r4, 53
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
10005c84:	fb240030 	swi	r25, r4, 48
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
10005c88:	a0630001 	ori	r3, r3, 1
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
10005c8c:	b9f4c5d8 	brlid	r15, -14888	// 10002264 <OS_EventTaskWait>
10005c90:	f0640034 	sbi	r3, r4, 52
    OS_EXIT_CRITICAL();
10005c94:	b9f422c8 	brlid	r15, 8904	// 10007f5c <OS_CPU_SR_Restore>
10005c98:	10b70000 	addk	r5, r23, r0
    OS_Sched();                                       /* Find next highest priority task ready         */
10005c9c:	b9f4cb24 	brlid	r15, -13532	// 100027c0 <OS_Sched>
10005ca0:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();
10005ca4:	b9f42288 	brlid	r15, 8840	// 10007f2c <OS_CPU_SR_Save>
10005ca8:	80000000 	or	r0, r0, r0
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
10005cac:	b0001000 	imm	4096
10005cb0:	e8a0d60c 	lwi	r5, r0, -10740	// 1000d60c <OSTCBCur>
10005cb4:	e0850035 	lbui	r4, r5, 53
10005cb8:	be040018 	beqid	r4, 24		// 10005cd0
10005cbc:	12e30000 	addk	r23, r3, r0
10005cc0:	a8840002 	xori	r4, r4, 2
10005cc4:	be040020 	beqid	r4, 32		// 10005ce4
10005cc8:	3060000e 	addik	r3, r0, 14
10005ccc:	b800000c 	bri	12		// 10005cd8
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
             break;
10005cd0:	b8100018 	brid	24		// 10005ce8
10005cd4:	f0930000 	sbi	r4, r19, 0
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
10005cd8:	b9f4c694 	brlid	r15, -14700	// 1000236c <OS_EventTaskRemove>
10005cdc:	10d60000 	addk	r6, r22, r0
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
10005ce0:	3060000a 	addik	r3, r0, 10
10005ce4:	f0730000 	sbi	r3, r19, 0
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10005ce8:	b0001000 	imm	4096
10005cec:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
10005cf0:	10b70000 	addk	r5, r23, r0
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
10005cf4:	f0040034 	sbi	r0, r4, 52
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
10005cf8:	f0040035 	sbi	r0, r4, 53
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
10005cfc:	f804001c 	swi	r0, r4, 28
#if (OS_EVENT_MULTI_EN > 0u)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
10005d00:	b9f4225c 	brlid	r15, 8796	// 10007f5c <OS_CPU_SR_Restore>
10005d04:	f8040020 	swi	r0, r4, 32
}
10005d08:	e9e10000 	lwi	r15, r1, 0
10005d0c:	ea61001c 	lwi	r19, r1, 28
10005d10:	eac10020 	lwi	r22, r1, 32
10005d14:	eae10024 	lwi	r23, r1, 36
10005d18:	eb010028 	lwi	r24, r1, 40
10005d1c:	eb21002c 	lwi	r25, r1, 44
10005d20:	b60f0008 	rtsd	r15, 8
10005d24:	30210030 	addik	r1, r1, 48

10005d28 <OSSemPendAbort>:

#if OS_SEM_PEND_ABORT_EN > 0u
INT8U  OSSemPendAbort (OS_EVENT  *pevent, 
                       INT8U      opt, 
                       INT8U     *perr)
{
10005d28:	3021ffcc 	addik	r1, r1, -52
10005d2c:	fac10020 	swi	r22, r1, 32
10005d30:	fae10024 	swi	r23, r1, 36
10005d34:	fb410030 	swi	r26, r1, 48
10005d38:	f9e10000 	swi	r15, r1, 0
10005d3c:	fa61001c 	swi	r19, r1, 28
10005d40:	fb010028 	swi	r24, r1, 40
10005d44:	fb21002c 	swi	r25, r1, 44
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005d48:	e3250000 	lbui	r25, r5, 0

#if OS_SEM_PEND_ABORT_EN > 0u
INT8U  OSSemPendAbort (OS_EVENT  *pevent, 
                       INT8U      opt, 
                       INT8U     *perr)
{
10005d4c:	12c50000 	addk	r22, r5, r0
10005d50:	13460000 	addk	r26, r6, r0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return (0u);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005d54:	ab390003 	xori	r25, r25, 3
10005d58:	be190018 	beqid	r25, 24		// 10005d70
10005d5c:	12e70000 	addk	r23, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10005d60:	30600001 	addik	r3, r0, 1
10005d64:	f0670000 	sbi	r3, r7, 0
        return (0u);
10005d68:	b8100090 	brid	144		// 10005df8
10005d6c:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
10005d70:	b9f421bc 	brlid	r15, 8636	// 10007f2c <OS_CPU_SR_Save>
10005d74:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
10005d78:	e276000a 	lbui	r19, r22, 10
10005d7c:	be130070 	beqid	r19, 112		// 10005dec
10005d80:	13030000 	addk	r24, r3, r0
        nbr_tasks = 0u;
        switch (opt) {
10005d84:	aa7a0001 	xori	r19, r26, 1
10005d88:	be130028 	beqid	r19, 40		// 10005db0
10005d8c:	10b60000 	addk	r5, r22, r0
                 }
                 break;
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
10005d90:	b8100030 	brid	48		// 10005dc0
10005d94:	10d90000 	addk	r6, r25, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
10005d98:	10b60000 	addk	r5, r22, r0
10005d9c:	30e00001 	addik	r7, r0, 1
10005da0:	31000002 	addik	r8, r0, 2	// 2 <CPU_IE_BIT>
10005da4:	b9f4c654 	brlid	r15, -14764	// 100023f8 <OS_EventTaskRdy>
10005da8:	32730001 	addik	r19, r19, 1
                     nbr_tasks++;
10005dac:	a67300ff 	andi	r19, r19, 255
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
        nbr_tasks = 0u;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
10005db0:	e076000a 	lbui	r3, r22, 10
10005db4:	be23ffe4 	bneid	r3, -28		// 10005d98
10005db8:	10c00000 	addk	r6, r0, r0
10005dbc:	b8000014 	bri	20		// 10005dd0
                 }
                 break;
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
10005dc0:	30e00001 	addik	r7, r0, 1
10005dc4:	b9f4c634 	brlid	r15, -14796	// 100023f8 <OS_EventTaskRdy>
10005dc8:	31000002 	addik	r8, r0, 2	// 2 <CPU_IE_BIT>
                 nbr_tasks++;
10005dcc:	32600001 	addik	r19, r0, 1
                 break;
        }
        OS_EXIT_CRITICAL();
10005dd0:	b9f4218c 	brlid	r15, 8588	// 10007f5c <OS_CPU_SR_Restore>
10005dd4:	10b80000 	addk	r5, r24, r0
        OS_Sched();                                   /* Find HPT ready to run                         */
10005dd8:	b9f4c9e8 	brlid	r15, -13848	// 100027c0 <OS_Sched>
10005ddc:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_PEND_ABORT;
10005de0:	3060000e 	addik	r3, r0, 14
        return (nbr_tasks);
10005de4:	b8100014 	brid	20		// 10005df8
10005de8:	f0770000 	sbi	r3, r23, 0
    }
    OS_EXIT_CRITICAL();
10005dec:	b9f42170 	brlid	r15, 8560	// 10007f5c <OS_CPU_SR_Restore>
10005df0:	10a30000 	addk	r5, r3, r0
    *perr = OS_ERR_NONE;
10005df4:	f2770000 	sbi	r19, r23, 0
    return (0);                                       /* No tasks waiting on semaphore                 */
}
10005df8:	10730000 	addk	r3, r19, r0
10005dfc:	e9e10000 	lwi	r15, r1, 0
10005e00:	ea61001c 	lwi	r19, r1, 28
10005e04:	eac10020 	lwi	r22, r1, 32
10005e08:	eae10024 	lwi	r23, r1, 36
10005e0c:	eb010028 	lwi	r24, r1, 40
10005e10:	eb21002c 	lwi	r25, r1, 44
10005e14:	eb410030 	lwi	r26, r1, 48
10005e18:	b60f0008 	rtsd	r15, 8
10005e1c:	30210034 	addik	r1, r1, 52

10005e20 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
10005e20:	3021ffd0 	addik	r1, r1, -48
10005e24:	fa61001c 	swi	r19, r1, 28
10005e28:	fac10020 	swi	r22, r1, 32
10005e2c:	f9e10000 	swi	r15, r1, 0
10005e30:	fae10024 	swi	r23, r1, 36
10005e34:	fb010028 	swi	r24, r1, 40
10005e38:	fb21002c 	swi	r25, r1, 44
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005e3c:	e3050000 	lbui	r24, r5, 0
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
10005e40:	12c50000 	addk	r22, r5, r0
#if OS_ARG_CHK_EN > 0u
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005e44:	ab180003 	xori	r24, r24, 3
10005e48:	be38007c 	bneid	r24, 124		// 10005ec4
10005e4c:	32600001 	addik	r19, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005e50:	b9f420dc 	brlid	r15, 8412	// 10007f2c <OS_CPU_SR_Save>
10005e54:	80000000 	or	r0, r0, r0
    if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
10005e58:	e336000a 	lbui	r25, r22, 10
10005e5c:	be190038 	beqid	r25, 56		// 10005e94
10005e60:	12e30000 	addk	r23, r3, r0
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
10005e64:	10f30000 	addk	r7, r19, r0
10005e68:	10d80000 	addk	r6, r24, r0
10005e6c:	11180000 	addk	r8, r24, r0
10005e70:	10b60000 	addk	r5, r22, r0
10005e74:	b9f4c584 	brlid	r15, -14972	// 100023f8 <OS_EventTaskRdy>
10005e78:	12780000 	addk	r19, r24, r0
        OS_EXIT_CRITICAL();
10005e7c:	b9f420e0 	brlid	r15, 8416	// 10007f5c <OS_CPU_SR_Restore>
10005e80:	10b70000 	addk	r5, r23, r0
        OS_Sched();                                   /* Find HPT ready to run                         */
10005e84:	b9f4c93c 	brlid	r15, -14020	// 100027c0 <OS_Sched>
10005e88:	80000000 	or	r0, r0, r0
        return (OS_ERR_NONE);
10005e8c:	b810003c 	brid	60		// 10005ec8
10005e90:	10730000 	addk	r3, r19, r0
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
10005e94:	e4760008 	lhui	r3, r22, 8
10005e98:	b0000000 	imm	0
10005e9c:	a883ffff 	xori	r4, r3, -1
10005ea0:	be04001c 	beqid	r4, 28		// 10005ebc
10005ea4:	10b70000 	addk	r5, r23, r0
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
10005ea8:	30630001 	addik	r3, r3, 1
        OS_EXIT_CRITICAL();
10005eac:	b9f420b0 	brlid	r15, 8368	// 10007f5c <OS_CPU_SR_Restore>
10005eb0:	f4760008 	shi	r3, r22, 8
        return (OS_ERR_NONE);
10005eb4:	b8100010 	brid	16		// 10005ec4
10005eb8:	12790000 	addk	r19, r25, r0
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
10005ebc:	b9f420a0 	brlid	r15, 8352	// 10007f5c <OS_CPU_SR_Restore>
10005ec0:	32600033 	addik	r19, r0, 51
    return (OS_ERR_SEM_OVF);
}
10005ec4:	10730000 	addk	r3, r19, r0
10005ec8:	e9e10000 	lwi	r15, r1, 0
10005ecc:	ea61001c 	lwi	r19, r1, 28
10005ed0:	eac10020 	lwi	r22, r1, 32
10005ed4:	eae10024 	lwi	r23, r1, 36
10005ed8:	eb010028 	lwi	r24, r1, 40
10005edc:	eb21002c 	lwi	r25, r1, 44
10005ee0:	b60f0008 	rtsd	r15, 8
10005ee4:	30210030 	addik	r1, r1, 48

10005ee8 <OSSemQuery>:
*/

#if OS_SEM_QUERY_EN > 0u
INT8U  OSSemQuery (OS_EVENT     *pevent, 
                   OS_SEM_DATA  *p_sem_data)
{
10005ee8:	3021ffd8 	addik	r1, r1, -40
10005eec:	fa61001c 	swi	r19, r1, 28
10005ef0:	fac10020 	swi	r22, r1, 32
10005ef4:	f9e10000 	swi	r15, r1, 0
10005ef8:	fae10024 	swi	r23, r1, 36
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
10005efc:	e2e50000 	lbui	r23, r5, 0
*/

#if OS_SEM_QUERY_EN > 0u
INT8U  OSSemQuery (OS_EVENT     *pevent, 
                   OS_SEM_DATA  *p_sem_data)
{
10005f00:	12650000 	addk	r19, r5, r0
10005f04:	12c60000 	addk	r22, r6, r0
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
10005f08:	aaf70003 	xori	r23, r23, 3
10005f0c:	be37004c 	bneid	r23, 76		// 10005f58
10005f10:	30600001 	addik	r3, r0, 1
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
10005f14:	b9f42018 	brlid	r15, 8216	// 10007f2c <OS_CPU_SR_Save>
10005f18:	80000000 	or	r0, r0, r0
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
10005f1c:	e093000a 	lbui	r4, r19, 10
    psrc                   = &pevent->OSEventTbl[0];
10005f20:	30d3000b 	addik	r6, r19, 11
    pdest                  = &p_sem_data->OSEventTbl[0];
10005f24:	30b60002 	addik	r5, r22, 2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
10005f28:	f096000a 	sbi	r4, r22, 10
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
10005f2c:	10970000 	addk	r4, r23, r0
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
10005f30:	c0e43000 	lbu	r7, r4, r6
10005f34:	d0e42800 	sb	r7, r4, r5
10005f38:	30840001 	addik	r4, r4, 1
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
10005f3c:	aae40008 	xori	r23, r4, 8
10005f40:	bc37fff0 	bnei	r23, -16		// 10005f30
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
10005f44:	e6730008 	lhui	r19, r19, 8
    OS_EXIT_CRITICAL();
10005f48:	10a30000 	addk	r5, r3, r0
10005f4c:	b9f42010 	brlid	r15, 8208	// 10007f5c <OS_CPU_SR_Restore>
10005f50:	f6760000 	shi	r19, r22, 0
    return (OS_ERR_NONE);
10005f54:	10770000 	addk	r3, r23, r0
}
10005f58:	e9e10000 	lwi	r15, r1, 0
10005f5c:	ea61001c 	lwi	r19, r1, 28
10005f60:	eac10020 	lwi	r22, r1, 32
10005f64:	eae10024 	lwi	r23, r1, 36
10005f68:	b60f0008 	rtsd	r15, 8
10005f6c:	30210028 	addik	r1, r1, 40

10005f70 <OSSemSet>:

#if OS_SEM_SET_EN > 0u
void  OSSemSet (OS_EVENT  *pevent, 
                INT16U     cnt, 
                INT8U     *perr)
{
10005f70:	3021ffd4 	addik	r1, r1, -44
10005f74:	fa61001c 	swi	r19, r1, 28
10005f78:	fac10020 	swi	r22, r1, 32
10005f7c:	fae10024 	swi	r23, r1, 36
10005f80:	f9e10000 	swi	r15, r1, 0
10005f84:	fb010028 	swi	r24, r1, 40
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005f88:	e3050000 	lbui	r24, r5, 0

#if OS_SEM_SET_EN > 0u
void  OSSemSet (OS_EVENT  *pevent, 
                INT16U     cnt, 
                INT8U     *perr)
{
10005f8c:	12650000 	addk	r19, r5, r0
10005f90:	12e60000 	addk	r23, r6, r0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *perr = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
10005f94:	ab180003 	xori	r24, r24, 3
10005f98:	be180014 	beqid	r24, 20		// 10005fac
10005f9c:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_EVENT_TYPE;
10005fa0:	30600001 	addik	r3, r0, 1
        return;
10005fa4:	b810003c 	brid	60		// 10005fe0
10005fa8:	f0670000 	sbi	r3, r7, 0
    }
    OS_ENTER_CRITICAL();
10005fac:	b9f41f80 	brlid	r15, 8064	// 10007f2c <OS_CPU_SR_Save>
10005fb0:	80000000 	or	r0, r0, r0
    *perr = OS_ERR_NONE;
10005fb4:	f3160000 	sbi	r24, r22, 0
    if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
10005fb8:	e4930008 	lhui	r4, r19, 8
10005fbc:	bc240010 	bnei	r4, 16		// 10005fcc
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
10005fc0:	e093000a 	lbui	r4, r19, 10
10005fc4:	be240010 	bneid	r4, 16		// 10005fd4
10005fc8:	30800049 	addik	r4, r0, 73
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
10005fcc:	b810000c 	brid	12		// 10005fd8
10005fd0:	f6f30008 	shi	r23, r19, 8
        } else {
            *perr              = OS_ERR_TASK_WAITING;
10005fd4:	f0960000 	sbi	r4, r22, 0
        }
    }
    OS_EXIT_CRITICAL();
10005fd8:	b9f41f84 	brlid	r15, 8068	// 10007f5c <OS_CPU_SR_Restore>
10005fdc:	10a30000 	addk	r5, r3, r0
}
10005fe0:	e9e10000 	lwi	r15, r1, 0
10005fe4:	ea61001c 	lwi	r19, r1, 28
10005fe8:	eac10020 	lwi	r22, r1, 32
10005fec:	eae10024 	lwi	r23, r1, 36
10005ff0:	eb010028 	lwi	r24, r1, 40
10005ff4:	b60f0008 	rtsd	r15, 8
10005ff8:	3021002c 	addik	r1, r1, 44

10005ffc <OSTaskChangePrio>:
*/

#if OS_TASK_CHANGE_PRIO_EN > 0u
INT8U  OSTaskChangePrio (INT8U  oldprio,
                         INT8U  newprio)
{
10005ffc:	3021ffd4 	addik	r1, r1, -44
10006000:	fa61001c 	swi	r19, r1, 28
10006004:	12660000 	addk	r19, r6, r0
10006008:	fac10020 	swi	r22, r1, 32
1000600c:	f9e10000 	swi	r15, r1, 0
10006010:	12c50000 	addk	r22, r5, r0
10006014:	fae10024 	swi	r23, r1, 36
    }
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
10006018:	b9f41f14 	brlid	r15, 7956	// 10007f2c <OS_CPU_SR_Save>
1000601c:	fb010028 	swi	r24, r1, 40
10006020:	10a30000 	addk	r5, r3, r0
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
10006024:	64730402 	bslli	r3, r19, 2
10006028:	b0001000 	imm	4096
1000602c:	e863e0a4 	lwi	r3, r3, -8028
10006030:	bc030014 	beqi	r3, 20		// 10006044
        OS_EXIT_CRITICAL();
10006034:	b9f41f28 	brlid	r15, 7976	// 10007f5c <OS_CPU_SR_Restore>
10006038:	32600028 	addik	r19, r0, 40	// 28 <STK_OFFSET_R11>
        return (OS_ERR_PRIO_EXIST);
1000603c:	b81001dc 	brid	476		// 10006218
10006040:	10730000 	addk	r3, r19, r0
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
10006044:	a87600ff 	xori	r3, r22, 255
10006048:	be230018 	bneid	r3, 24		// 10006060
1000604c:	66d60402 	bslli	r22, r22, 2
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
10006050:	b0001000 	imm	4096
10006054:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10006058:	e2c30036 	lbui	r22, r3, 54
    }
    ptcb = OSTCBPrioTbl[oldprio];
1000605c:	66d60402 	bslli	r22, r22, 2
10006060:	b0001000 	imm	4096
10006064:	e896e0a4 	lwi	r4, r22, -8028
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
10006068:	bc240014 	bnei	r4, 20		// 1000607c
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
1000606c:	b9f41ef0 	brlid	r15, 7920	// 10007f5c <OS_CPU_SR_Restore>
10006070:	32600029 	addik	r19, r0, 41
        return (OS_ERR_PRIO);
10006074:	b81001a4 	brid	420		// 10006218
10006078:	10730000 	addk	r3, r19, r0
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
1000607c:	a8640001 	xori	r3, r4, 1
10006080:	be230018 	bneid	r3, 24		// 10006098
10006084:	64f30402 	bslli	r7, r19, 2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
10006088:	b9f41ed4 	brlid	r15, 7892	// 10007f5c <OS_CPU_SR_Restore>
1000608c:	32600043 	addik	r19, r0, 67
        return (OS_ERR_TASK_NOT_EXIST);
10006090:	b8100188 	brid	392		// 10006218
10006094:	10730000 	addk	r3, r19, r0
    }
#if OS_LOWEST_PRIO <= 63u
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
10006098:	64730003 	bsrli	r3, r19, 3
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1u << y_new);
    bitx_new              = (INT16U)(1u << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
1000609c:	b0001000 	imm	4096
100060a0:	f816e0a4 	swi	r0, r22, -8028
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
100060a4:	b0001000 	imm	4096
100060a8:	f887e0a4 	swi	r4, r7, -8028
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
100060ac:	e1440038 	lbui	r10, r4, 56

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
100060b0:	e1240039 	lbui	r9, r4, 57
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63u
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
    x_new                 = (INT8U)(newprio & 0x07);
    bity_new              = (INT8U)(1u << y_new);
100060b4:	30c00001 	addik	r6, r0, 1
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
100060b8:	b0001000 	imm	4096
100060bc:	e0ead3fc 	lbui	r7, r10, -11268
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63u
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
    x_new                 = (INT8U)(newprio & 0x07);
100060c0:	a6f30007 	andi	r23, r19, 7
    bity_new              = (INT8U)(1u << y_new);
100060c4:	45061c00 	bsll	r8, r6, r3
    bitx_new              = (INT8U)(1u << x_new);
100060c8:	44c6bc00 	bsll	r6, r6, r23
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
100060cc:	85874800 	and	r12, r7, r9
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63u
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
    x_new                 = (INT8U)(newprio & 0x07);
    bity_new              = (INT8U)(1u << y_new);
100060d0:	a50800ff 	andi	r8, r8, 255
    bitx_new              = (INT8U)(1u << x_new);
100060d4:	a4c600ff 	andi	r6, r6, 255
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
100060d8:	be0c005c 	beqid	r12, 92		// 10006134
100060dc:	e164003a 	lbui	r11, r4, 58
         OSRdyTbl[y_old] &= ~bitx_old;
100060e0:	a989ffff 	xori	r12, r9, -1
100060e4:	84e76000 	and	r7, r7, r12
100060e8:	b0001000 	imm	4096
100060ec:	f0ead3fc 	sbi	r7, r10, -11268
         if (OSRdyTbl[y_old] == 0u) {
100060f0:	be27001c 	bneid	r7, 28		// 1000610c
100060f4:	a8ebffff 	xori	r7, r11, -1
             OSRdyGrp &= ~bity_old;
100060f8:	b0001000 	imm	4096
100060fc:	e180d3f8 	lbui	r12, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006100:	84e76000 	and	r7, r7, r12
10006104:	b0001000 	imm	4096
10006108:	f0e0d3f8 	sbi	r7, r0, -11272	// 1000d3f8 <OSRdyGrp>
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
1000610c:	b0001000 	imm	4096
10006110:	e0e0d3f8 	lbui	r7, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006114:	80e83800 	or	r7, r8, r7
10006118:	b0001000 	imm	4096
1000611c:	f0e0d3f8 	sbi	r7, r0, -11272	// 1000d3f8 <OSRdyGrp>
         OSRdyTbl[y_new] |= bitx_new;
10006120:	b0001000 	imm	4096
10006124:	e0e3d3fc 	lbui	r7, r3, -11268
10006128:	80e63800 	or	r7, r6, r7
1000612c:	b0001000 	imm	4096
10006130:	f0e3d3fc 	sbi	r7, r3, -11268
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
10006134:	e8e4001c 	lwi	r7, r4, 28
    if (pevent != (OS_EVENT *)0) {
10006138:	be070048 	beqid	r7, 72		// 10006180
1000613c:	12c75000 	addk	r22, r7, r10
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
10006140:	e196000b 	lbui	r12, r22, 11
10006144:	ab09ffff 	xori	r24, r9, -1
10006148:	85986000 	and	r12, r24, r12
        if (pevent->OSEventTbl[y_old] == 0u) {
1000614c:	be2c0018 	bneid	r12, 24		// 10006164
10006150:	f196000b 	sbi	r12, r22, 11
            pevent->OSEventGrp    &= ~bity_old;
10006154:	e2c7000a 	lbui	r22, r7, 10
10006158:	a98bffff 	xori	r12, r11, -1
1000615c:	858cb000 	and	r12, r12, r22
10006160:	f187000a 	sbi	r12, r7, 10
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
10006164:	e187000a 	lbui	r12, r7, 10
10006168:	81886000 	or	r12, r8, r12
1000616c:	f187000a 	sbi	r12, r7, 10
        pevent->OSEventTbl[y_new] |= bitx_new;
10006170:	10e71800 	addk	r7, r7, r3
10006174:	e187000b 	lbui	r12, r7, 11
10006178:	81866000 	or	r12, r6, r12
1000617c:	f187000b 	sbi	r12, r7, 11
    }
#if (OS_EVENT_MULTI_EN > 0u)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
10006180:	e9840020 	lwi	r12, r4, 32
10006184:	be0c005c 	beqid	r12, 92		// 100061e0
10006188:	a929ffff 	xori	r9, r9, -1
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
1000618c:	e8ec0000 	lwi	r7, r12, 0
        while (pevent != (OS_EVENT *)0) {
10006190:	b8100048 	brid	72		// 100061d8
10006194:	a96bffff 	xori	r11, r11, -1
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
10006198:	e2d8000b 	lbui	r22, r24, 11
1000619c:	86c9b000 	and	r22, r9, r22
            if (pevent->OSEventTbl[y_old] == 0u) {
100061a0:	be360014 	bneid	r22, 20		// 100061b4
100061a4:	f2d8000b 	sbi	r22, r24, 11
                pevent->OSEventGrp    &= ~bity_old;
100061a8:	e2c7000a 	lbui	r22, r7, 10
100061ac:	86cbb000 	and	r22, r11, r22
100061b0:	f2c7000a 	sbi	r22, r7, 10
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
100061b4:	e2c7000a 	lbui	r22, r7, 10
100061b8:	82c8b000 	or	r22, r8, r22
100061bc:	f2c7000a 	sbi	r22, r7, 10
            pevent->OSEventTbl[y_new] |= bitx_new;
100061c0:	10e71800 	addk	r7, r7, r3
100061c4:	e2c7000b 	lbui	r22, r7, 11
100061c8:	82c6b000 	or	r22, r6, r22
100061cc:	f2c7000b 	sbi	r22, r7, 11
            pevents++;
            pevent                     = *pevents;
100061d0:	e8ec0004 	lwi	r7, r12, 4
100061d4:	318c0004 	addik	r12, r12, 4
    }
#if (OS_EVENT_MULTI_EN > 0u)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
100061d8:	be27ffc0 	bneid	r7, -64		// 10006198
100061dc:	13075000 	addk	r24, r7, r10
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
100061e0:	f2640036 	sbi	r19, r4, 54
    ptcb->OSTCBY    = y_new;
100061e4:	f0640038 	sbi	r3, r4, 56
    ptcb->OSTCBX    = x_new;
100061e8:	f2e40037 	sbi	r23, r4, 55
    ptcb->OSTCBBitY = bity_new;
100061ec:	f104003a 	sbi	r8, r4, 58
    ptcb->OSTCBBitX = bitx_new;
    OS_EXIT_CRITICAL();
100061f0:	b9f41d6c 	brlid	r15, 7532	// 10007f5c <OS_CPU_SR_Restore>
100061f4:	f0c40039 	sbi	r6, r4, 57
    if (OSRunning == OS_TRUE) {
100061f8:	b0001000 	imm	4096
100061fc:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
10006200:	a8630001 	xori	r3, r3, 1
10006204:	be230010 	bneid	r3, 16		// 10006214
10006208:	12600000 	addk	r19, r0, r0
        OS_Sched();                                         /* Find new highest priority task          */
1000620c:	b9f4c5b4 	brlid	r15, -14924	// 100027c0 <OS_Sched>
10006210:	80000000 	or	r0, r0, r0
    }
    return (OS_ERR_NONE);
}
10006214:	10730000 	addk	r3, r19, r0
10006218:	e9e10000 	lwi	r15, r1, 0
1000621c:	ea61001c 	lwi	r19, r1, 28
10006220:	eac10020 	lwi	r22, r1, 32
10006224:	eae10024 	lwi	r23, r1, 36
10006228:	eb010028 	lwi	r24, r1, 40
1000622c:	b60f0008 	rtsd	r15, 8
10006230:	3021002c 	addik	r1, r1, 44

10006234 <OSTaskCreate>:
#if OS_TASK_CREATE_EN > 0u
INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
{
10006234:	3021ffc8 	addik	r1, r1, -56
10006238:	fac10024 	swi	r22, r1, 36
1000623c:	fb01002c 	swi	r24, r1, 44
10006240:	fb210030 	swi	r25, r1, 48
10006244:	fb410034 	swi	r26, r1, 52
10006248:	f9e10000 	swi	r15, r1, 0
1000624c:	fa610020 	swi	r19, r1, 32
10006250:	fae10028 	swi	r23, r1, 40
10006254:	13450000 	addk	r26, r5, r0
10006258:	13260000 	addk	r25, r6, r0
1000625c:	13070000 	addk	r24, r7, r0
#if OS_ARG_CHK_EN > 0u
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
10006260:	b9f41ccc 	brlid	r15, 7372	// 10007f2c <OS_CPU_SR_Save>
10006264:	12c80000 	addk	r22, r8, r0
    if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
10006268:	b0001000 	imm	4096
1000626c:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
10006270:	be04001c 	beqid	r4, 28		// 1000628c
10006274:	66f60402 	bslli	r23, r22, 2
        OS_EXIT_CRITICAL();
10006278:	10a30000 	addk	r5, r3, r0
1000627c:	b9f41ce0 	brlid	r15, 7392	// 10007f5c <OS_CPU_SR_Restore>
10006280:	32c0003c 	addik	r22, r0, 60	// 3c <STK_OFFSET_R17>
        return (OS_ERR_TASK_CREATE_ISR);
10006284:	b81000b4 	brid	180		// 10006338
10006288:	10760000 	addk	r3, r22, r0
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
1000628c:	b0001000 	imm	4096
10006290:	ea77e0a4 	lwi	r19, r23, -8028
10006294:	be330098 	bneid	r19, 152		// 1000632c
10006298:	10a30000 	addk	r5, r3, r0
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
1000629c:	30800001 	addik	r4, r0, 1
100062a0:	b0001000 	imm	4096
100062a4:	f897e0a4 	swi	r4, r23, -8028
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
100062a8:	b9f41cb4 	brlid	r15, 7348	// 10007f5c <OS_CPU_SR_Restore>
100062ac:	10a30000 	addk	r5, r3, r0
        psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
100062b0:	10ba0000 	addk	r5, r26, r0
100062b4:	10d90000 	addk	r6, r25, r0
100062b8:	10f80000 	addk	r7, r24, r0
100062bc:	b9f41980 	brlid	r15, 6528	// 10007c3c <OSTaskStkInit>
100062c0:	11130000 	addk	r8, r19, r0
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
100062c4:	10b60000 	addk	r5, r22, r0
100062c8:	10c30000 	addk	r6, r3, r0
100062cc:	10f30000 	addk	r7, r19, r0
100062d0:	11130000 	addk	r8, r19, r0
100062d4:	11330000 	addk	r9, r19, r0
100062d8:	11530000 	addk	r10, r19, r0
100062dc:	b9f4cb58 	brlid	r15, -13480	// 10002e34 <OS_TCBInit>
100062e0:	fa61001c 	swi	r19, r1, 28
        if (err == OS_ERR_NONE) {
100062e4:	be230028 	bneid	r3, 40		// 1000630c
100062e8:	12c30000 	addk	r22, r3, r0
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
100062ec:	b0001000 	imm	4096
100062f0:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
100062f4:	a8630001 	xori	r3, r3, 1
100062f8:	bc23003c 	bnei	r3, 60		// 10006334
                OS_Sched();
100062fc:	b9f4c4c4 	brlid	r15, -15164	// 100027c0 <OS_Sched>
10006300:	80000000 	or	r0, r0, r0
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
10006304:	b8100034 	brid	52		// 10006338
10006308:	10760000 	addk	r3, r22, r0
        if (err == OS_ERR_NONE) {
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
                OS_Sched();
            }
        } else {
            OS_ENTER_CRITICAL();
1000630c:	b9f41c20 	brlid	r15, 7200	// 10007f2c <OS_CPU_SR_Save>
10006310:	80000000 	or	r0, r0, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
10006314:	b0001000 	imm	4096
10006318:	fa77e0a4 	swi	r19, r23, -8028
            OS_EXIT_CRITICAL();
1000631c:	b9f41c40 	brlid	r15, 7232	// 10007f5c <OS_CPU_SR_Restore>
10006320:	10a30000 	addk	r5, r3, r0
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
10006324:	b8100014 	brid	20		// 10006338
10006328:	10760000 	addk	r3, r22, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
1000632c:	b9f41c30 	brlid	r15, 7216	// 10007f5c <OS_CPU_SR_Restore>
10006330:	32c00028 	addik	r22, r0, 40	// 28 <STK_OFFSET_R11>
    return (OS_ERR_PRIO_EXIST);
}
10006334:	10760000 	addk	r3, r22, r0
10006338:	e9e10000 	lwi	r15, r1, 0
1000633c:	ea610020 	lwi	r19, r1, 32
10006340:	eac10024 	lwi	r22, r1, 36
10006344:	eae10028 	lwi	r23, r1, 40
10006348:	eb01002c 	lwi	r24, r1, 44
1000634c:	eb210030 	lwi	r25, r1, 48
10006350:	eb410034 	lwi	r26, r1, 52
10006354:	b60f0008 	rtsd	r15, 8
10006358:	30210038 	addik	r1, r1, 56

1000635c <OSTaskDel>:
    OS_CPU_SR     cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
1000635c:	b0001000 	imm	4096
10006360:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0u
INT8U  OSTaskDel (INT8U prio)
{
10006364:	3021ffd8 	addik	r1, r1, -40
10006368:	fa61001c 	swi	r19, r1, 28
1000636c:	fac10020 	swi	r22, r1, 32
10006370:	f9e10000 	swi	r15, r1, 0
10006374:	fae10024 	swi	r23, r1, 36
10006378:	12c50000 	addk	r22, r5, r0
    OS_CPU_SR     cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
1000637c:	be2301d4 	bneid	r3, 468		// 10006550
10006380:	32600040 	addik	r19, r0, 64	// 40 <STK_OFFSET_R18>
        return (OS_ERR_TASK_DEL_ISR);
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
10006384:	a865003f 	xori	r3, r5, 63
10006388:	be0301c8 	beqid	r3, 456		// 10006550
1000638c:	3260003e 	addik	r19, r0, 62
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
10006390:	b9f41b9c 	brlid	r15, 7068	// 10007f2c <OS_CPU_SR_Save>
10006394:	80000000 	or	r0, r0, r0
10006398:	12e30000 	addk	r23, r3, r0
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
1000639c:	a87600ff 	xori	r3, r22, 255
100063a0:	be230018 	bneid	r3, 24		// 100063b8
100063a4:	64760402 	bslli	r3, r22, 2
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
100063a8:	b0001000 	imm	4096
100063ac:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
100063b0:	e2c30036 	lbui	r22, r3, 54
    }
    ptcb = OSTCBPrioTbl[prio];
100063b4:	64760402 	bslli	r3, r22, 2
100063b8:	b0001000 	imm	4096
100063bc:	ea63e0a4 	lwi	r19, r3, -8028
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
100063c0:	be330018 	bneid	r19, 24		// 100063d8
100063c4:	10b70000 	addk	r5, r23, r0
        OS_EXIT_CRITICAL();
100063c8:	b9f41b94 	brlid	r15, 7060	// 10007f5c <OS_CPU_SR_Restore>
100063cc:	32600043 	addik	r19, r0, 67
        return (OS_ERR_TASK_NOT_EXIST);
100063d0:	b8100184 	brid	388		// 10006554
100063d4:	10730000 	addk	r3, r19, r0
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
100063d8:	a8730001 	xori	r3, r19, 1
100063dc:	bc230014 	bnei	r3, 20		// 100063f0
        OS_EXIT_CRITICAL();
100063e0:	b9f41b7c 	brlid	r15, 7036	// 10007f5c <OS_CPU_SR_Restore>
100063e4:	3260003d 	addik	r19, r0, 61
        return (OS_ERR_TASK_DEL);
100063e8:	b810016c 	brid	364		// 10006554
100063ec:	10730000 	addk	r3, r19, r0
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
100063f0:	e0930038 	lbui	r4, r19, 56
100063f4:	e0730039 	lbui	r3, r19, 57
100063f8:	b0001000 	imm	4096
100063fc:	e0a4d3fc 	lbui	r5, r4, -11268
10006400:	a863ffff 	xori	r3, r3, -1
10006404:	84632800 	and	r3, r3, r5
10006408:	b0001000 	imm	4096
1000640c:	f064d3fc 	sbi	r3, r4, -11268
    if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
10006410:	bc230020 	bnei	r3, 32		// 10006430
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
10006414:	e073003a 	lbui	r3, r19, 58
10006418:	b0001000 	imm	4096
1000641c:	e080d3f8 	lbui	r4, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006420:	a863ffff 	xori	r3, r3, -1
10006424:	84632000 	and	r3, r3, r4
10006428:	b0001000 	imm	4096
1000642c:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
    }

#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
10006430:	e8d3001c 	lwi	r6, r19, 28
10006434:	bc06000c 	beqi	r6, 12		// 10006440
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
10006438:	b9f4bf34 	brlid	r15, -16588	// 1000236c <OS_EventTaskRemove>
1000643c:	10b30000 	addk	r5, r19, r0
    }
#if (OS_EVENT_MULTI_EN > 0u)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
10006440:	e8d30020 	lwi	r6, r19, 32
10006444:	bc06000c 	beqi	r6, 12		// 10006450
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
10006448:	b9f4bf60 	brlid	r15, -16544	// 100023a8 <OS_EventTaskRemoveMulti>
1000644c:	10b30000 	addk	r5, r19, r0
    }
#endif
#endif

#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    pnode = ptcb->OSTCBFlagNode;
10006450:	e8b30028 	lwi	r5, r19, 40
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
10006454:	bc05000c 	beqi	r5, 12		// 10006460
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
10006458:	b9f4d0a0 	brlid	r15, -12128	// 100034f8 <OS_FlagUnlink>
1000645c:	80000000 	or	r0, r0, r0
#endif

    ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
10006460:	b0001000 	imm	4096
10006464:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
    }
#endif

    ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
10006468:	f8130030 	swi	r0, r19, 48
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
1000646c:	f0130034 	sbi	r0, r19, 52
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
10006470:	a88300ff 	xori	r4, r3, 255
10006474:	be040014 	beqid	r4, 20		// 10006488
10006478:	f0130035 	sbi	r0, r19, 53
        OSLockNesting++;
1000647c:	30630001 	addik	r3, r3, 1
10006480:	b0001000 	imm	4096
10006484:	f060ce10 	sbi	r3, r0, -12784	// 1000ce10 <OSLockNesting>
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
10006488:	b9f41ad4 	brlid	r15, 6868	// 10007f5c <OS_CPU_SR_Restore>
1000648c:	10b70000 	addk	r5, r23, r0
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
10006490:	b9f4bdcc 	brlid	r15, -16948	// 1000225c <OS_Dummy>
10006494:	80000000 	or	r0, r0, r0
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
10006498:	b9f41a94 	brlid	r15, 6804	// 10007f2c <OS_CPU_SR_Save>
1000649c:	80000000 	or	r0, r0, r0
    if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
100064a0:	b0001000 	imm	4096
100064a4:	e080ce10 	lbui	r4, r0, -12784	// 1000ce10 <OSLockNesting>
100064a8:	be040014 	beqid	r4, 20		// 100064bc
100064ac:	12e30000 	addk	r23, r3, r0
        OSLockNesting--;
100064b0:	3084ffff 	addik	r4, r4, -1
100064b4:	b0001000 	imm	4096
100064b8:	f080ce10 	sbi	r4, r0, -12784	// 1000ce10 <OSLockNesting>
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
100064bc:	10b30000 	addk	r5, r19, r0
100064c0:	b9f4175c 	brlid	r15, 5980	// 10007c1c <OSTaskDelHook>
100064c4:	66d60402 	bslli	r22, r22, 2
    OSTaskCtr--;                                        /* One less task being managed                 */
100064c8:	b0001000 	imm	4096
100064cc:	e060d389 	lbui	r3, r0, -11383	// 1000d389 <OSTaskCtr>
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
100064d0:	b0001000 	imm	4096
100064d4:	f816e0a4 	swi	r0, r22, -8028
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
100064d8:	e8930018 	lwi	r4, r19, 24
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
    if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
    OSTaskCtr--;                                        /* One less task being managed                 */
100064dc:	3063ffff 	addik	r3, r3, -1
100064e0:	b0001000 	imm	4096
100064e4:	f060d389 	sbi	r3, r0, -11383	// 1000d389 <OSTaskCtr>
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
100064e8:	be240018 	bneid	r4, 24		// 10006500
100064ec:	e8d30014 	lwi	r6, r19, 20
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
100064f0:	f8860018 	swi	r4, r6, 24
        OSTCBList                  = ptcb->OSTCBNext;
100064f4:	b0001000 	imm	4096
100064f8:	f8c0d0f8 	swi	r6, r0, -12040	// 1000d0f8 <OSTCBList>
100064fc:	b8000010 	bri	16		// 1000650c
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
10006500:	f8c40014 	swi	r6, r4, 20
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
10006504:	e8730014 	lwi	r3, r19, 20
10006508:	f8830018 	swi	r4, r3, 24
    }
    ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
1000650c:	b0001000 	imm	4096
10006510:	e860d384 	lwi	r3, r0, -11388	// 1000d384 <OSTCBFreeList>
    OSTCBFreeList       = ptcb;
#if OS_TASK_NAME_EN > 0u
    ptcb->OSTCBTaskName = (INT8U *)"?";
#endif
    OS_EXIT_CRITICAL();
10006514:	10b70000 	addk	r5, r23, r0
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
    }
    ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
    OSTCBFreeList       = ptcb;
10006518:	b0001000 	imm	4096
1000651c:	fa60d384 	swi	r19, r0, -11388	// 1000d384 <OSTCBFreeList>
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
    }
    ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
10006520:	f8730014 	swi	r3, r19, 20
    OSTCBFreeList       = ptcb;
#if OS_TASK_NAME_EN > 0u
    ptcb->OSTCBTaskName = (INT8U *)"?";
10006524:	b0001000 	imm	4096
10006528:	30608b0c 	addik	r3, r0, -29940
#endif
    OS_EXIT_CRITICAL();
1000652c:	b9f41a30 	brlid	r15, 6704	// 10007f5c <OS_CPU_SR_Restore>
10006530:	f8730050 	swi	r3, r19, 80
    if (OSRunning == OS_TRUE) {
10006534:	b0001000 	imm	4096
10006538:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
1000653c:	a8630001 	xori	r3, r3, 1
10006540:	be230010 	bneid	r3, 16		// 10006550
10006544:	12600000 	addk	r19, r0, r0
        OS_Sched();                                     /* Find new highest priority task              */
10006548:	b9f4c278 	brlid	r15, -15752	// 100027c0 <OS_Sched>
1000654c:	80000000 	or	r0, r0, r0
    }
    return (OS_ERR_NONE);
}
10006550:	10730000 	addk	r3, r19, r0
10006554:	e9e10000 	lwi	r15, r1, 0
10006558:	ea61001c 	lwi	r19, r1, 28
1000655c:	eac10020 	lwi	r22, r1, 32
10006560:	eae10024 	lwi	r23, r1, 36
10006564:	b60f0008 	rtsd	r15, 8
10006568:	30210028 	addik	r1, r1, 40

1000656c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0u
INT8U  OSTaskDelReq (INT8U prio)
{
1000656c:	3021ffdc 	addik	r1, r1, -36
10006570:	fa61001c 	swi	r19, r1, 28
10006574:	fac10020 	swi	r22, r1, 32
10006578:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
1000657c:	a865003f 	xori	r3, r5, 63
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0u
INT8U  OSTaskDelReq (INT8U prio)
{
10006580:	12c50000 	addk	r22, r5, r0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
10006584:	be030084 	beqid	r3, 132		// 10006608
10006588:	3260003e 	addik	r19, r0, 62
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
1000658c:	a86500ff 	xori	r3, r5, 255
10006590:	bc230028 	bnei	r3, 40		// 100065b8
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
10006594:	b9f41998 	brlid	r15, 6552	// 10007f2c <OS_CPU_SR_Save>
10006598:	80000000 	or	r0, r0, r0
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
1000659c:	b0001000 	imm	4096
100065a0:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
        OS_EXIT_CRITICAL();
100065a4:	10a30000 	addk	r5, r3, r0
100065a8:	b9f419b4 	brlid	r15, 6580	// 10007f5c <OS_CPU_SR_Restore>
100065ac:	e264003b 	lbui	r19, r4, 59
        return (stat);
100065b0:	b810005c 	brid	92		// 1000660c
100065b4:	10730000 	addk	r3, r19, r0
    }
    OS_ENTER_CRITICAL();
100065b8:	b9f41974 	brlid	r15, 6516	// 10007f2c <OS_CPU_SR_Save>
100065bc:	66d60402 	bslli	r22, r22, 2
100065c0:	10a30000 	addk	r5, r3, r0
    ptcb = OSTCBPrioTbl[prio];
100065c4:	b0001000 	imm	4096
100065c8:	e876e0a4 	lwi	r3, r22, -8028
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
100065cc:	be230018 	bneid	r3, 24		// 100065e4
100065d0:	a8830001 	xori	r4, r3, 1
        OS_EXIT_CRITICAL();
100065d4:	b9f41988 	brlid	r15, 6536	// 10007f5c <OS_CPU_SR_Restore>
100065d8:	32600043 	addik	r19, r0, 67
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
100065dc:	b8100030 	brid	48		// 1000660c
100065e0:	10730000 	addk	r3, r19, r0
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
100065e4:	be240018 	bneid	r4, 24		// 100065fc
100065e8:	3080003f 	addik	r4, r0, 63
        OS_EXIT_CRITICAL();
100065ec:	b9f41970 	brlid	r15, 6512	// 10007f5c <OS_CPU_SR_Restore>
100065f0:	3260003d 	addik	r19, r0, 61
        return (OS_ERR_TASK_DEL);
100065f4:	b8100018 	brid	24		// 1000660c
100065f8:	10730000 	addk	r3, r19, r0
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
    OS_EXIT_CRITICAL();
100065fc:	b9f41960 	brlid	r15, 6496	// 10007f5c <OS_CPU_SR_Restore>
10006600:	f083003b 	sbi	r4, r3, 59
    return (OS_ERR_NONE);
10006604:	12600000 	addk	r19, r0, r0
}
10006608:	10730000 	addk	r3, r19, r0
1000660c:	e9e10000 	lwi	r15, r1, 0
10006610:	ea61001c 	lwi	r19, r1, 28
10006614:	eac10020 	lwi	r22, r1, 32
10006618:	b60f0008 	rtsd	r15, 8
1000661c:	30210024 	addik	r1, r1, 36

10006620 <OSTaskNameGet>:
    if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
10006620:	b0001000 	imm	4096
10006624:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>

#if OS_TASK_NAME_EN > 0u
INT8U  OSTaskNameGet (INT8U    prio,
                      INT8U  **pname,
                      INT8U   *perr)
{
10006628:	3021ffd0 	addik	r1, r1, -48
1000662c:	fa61001c 	swi	r19, r1, 28
10006630:	fac10020 	swi	r22, r1, 32
10006634:	fb21002c 	swi	r25, r1, 44
10006638:	f9e10000 	swi	r15, r1, 0
1000663c:	fae10024 	swi	r23, r1, 36
10006640:	fb010028 	swi	r24, r1, 40
10006644:	12650000 	addk	r19, r5, r0
10006648:	13260000 	addk	r25, r6, r0
    if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
        return (0u);
    }
#endif
    if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
1000664c:	be030018 	beqid	r3, 24		// 10006664
10006650:	12c70000 	addk	r22, r7, r0
        *perr = OS_ERR_NAME_GET_ISR;
10006654:	30600011 	addik	r3, r0, 17
10006658:	f0670000 	sbi	r3, r7, 0
        return (0u);
1000665c:	b810008c 	brid	140		// 100066e8
10006660:	12600000 	addk	r19, r0, r0
    }
    OS_ENTER_CRITICAL();
10006664:	b9f418c8 	brlid	r15, 6344	// 10007f2c <OS_CPU_SR_Save>
10006668:	80000000 	or	r0, r0, r0
1000666c:	12e30000 	addk	r23, r3, r0
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
10006670:	a87300ff 	xori	r3, r19, 255
10006674:	be230018 	bneid	r3, 24		// 1000668c
10006678:	66730402 	bslli	r19, r19, 2
        prio = OSTCBCur->OSTCBPrio;
1000667c:	b0001000 	imm	4096
10006680:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10006684:	e2630036 	lbui	r19, r3, 54
    }
    ptcb = OSTCBPrioTbl[prio];
10006688:	66730402 	bslli	r19, r19, 2
1000668c:	b0001000 	imm	4096
10006690:	ea73e0a4 	lwi	r19, r19, -8028
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
10006694:	be33001c 	bneid	r19, 28		// 100066b0
10006698:	ab130001 	xori	r24, r19, 1
        OS_EXIT_CRITICAL();                              /* No                                         */
1000669c:	b9f418c0 	brlid	r15, 6336	// 10007f5c <OS_CPU_SR_Restore>
100066a0:	10b70000 	addk	r5, r23, r0
        *perr = OS_ERR_TASK_NOT_EXIST;
100066a4:	30600043 	addik	r3, r0, 67
        return (0u);
100066a8:	b8100040 	brid	64		// 100066e8
100066ac:	f0760000 	sbi	r3, r22, 0
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
100066b0:	be38001c 	bneid	r24, 28		// 100066cc
100066b4:	10b70000 	addk	r5, r23, r0
        OS_EXIT_CRITICAL();                              /* Yes                                        */
100066b8:	b9f418a4 	brlid	r15, 6308	// 10007f5c <OS_CPU_SR_Restore>
100066bc:	12780000 	addk	r19, r24, r0
        *perr = OS_ERR_TASK_NOT_EXIST;
100066c0:	30600043 	addik	r3, r0, 67
        return (0u);
100066c4:	b8100024 	brid	36		// 100066e8
100066c8:	f0760000 	sbi	r3, r22, 0
    }
    *pname = ptcb->OSTCBTaskName;
100066cc:	e8b30050 	lwi	r5, r19, 80
    len    = OS_StrLen(*pname);
100066d0:	b9f4c554 	brlid	r15, -15020	// 10002c24 <OS_StrLen>
100066d4:	f8b90000 	swi	r5, r25, 0
    OS_EXIT_CRITICAL();
100066d8:	10b70000 	addk	r5, r23, r0
100066dc:	b9f41880 	brlid	r15, 6272	// 10007f5c <OS_CPU_SR_Restore>
100066e0:	12630000 	addk	r19, r3, r0
    *perr  = OS_ERR_NONE;
100066e4:	f0160000 	sbi	r0, r22, 0
    return (len);
}
100066e8:	10730000 	addk	r3, r19, r0
100066ec:	e9e10000 	lwi	r15, r1, 0
100066f0:	ea61001c 	lwi	r19, r1, 28
100066f4:	eac10020 	lwi	r22, r1, 32
100066f8:	eae10024 	lwi	r23, r1, 36
100066fc:	eb010028 	lwi	r24, r1, 40
10006700:	eb21002c 	lwi	r25, r1, 44
10006704:	b60f0008 	rtsd	r15, 8
10006708:	30210030 	addik	r1, r1, 48

1000670c <OSTaskNameSet>:
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
        return;
    }
#endif
    if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
1000670c:	b0001000 	imm	4096
10006710:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
*/
#if OS_TASK_NAME_EN > 0u
void  OSTaskNameSet (INT8U   prio,
                     INT8U  *pname,
                     INT8U  *perr)
{
10006714:	3021ffd8 	addik	r1, r1, -40
10006718:	fa61001c 	swi	r19, r1, 28
1000671c:	fac10020 	swi	r22, r1, 32
10006720:	fae10024 	swi	r23, r1, 36
10006724:	f9e10000 	swi	r15, r1, 0
10006728:	12c50000 	addk	r22, r5, r0
1000672c:	12e60000 	addk	r23, r6, r0
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
        return;
    }
#endif
    if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
10006730:	be030010 	beqid	r3, 16		// 10006740
10006734:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_NAME_SET_ISR;
10006738:	b8100050 	brid	80		// 10006788
1000673c:	30600012 	addik	r3, r0, 18
        return;
    }
    OS_ENTER_CRITICAL();
10006740:	b9f417ec 	brlid	r15, 6124	// 10007f2c <OS_CPU_SR_Save>
10006744:	80000000 	or	r0, r0, r0
10006748:	10a30000 	addk	r5, r3, r0
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
1000674c:	a87600ff 	xori	r3, r22, 255
10006750:	be230018 	bneid	r3, 24		// 10006768
10006754:	66d60402 	bslli	r22, r22, 2
        prio = OSTCBCur->OSTCBPrio;
10006758:	b0001000 	imm	4096
1000675c:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10006760:	e2c30036 	lbui	r22, r3, 54
    }
    ptcb = OSTCBPrioTbl[prio];
10006764:	66d60402 	bslli	r22, r22, 2
10006768:	b0001000 	imm	4096
1000676c:	e876e0a4 	lwi	r3, r22, -8028
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
10006770:	bc03000c 	beqi	r3, 12		// 1000677c
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
        return;
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
10006774:	a8830001 	xori	r4, r3, 1
10006778:	bc240018 	bnei	r4, 24		// 10006790
        OS_EXIT_CRITICAL();                          /* Yes                                            */
1000677c:	b9f417e0 	brlid	r15, 6112	// 10007f5c <OS_CPU_SR_Restore>
10006780:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_TASK_NOT_EXIST;
10006784:	30600043 	addik	r3, r0, 67
        return;
10006788:	b8100014 	brid	20		// 1000679c
1000678c:	f0730000 	sbi	r3, r19, 0
    }
    ptcb->OSTCBTaskName = pname;
    OS_EXIT_CRITICAL();
10006790:	b9f417cc 	brlid	r15, 6092	// 10007f5c <OS_CPU_SR_Restore>
10006794:	fae30050 	swi	r23, r3, 80
    *perr               = OS_ERR_NONE;
10006798:	f0130000 	sbi	r0, r19, 0
}
1000679c:	e9e10000 	lwi	r15, r1, 0
100067a0:	ea61001c 	lwi	r19, r1, 28
100067a4:	eac10020 	lwi	r22, r1, 32
100067a8:	eae10024 	lwi	r23, r1, 36
100067ac:	b60f0008 	rtsd	r15, 8
100067b0:	30210028 	addik	r1, r1, 40

100067b4 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0u
INT8U  OSTaskResume (INT8U prio)
{
100067b4:	3021ffdc 	addik	r1, r1, -36
100067b8:	fa61001c 	swi	r19, r1, 28
100067bc:	12650000 	addk	r19, r5, r0
100067c0:	f9e10000 	swi	r15, r1, 0
#if OS_ARG_CHK_EN > 0u
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
100067c4:	b9f41768 	brlid	r15, 5992	// 10007f2c <OS_CPU_SR_Save>
100067c8:	fac10020 	swi	r22, r1, 32
100067cc:	10a30000 	addk	r5, r3, r0
    ptcb = OSTCBPrioTbl[prio];
100067d0:	64730402 	bslli	r3, r19, 2
100067d4:	b0001000 	imm	4096
100067d8:	e883e0a4 	lwi	r4, r3, -8028
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
100067dc:	bc240014 	bnei	r4, 20		// 100067f0
        OS_EXIT_CRITICAL();
100067e0:	b9f4177c 	brlid	r15, 6012	// 10007f5c <OS_CPU_SR_Restore>
100067e4:	32600046 	addik	r19, r0, 70
        return (OS_ERR_TASK_RESUME_PRIO);
100067e8:	b81000c8 	brid	200		// 100068b0
100067ec:	10730000 	addk	r3, r19, r0
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
100067f0:	a8640001 	xori	r3, r4, 1
100067f4:	bc230014 	bnei	r3, 20		// 10006808
        OS_EXIT_CRITICAL();
100067f8:	b9f41764 	brlid	r15, 5988	// 10007f5c <OS_CPU_SR_Restore>
100067fc:	32600043 	addik	r19, r0, 67
        return (OS_ERR_TASK_NOT_EXIST);
10006800:	b81000b0 	brid	176		// 100068b0
10006804:	10730000 	addk	r3, r19, r0
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
10006808:	e2640034 	lbui	r19, r4, 52
1000680c:	a4730008 	andi	r3, r19, 8
10006810:	be030094 	beqid	r3, 148		// 100068a4
10006814:	a67300f7 	andi	r19, r19, 247
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
10006818:	be33007c 	bneid	r19, 124		// 10006894
1000681c:	f2640034 	sbi	r19, r4, 52
            if (ptcb->OSTCBDly == 0u) {
10006820:	eac40030 	lwi	r22, r4, 48
10006824:	bc360060 	bnei	r22, 96		// 10006884
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
10006828:	e0c4003a 	lbui	r6, r4, 58
1000682c:	b0001000 	imm	4096
10006830:	e060d3f8 	lbui	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006834:	80661800 	or	r3, r6, r3
10006838:	b0001000 	imm	4096
1000683c:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10006840:	e0640038 	lbui	r3, r4, 56
10006844:	e0840039 	lbui	r4, r4, 57
10006848:	b0001000 	imm	4096
1000684c:	e0c3d3fc 	lbui	r6, r3, -11268
10006850:	80862000 	or	r4, r6, r4
10006854:	b0001000 	imm	4096
10006858:	f083d3fc 	sbi	r4, r3, -11268
                OS_EXIT_CRITICAL();
1000685c:	b9f41700 	brlid	r15, 5888	// 10007f5c <OS_CPU_SR_Restore>
10006860:	12760000 	addk	r19, r22, r0
                if (OSRunning == OS_TRUE) {
10006864:	b0001000 	imm	4096
10006868:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
1000686c:	a8630001 	xori	r3, r3, 1
10006870:	bc23003c 	bnei	r3, 60		// 100068ac
                    OS_Sched();                               /* Find new highest priority task        */
10006874:	b9f4bf4c 	brlid	r15, -16564	// 100027c0 <OS_Sched>
10006878:	80000000 	or	r0, r0, r0
        }
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
}
1000687c:	b8100034 	brid	52		// 100068b0
10006880:	10730000 	addk	r3, r19, r0
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
                    OS_Sched();                               /* Find new highest priority task        */
                }
            } else {
                OS_EXIT_CRITICAL();
10006884:	b9f416d8 	brlid	r15, 5848	// 10007f5c <OS_CPU_SR_Restore>
10006888:	80000000 	or	r0, r0, r0
        }
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
}
1000688c:	b8100024 	brid	36		// 100068b0
10006890:	10730000 	addk	r3, r19, r0
                }
            } else {
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
10006894:	b9f416c8 	brlid	r15, 5832	// 10007f5c <OS_CPU_SR_Restore>
10006898:	12600000 	addk	r19, r0, r0
        }
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
}
1000689c:	b8100014 	brid	20		// 100068b0
100068a0:	10730000 	addk	r3, r19, r0
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();
100068a4:	b9f416b8 	brlid	r15, 5816	// 10007f5c <OS_CPU_SR_Restore>
100068a8:	32600044 	addik	r19, r0, 68	// 44 <STK_OFFSET_R19>
    return (OS_ERR_TASK_NOT_SUSPENDED);
}
100068ac:	10730000 	addk	r3, r19, r0
100068b0:	e9e10000 	lwi	r15, r1, 0
100068b4:	ea61001c 	lwi	r19, r1, 28
100068b8:	eac10020 	lwi	r22, r1, 32
100068bc:	b60f0008 	rtsd	r15, 8
100068c0:	30210024 	addik	r1, r1, 36

100068c4 <OSTaskStkChk>:
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
INT8U  OSTaskStkChk (INT8U         prio,
                     OS_STK_DATA  *p_stk_data)
{
100068c4:	3021ffd8 	addik	r1, r1, -40
100068c8:	fac10020 	swi	r22, r1, 32
100068cc:	12c50000 	addk	r22, r5, r0
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
100068d0:	f8060000 	swi	r0, r6, 0
    p_stk_data->OSUsed = 0u;
100068d4:	f8060004 	swi	r0, r6, 4
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
INT8U  OSTaskStkChk (INT8U         prio,
                     OS_STK_DATA  *p_stk_data)
{
100068d8:	fa61001c 	swi	r19, r1, 28
100068dc:	f9e10000 	swi	r15, r1, 0
100068e0:	fae10024 	swi	r23, r1, 36
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
    p_stk_data->OSUsed = 0u;
    OS_ENTER_CRITICAL();
100068e4:	b9f41648 	brlid	r15, 5704	// 10007f2c <OS_CPU_SR_Save>
100068e8:	12660000 	addk	r19, r6, r0
100068ec:	10a30000 	addk	r5, r3, r0
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
100068f0:	a87600ff 	xori	r3, r22, 255
100068f4:	be230018 	bneid	r3, 24		// 1000690c
100068f8:	66d60402 	bslli	r22, r22, 2
        prio = OSTCBCur->OSTCBPrio;
100068fc:	b0001000 	imm	4096
10006900:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10006904:	e2c30036 	lbui	r22, r3, 54
    }
    ptcb = OSTCBPrioTbl[prio];
10006908:	66d60402 	bslli	r22, r22, 2
1000690c:	b0001000 	imm	4096
10006910:	e876e0a4 	lwi	r3, r22, -8028
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
10006914:	bc03000c 	beqi	r3, 12		// 10006920
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
    }
    if (ptcb == OS_TCB_RESERVED) {
10006918:	a8830001 	xori	r4, r3, 1
1000691c:	bc240014 	bnei	r4, 20		// 10006930
        OS_EXIT_CRITICAL();
10006920:	b9f4163c 	brlid	r15, 5692	// 10007f5c <OS_CPU_SR_Restore>
10006924:	80000000 	or	r0, r0, r0
        return (OS_ERR_TASK_NOT_EXIST);
10006928:	b8100060 	brid	96		// 10006988
1000692c:	30600043 	addik	r3, r0, 67
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
10006930:	e4830010 	lhui	r4, r3, 16
10006934:	a4840001 	andi	r4, r4, 1
10006938:	bc240014 	bnei	r4, 20		// 1000694c
        OS_EXIT_CRITICAL();
1000693c:	b9f41620 	brlid	r15, 5664	// 10007f5c <OS_CPU_SR_Restore>
10006940:	80000000 	or	r0, r0, r0
        return (OS_ERR_TASK_OPT);
10006944:	b8100044 	brid	68		// 10006988
10006948:	30600045 	addik	r3, r0, 69
    }
    nfree = 0u;
    size  = ptcb->OSTCBStkSize;
1000694c:	eae3000c 	lwi	r23, r3, 12
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
10006950:	b9f4160c 	brlid	r15, 5644	// 10007f5c <OS_CPU_SR_Restore>
10006954:	eac30008 	lwi	r22, r3, 8
#if OS_STK_GROWTH == 1u
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
10006958:	b810000c 	brid	12		// 10006964
1000695c:	10600000 	addk	r3, r0, r0
        nfree++;
10006960:	30630001 	addik	r3, r3, 1
    nfree = 0u;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1u
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
10006964:	e8960000 	lwi	r4, r22, 0
10006968:	be04fff8 	beqid	r4, -8		// 10006960
1000696c:	32d60004 	addik	r22, r22, 4
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
10006970:	64830402 	bslli	r4, r3, 2
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
10006974:	1463b800 	rsubk	r3, r3, r23
10006978:	64630402 	bslli	r3, r3, 2
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
1000697c:	f8930000 	swi	r4, r19, 0
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
10006980:	f8730004 	swi	r3, r19, 4
    return (OS_ERR_NONE);
10006984:	10600000 	addk	r3, r0, r0
}
10006988:	e9e10000 	lwi	r15, r1, 0
1000698c:	ea61001c 	lwi	r19, r1, 28
10006990:	eac10020 	lwi	r22, r1, 32
10006994:	eae10024 	lwi	r23, r1, 36
10006998:	b60f0008 	rtsd	r15, 8
1000699c:	30210028 	addik	r1, r1, 40

100069a0 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0u
INT8U  OSTaskSuspend (INT8U prio)
{
100069a0:	3021ffdc 	addik	r1, r1, -36
100069a4:	fa61001c 	swi	r19, r1, 28
100069a8:	12650000 	addk	r19, r5, r0
100069ac:	f9e10000 	swi	r15, r1, 0
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
#endif
    OS_ENTER_CRITICAL();
100069b0:	b9f4157c 	brlid	r15, 5500	// 10007f2c <OS_CPU_SR_Save>
100069b4:	fac10020 	swi	r22, r1, 32
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
100069b8:	a89300ff 	xori	r4, r19, 255
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
#endif
    OS_ENTER_CRITICAL();
100069bc:	10a30000 	addk	r5, r3, r0
100069c0:	b0001000 	imm	4096
100069c4:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
100069c8:	be240010 	bneid	r4, 16		// 100069d8
100069cc:	32c00001 	addik	r22, r0, 1
        prio = OSTCBCur->OSTCBPrio;
100069d0:	b8100010 	brid	16		// 100069e0
100069d4:	e2630036 	lbui	r19, r3, 54
        self = OS_TRUE;
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
100069d8:	e2c30036 	lbui	r22, r3, 54
        self = OS_TRUE;
100069dc:	8ad69c00 	pcmpeq	r22, r22, r19
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
    }
    ptcb = OSTCBPrioTbl[prio];
100069e0:	66730402 	bslli	r19, r19, 2
100069e4:	b0001000 	imm	4096
100069e8:	e893e0a4 	lwi	r4, r19, -8028
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
100069ec:	bc240014 	bnei	r4, 20		// 10006a00
        OS_EXIT_CRITICAL();
100069f0:	b9f4156c 	brlid	r15, 5484	// 10007f5c <OS_CPU_SR_Restore>
100069f4:	32600048 	addik	r19, r0, 72	// 48 <STK_OFFSET_R20>
        return (OS_ERR_TASK_SUSPEND_PRIO);
100069f8:	b810008c 	brid	140		// 10006a84
100069fc:	10730000 	addk	r3, r19, r0
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
10006a00:	a8640001 	xori	r3, r4, 1
10006a04:	bc230014 	bnei	r3, 20		// 10006a18
        OS_EXIT_CRITICAL();
10006a08:	b9f41554 	brlid	r15, 5460	// 10007f5c <OS_CPU_SR_Restore>
10006a0c:	32600043 	addik	r19, r0, 67
        return (OS_ERR_TASK_NOT_EXIST);
10006a10:	b8100074 	brid	116		// 10006a84
10006a14:	10730000 	addk	r3, r19, r0
    }
    y            = ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
10006a18:	e0c40038 	lbui	r6, r4, 56
10006a1c:	e0640039 	lbui	r3, r4, 57
10006a20:	b0001000 	imm	4096
10006a24:	e0e6d3fc 	lbui	r7, r6, -11268
10006a28:	a863ffff 	xori	r3, r3, -1
10006a2c:	84633800 	and	r3, r3, r7
10006a30:	b0001000 	imm	4096
10006a34:	f066d3fc 	sbi	r3, r6, -11268
    if (OSRdyTbl[y] == 0u) {
10006a38:	bc230020 	bnei	r3, 32		// 10006a58
        OSRdyGrp &= ~ptcb->OSTCBBitY;
10006a3c:	e064003a 	lbui	r3, r4, 58
10006a40:	b0001000 	imm	4096
10006a44:	e0c0d3f8 	lbui	r6, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006a48:	a863ffff 	xori	r3, r3, -1
10006a4c:	84633000 	and	r3, r3, r6
10006a50:	b0001000 	imm	4096
10006a54:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
10006a58:	e0640034 	lbui	r3, r4, 52
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
10006a5c:	aad60001 	xori	r22, r22, 1
        OS_Sched();                                             /* Find new highest priority task      */
    }
    return (OS_ERR_NONE);
10006a60:	12600000 	addk	r19, r0, r0
    y            = ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
    if (OSRdyTbl[y] == 0u) {
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
10006a64:	a0630008 	ori	r3, r3, 8
    OS_EXIT_CRITICAL();
10006a68:	b9f414f4 	brlid	r15, 5364	// 10007f5c <OS_CPU_SR_Restore>
10006a6c:	f0640034 	sbi	r3, r4, 52
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
10006a70:	be360014 	bneid	r22, 20		// 10006a84
10006a74:	10730000 	addk	r3, r19, r0
        OS_Sched();                                             /* Find new highest priority task      */
10006a78:	b9f4bd48 	brlid	r15, -17080	// 100027c0 <OS_Sched>
10006a7c:	80000000 	or	r0, r0, r0
    }
    return (OS_ERR_NONE);
}
10006a80:	10730000 	addk	r3, r19, r0
10006a84:	e9e10000 	lwi	r15, r1, 0
10006a88:	ea61001c 	lwi	r19, r1, 28
10006a8c:	eac10020 	lwi	r22, r1, 32
10006a90:	b60f0008 	rtsd	r15, 8
10006a94:	30210024 	addik	r1, r1, 36

10006a98 <OSTaskQuery>:
*/

#if OS_TASK_QUERY_EN > 0u
INT8U  OSTaskQuery (INT8U    prio,
                    OS_TCB  *p_task_data)
{
10006a98:	3021ffd8 	addik	r1, r1, -40
10006a9c:	fac10020 	swi	r22, r1, 32
10006aa0:	12c50000 	addk	r22, r5, r0
10006aa4:	fa61001c 	swi	r19, r1, 28
10006aa8:	fae10024 	swi	r23, r1, 36
10006aac:	f9e10000 	swi	r15, r1, 0
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
        return (OS_ERR_PDATA_NULL);
    }
#endif
    OS_ENTER_CRITICAL();
10006ab0:	b9f4147c 	brlid	r15, 5244	// 10007f2c <OS_CPU_SR_Save>
10006ab4:	12e60000 	addk	r23, r6, r0
10006ab8:	12630000 	addk	r19, r3, r0
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
10006abc:	a87600ff 	xori	r3, r22, 255
10006ac0:	be230018 	bneid	r3, 24		// 10006ad8
10006ac4:	66d60402 	bslli	r22, r22, 2
        prio = OSTCBCur->OSTCBPrio;
10006ac8:	b0001000 	imm	4096
10006acc:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
10006ad0:	e2c30036 	lbui	r22, r3, 54
    }
    ptcb = OSTCBPrioTbl[prio];
10006ad4:	66d60402 	bslli	r22, r22, 2
10006ad8:	b0001000 	imm	4096
10006adc:	e876e0a4 	lwi	r3, r22, -8028
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
10006ae0:	be230018 	bneid	r3, 24		// 10006af8
10006ae4:	a8830001 	xori	r4, r3, 1
        OS_EXIT_CRITICAL();
10006ae8:	b9f41474 	brlid	r15, 5236	// 10007f5c <OS_CPU_SR_Restore>
10006aec:	10b30000 	addk	r5, r19, r0
        return (OS_ERR_PRIO);
10006af0:	b8100038 	brid	56		// 10006b28
10006af4:	30600029 	addik	r3, r0, 41
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
10006af8:	be240018 	bneid	r4, 24		// 10006b10
10006afc:	10c30000 	addk	r6, r3, r0
        OS_EXIT_CRITICAL();
10006b00:	b9f4145c 	brlid	r15, 5212	// 10007f5c <OS_CPU_SR_Restore>
10006b04:	10b30000 	addk	r5, r19, r0
        return (OS_ERR_TASK_NOT_EXIST);
10006b08:	b8100020 	brid	32		// 10006b28
10006b0c:	30600043 	addik	r3, r0, 67
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
10006b10:	10b70000 	addk	r5, r23, r0
10006b14:	b9f4bc80 	brlid	r15, -17280	// 10002794 <OS_MemCopy>
10006b18:	30e00058 	addik	r7, r0, 88	// 58 <STK_OFFSET_R24>
    OS_EXIT_CRITICAL();
10006b1c:	b9f41440 	brlid	r15, 5184	// 10007f5c <OS_CPU_SR_Restore>
10006b20:	10b30000 	addk	r5, r19, r0
    return (OS_ERR_NONE);
10006b24:	10600000 	addk	r3, r0, r0
}
10006b28:	e9e10000 	lwi	r15, r1, 0
10006b2c:	ea61001c 	lwi	r19, r1, 28
10006b30:	eac10020 	lwi	r22, r1, 32
10006b34:	eae10024 	lwi	r23, r1, 36
10006b38:	b60f0008 	rtsd	r15, 8
10006b3c:	30210028 	addik	r1, r1, 40

10006b40 <OSTaskRegGet>:

#if OS_TASK_REG_TBL_SIZE > 0u
INT32U  OSTaskRegGet (INT8U   prio,
                      INT8U   id,
                      INT8U  *perr)
{
10006b40:	3021ffd8 	addik	r1, r1, -40
10006b44:	fa61001c 	swi	r19, r1, 28
10006b48:	12650000 	addk	r19, r5, r0
10006b4c:	fac10020 	swi	r22, r1, 32
10006b50:	fae10024 	swi	r23, r1, 36
10006b54:	f9e10000 	swi	r15, r1, 0
10006b58:	12e60000 	addk	r23, r6, r0
    if (id >= OS_TASK_REG_TBL_SIZE) {
        *perr = OS_ERR_ID_INVALID;
        return (0u);
    }
#endif
    OS_ENTER_CRITICAL();
10006b5c:	b9f413d0 	brlid	r15, 5072	// 10007f2c <OS_CPU_SR_Save>
10006b60:	12c70000 	addk	r22, r7, r0
    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
10006b64:	a89300ff 	xori	r4, r19, 255
10006b68:	be240018 	bneid	r4, 24		// 10006b80
10006b6c:	66730402 	bslli	r19, r19, 2
        ptcb = OSTCBCur;
10006b70:	b0001000 	imm	4096
10006b74:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    } else {
        ptcb = OSTCBPrioTbl[prio];
    }
    value = ptcb->OSTCBRegTbl[id];
10006b78:	b8100014 	brid	20		// 10006b8c
10006b7c:	30d70015 	addik	r6, r23, 21
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
        ptcb = OSTCBCur;
    } else {
        ptcb = OSTCBPrioTbl[prio];
10006b80:	b0001000 	imm	4096
10006b84:	e893e0a4 	lwi	r4, r19, -8028
    }
    value = ptcb->OSTCBRegTbl[id];
10006b88:	30d70015 	addik	r6, r23, 21
10006b8c:	64c60402 	bslli	r6, r6, 2
    OS_EXIT_CRITICAL();
10006b90:	10a30000 	addk	r5, r3, r0
10006b94:	b9f413c8 	brlid	r15, 5064	// 10007f5c <OS_CPU_SR_Restore>
10006b98:	ca662000 	lw	r19, r6, r4
    *perr = OS_ERR_NONE;
    return (value);
}
10006b9c:	10730000 	addk	r3, r19, r0
    } else {
        ptcb = OSTCBPrioTbl[prio];
    }
    value = ptcb->OSTCBRegTbl[id];
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
10006ba0:	f0160000 	sbi	r0, r22, 0
    return (value);
}
10006ba4:	e9e10000 	lwi	r15, r1, 0
10006ba8:	ea61001c 	lwi	r19, r1, 28
10006bac:	eac10020 	lwi	r22, r1, 32
10006bb0:	eae10024 	lwi	r23, r1, 36
10006bb4:	b60f0008 	rtsd	r15, 8
10006bb8:	30210028 	addik	r1, r1, 40

10006bbc <OSTaskRegSet>:
#if OS_TASK_REG_TBL_SIZE > 0u
void  OSTaskRegSet (INT8U    prio,
                    INT8U    id,
                    INT32U   value,
                    INT8U   *perr)
{
10006bbc:	3021ffd4 	addik	r1, r1, -44
10006bc0:	fa61001c 	swi	r19, r1, 28
10006bc4:	12650000 	addk	r19, r5, r0
10006bc8:	fac10020 	swi	r22, r1, 32
10006bcc:	fae10024 	swi	r23, r1, 36
10006bd0:	fb010028 	swi	r24, r1, 40
10006bd4:	f9e10000 	swi	r15, r1, 0
10006bd8:	13060000 	addk	r24, r6, r0
10006bdc:	12e70000 	addk	r23, r7, r0
    if (id >= OS_TASK_REG_TBL_SIZE) {
        *perr = OS_ERR_ID_INVALID;
        return;
    }
#endif
    OS_ENTER_CRITICAL();
10006be0:	b9f4134c 	brlid	r15, 4940	// 10007f2c <OS_CPU_SR_Save>
10006be4:	12c80000 	addk	r22, r8, r0
    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
10006be8:	a89300ff 	xori	r4, r19, 255
10006bec:	be240018 	bneid	r4, 24		// 10006c04
10006bf0:	66730402 	bslli	r19, r19, 2
        ptcb = OSTCBCur;
10006bf4:	b0001000 	imm	4096
10006bf8:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
    } else {
        ptcb = OSTCBPrioTbl[prio];
    }
    ptcb->OSTCBRegTbl[id] = value;
10006bfc:	b8100014 	brid	20		// 10006c10
10006c00:	30d80015 	addik	r6, r24, 21
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
        ptcb = OSTCBCur;
    } else {
        ptcb = OSTCBPrioTbl[prio];
10006c04:	b0001000 	imm	4096
10006c08:	e893e0a4 	lwi	r4, r19, -8028
    }
    ptcb->OSTCBRegTbl[id] = value;
10006c0c:	30d80015 	addik	r6, r24, 21
10006c10:	64c60402 	bslli	r6, r6, 2
    OS_EXIT_CRITICAL();
10006c14:	10a30000 	addk	r5, r3, r0
10006c18:	b9f41344 	brlid	r15, 4932	// 10007f5c <OS_CPU_SR_Restore>
10006c1c:	dae62000 	sw	r23, r6, r4
    *perr                 = OS_ERR_NONE;
}
10006c20:	e9e10000 	lwi	r15, r1, 0
    } else {
        ptcb = OSTCBPrioTbl[prio];
    }
    ptcb->OSTCBRegTbl[id] = value;
    OS_EXIT_CRITICAL();
    *perr                 = OS_ERR_NONE;
10006c24:	f0160000 	sbi	r0, r22, 0
}
10006c28:	ea61001c 	lwi	r19, r1, 28
10006c2c:	eac10020 	lwi	r22, r1, 32
10006c30:	eae10024 	lwi	r23, r1, 36
10006c34:	eb010028 	lwi	r24, r1, 40
10006c38:	b60f0008 	rtsd	r15, 8
10006c3c:	3021002c 	addik	r1, r1, 44

10006c40 <OS_TaskReturn>:
*********************************************************************************************************
*/

void  OS_TaskReturn (void)
{
    OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
10006c40:	b0001000 	imm	4096
10006c44:	e8a0d60c 	lwi	r5, r0, -10740	// 1000d60c <OSTCBCur>
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_TaskReturn (void)
{
10006c48:	3021ffe4 	addik	r1, r1, -28
10006c4c:	f9e10000 	swi	r15, r1, 0
    OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
10006c50:	b9f40fd4 	brlid	r15, 4052	// 10007c24 <OSTaskReturnHook>
10006c54:	80000000 	or	r0, r0, r0

#if OS_TASK_DEL_EN > 0u
    (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
10006c58:	b9f4f704 	brlid	r15, -2300	// 1000635c <OSTaskDel>
10006c5c:	30a000ff 	addik	r5, r0, 255
#else
    for (;;) {
        OSTimeDly(OS_TICKS_PER_SEC);
    }
#endif
}
10006c60:	e9e10000 	lwi	r15, r1, 0
10006c64:	b60f0008 	rtsd	r15, 8
10006c68:	3021001c 	addik	r1, r1, 28

10006c6c <OS_TaskStkClr>:
#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
void  OS_TaskStkClr (OS_STK  *pbos,
                     INT32U   size,
                     INT16U   opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
10006c6c:	a4670001 	andi	r3, r7, 1
10006c70:	bc030024 	beqi	r3, 36		// 10006c94
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
10006c74:	a4e70002 	andi	r7, r7, 2
10006c78:	bc270018 	bnei	r7, 24		// 10006c90
10006c7c:	b60f0008 	rtsd	r15, 8
10006c80:	80000000 	or	r0, r0, r0
#if OS_STK_GROWTH == 1u
            while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
10006c84:	f8050000 	swi	r0, r5, 0
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1u
            while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                size--;
10006c88:	30c6ffff 	addik	r6, r6, -1
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
10006c8c:	30a50004 	addik	r5, r5, 4
                     INT16U   opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1u
            while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
10006c90:	bc26fff4 	bnei	r6, -12		// 10006c84
10006c94:	b60f0008 	rtsd	r15, 8
10006c98:	80000000 	or	r0, r0, r0

10006c9c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
10006c9c:	3021ffb8 	addik	r1, r1, -72
10006ca0:	fa610020 	swi	r19, r1, 32
10006ca4:	fb01002c 	swi	r24, r1, 44
10006ca8:	fb210030 	swi	r25, r1, 48
10006cac:	fb410034 	swi	r26, r1, 52
10006cb0:	fb610038 	swi	r27, r1, 56
10006cb4:	fb81003c 	swi	r28, r1, 60
10006cb8:	fba10040 	swi	r29, r1, 64
10006cbc:	fbc10044 	swi	r30, r1, 68
10006cc0:	f9e10000 	swi	r15, r1, 0
10006cc4:	fac10024 	swi	r22, r1, 36
10006cc8:	fae10028 	swi	r23, r1, 40
10006ccc:	13c50000 	addk	r30, r5, r0
10006cd0:	13a60000 	addk	r29, r6, r0
10006cd4:	13870000 	addk	r28, r7, r0
10006cd8:	13280000 	addk	r25, r8, r0
10006cdc:	13690000 	addk	r27, r9, r0
10006ce0:	130a0000 	addk	r24, r10, r0
10006ce4:	eb410064 	lwi	r26, r1, 100
#if OS_ARG_CHK_EN > 0u
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
10006ce8:	b9f41244 	brlid	r15, 4676	// 10007f2c <OS_CPU_SR_Save>
10006cec:	e661006e 	lhui	r19, r1, 110
    if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
10006cf0:	b0001000 	imm	4096
10006cf4:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
10006cf8:	be04001c 	beqid	r4, 28		// 10006d14
10006cfc:	66d90402 	bslli	r22, r25, 2
        OS_EXIT_CRITICAL();
10006d00:	10a30000 	addk	r5, r3, r0
10006d04:	b9f41258 	brlid	r15, 4696	// 10007f5c <OS_CPU_SR_Restore>
10006d08:	3260003c 	addik	r19, r0, 60	// 3c <STK_OFFSET_R17>
        return (OS_ERR_TASK_CREATE_ISR);
10006d0c:	b81000c4 	brid	196		// 10006dd0
10006d10:	10730000 	addk	r3, r19, r0
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
10006d14:	b0001000 	imm	4096
10006d18:	eaf6e0a4 	lwi	r23, r22, -8028
10006d1c:	be3700a8 	bneid	r23, 168		// 10006dc4
10006d20:	10a30000 	addk	r5, r3, r0
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
10006d24:	30800001 	addik	r4, r0, 1
10006d28:	b0001000 	imm	4096
10006d2c:	f896e0a4 	swi	r4, r22, -8028
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
10006d30:	b9f4122c 	brlid	r15, 4652	// 10007f5c <OS_CPU_SR_Restore>
10006d34:	10a30000 	addk	r5, r3, r0

#if (OS_TASK_STAT_STK_CHK_EN > 0u)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
10006d38:	10f30000 	addk	r7, r19, r0
10006d3c:	10b80000 	addk	r5, r24, r0
10006d40:	b9f4ff2c 	brlid	r15, -212	// 10006c6c <OS_TaskStkClr>
10006d44:	10da0000 	addk	r6, r26, r0
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
10006d48:	11130000 	addk	r8, r19, r0
10006d4c:	10be0000 	addk	r5, r30, r0
10006d50:	10dd0000 	addk	r6, r29, r0
10006d54:	b9f40ee8 	brlid	r15, 3816	// 10007c3c <OSTaskStkInit>
10006d58:	10fc0000 	addk	r7, r28, r0
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
10006d5c:	10b90000 	addk	r5, r25, r0
10006d60:	10c30000 	addk	r6, r3, r0
10006d64:	10f80000 	addk	r7, r24, r0
10006d68:	111b0000 	addk	r8, r27, r0
10006d6c:	113a0000 	addk	r9, r26, r0
10006d70:	e9410068 	lwi	r10, r1, 104
10006d74:	b9f4c0c0 	brlid	r15, -16192	// 10002e34 <OS_TCBInit>
10006d78:	fa61001c 	swi	r19, r1, 28
        if (err == OS_ERR_NONE) {
10006d7c:	be230028 	bneid	r3, 40		// 10006da4
10006d80:	12630000 	addk	r19, r3, r0
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
10006d84:	b0001000 	imm	4096
10006d88:	e060ce18 	lbui	r3, r0, -12776	// 1000ce18 <OSRunning>
10006d8c:	a8630001 	xori	r3, r3, 1
10006d90:	bc23003c 	bnei	r3, 60		// 10006dcc
                OS_Sched();
10006d94:	b9f4ba2c 	brlid	r15, -17876	// 100027c0 <OS_Sched>
10006d98:	80000000 	or	r0, r0, r0
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
10006d9c:	b8100034 	brid	52		// 10006dd0
10006da0:	10730000 	addk	r3, r19, r0
        if (err == OS_ERR_NONE) {
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
                OS_Sched();
            }
        } else {
            OS_ENTER_CRITICAL();
10006da4:	b9f41188 	brlid	r15, 4488	// 10007f2c <OS_CPU_SR_Save>
10006da8:	80000000 	or	r0, r0, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
10006dac:	b0001000 	imm	4096
10006db0:	faf6e0a4 	swi	r23, r22, -8028
            OS_EXIT_CRITICAL();
10006db4:	b9f411a8 	brlid	r15, 4520	// 10007f5c <OS_CPU_SR_Restore>
10006db8:	10a30000 	addk	r5, r3, r0
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
10006dbc:	b8100014 	brid	20		// 10006dd0
10006dc0:	10730000 	addk	r3, r19, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
10006dc4:	b9f41198 	brlid	r15, 4504	// 10007f5c <OS_CPU_SR_Restore>
10006dc8:	32600028 	addik	r19, r0, 40	// 28 <STK_OFFSET_R11>
    return (OS_ERR_PRIO_EXIST);
}
10006dcc:	10730000 	addk	r3, r19, r0
10006dd0:	e9e10000 	lwi	r15, r1, 0
10006dd4:	ea610020 	lwi	r19, r1, 32
10006dd8:	eac10024 	lwi	r22, r1, 36
10006ddc:	eae10028 	lwi	r23, r1, 40
10006de0:	eb01002c 	lwi	r24, r1, 44
10006de4:	eb210030 	lwi	r25, r1, 48
10006de8:	eb410034 	lwi	r26, r1, 52
10006dec:	eb610038 	lwi	r27, r1, 56
10006df0:	eb81003c 	lwi	r28, r1, 60
10006df4:	eba10040 	lwi	r29, r1, 64
10006df8:	ebc10044 	lwi	r30, r1, 68
10006dfc:	b60f0008 	rtsd	r15, 8
10006e00:	30210048 	addik	r1, r1, 72

10006e04 <OSTimeDly>:
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10006e04:	b0001000 	imm	4096
10006e08:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT32U ticks)
{
10006e0c:	3021ffe0 	addik	r1, r1, -32
10006e10:	fa61001c 	swi	r19, r1, 28
10006e14:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10006e18:	be230084 	bneid	r3, 132		// 10006e9c
10006e1c:	12650000 	addk	r19, r5, r0
        return;
    }
    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
10006e20:	b0001000 	imm	4096
10006e24:	e060ce10 	lbui	r3, r0, -12784	// 1000ce10 <OSLockNesting>
10006e28:	be230078 	bneid	r3, 120		// 10006ea0
10006e2c:	e9e10000 	lwi	r15, r1, 0
        return;
    }
    if (ticks > 0u) {                            /* 0 means no delay!                                  */
10006e30:	bc050070 	beqi	r5, 112		// 10006ea0
        OS_ENTER_CRITICAL();
10006e34:	b9f410f8 	brlid	r15, 4344	// 10007f2c <OS_CPU_SR_Save>
10006e38:	80000000 	or	r0, r0, r0
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
10006e3c:	b0001000 	imm	4096
10006e40:	e880d60c 	lwi	r4, r0, -10740	// 1000d60c <OSTCBCur>
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
10006e44:	e0c40038 	lbui	r6, r4, 56
10006e48:	e0a40039 	lbui	r5, r4, 57
10006e4c:	b0001000 	imm	4096
10006e50:	e0e6d3fc 	lbui	r7, r6, -11268
10006e54:	a8a5ffff 	xori	r5, r5, -1
10006e58:	84a53800 	and	r5, r5, r7
10006e5c:	b0001000 	imm	4096
10006e60:	f0a6d3fc 	sbi	r5, r6, -11268
        if (OSRdyTbl[y] == 0u) {
10006e64:	be250028 	bneid	r5, 40		// 10006e8c
10006e68:	10a30000 	addk	r5, r3, r0
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
10006e6c:	e0a4003a 	lbui	r5, r4, 58
10006e70:	b0001000 	imm	4096
10006e74:	e0c0d3f8 	lbui	r6, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006e78:	a8a5ffff 	xori	r5, r5, -1
10006e7c:	84a53000 	and	r5, r5, r6
10006e80:	b0001000 	imm	4096
10006e84:	f0a0d3f8 	sbi	r5, r0, -11272	// 1000d3f8 <OSRdyGrp>
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
10006e88:	10a30000 	addk	r5, r3, r0
10006e8c:	b9f410d0 	brlid	r15, 4304	// 10007f5c <OS_CPU_SR_Restore>
10006e90:	fa640030 	swi	r19, r4, 48
        OS_Sched();                              /* Find next task to run!                             */
10006e94:	b9f4b92c 	brlid	r15, -18132	// 100027c0 <OS_Sched>
10006e98:	80000000 	or	r0, r0, r0
    }
}
10006e9c:	e9e10000 	lwi	r15, r1, 0
10006ea0:	ea61001c 	lwi	r19, r1, 28
10006ea4:	b60f0008 	rtsd	r15, 8
10006ea8:	30210020 	addik	r1, r1, 32

10006eac <OSTimeDlyHMSM>:
                      INT16U  ms)
{
    INT32U ticks;


    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10006eac:	b0001000 	imm	4096
10006eb0:	e080d608 	lbui	r4, r0, -10744	// 1000d608 <OSIntNesting>
#if OS_TIME_DLY_HMSM_EN > 0u
INT8U  OSTimeDlyHMSM (INT8U   hours,
                      INT8U   minutes,
                      INT8U   seconds,
                      INT16U  ms)
{
10006eb4:	3021ffe0 	addik	r1, r1, -32
10006eb8:	f9e10000 	swi	r15, r1, 0
10006ebc:	fa61001c 	swi	r19, r1, 28
    INT32U ticks;


    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
10006ec0:	be240048 	bneid	r4, 72		// 10006f08
10006ec4:	30600055 	addik	r3, r0, 85
        return (OS_ERR_TIME_DLY_ISR);
    }
    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
10006ec8:	b0001000 	imm	4096
10006ecc:	e260ce10 	lbui	r19, r0, -12784	// 1000ce10 <OSLockNesting>
10006ed0:	be330038 	bneid	r19, 56		// 10006f08
10006ed4:	30600032 	addik	r3, r0, 50
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
10006ed8:	61080064 	muli	r8, r8, 100
10006edc:	306003e8 	addik	r3, r0, 1000
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
10006ee0:	60c6003c 	muli	r6, r6, 60
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
10006ee4:	310801f4 	addik	r8, r8, 500
10006ee8:	49034002 	idivu	r8, r3, r8
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
10006eec:	60a50e10 	muli	r5, r5, 3600
10006ef0:	10e63800 	addk	r7, r6, r7
10006ef4:	10a72800 	addk	r5, r7, r5
10006ef8:	60a50064 	muli	r5, r5, 100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
    OSTimeDly(ticks);
10006efc:	b9f4ff08 	brlid	r15, -248	// 10006e04 <OSTimeDly>
10006f00:	10a82800 	addk	r5, r8, r5
    return (OS_ERR_NONE);
10006f04:	10730000 	addk	r3, r19, r0
}
10006f08:	e9e10000 	lwi	r15, r1, 0
10006f0c:	ea61001c 	lwi	r19, r1, 28
10006f10:	b60f0008 	rtsd	r15, 8
10006f14:	30210020 	addik	r1, r1, 32

10006f18 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0u
INT8U  OSTimeDlyResume (INT8U prio)
{
10006f18:	3021ffe0 	addik	r1, r1, -32
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (prio >= OS_LOWEST_PRIO) {
10006f1c:	3080003e 	addik	r4, r0, 62
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0u
INT8U  OSTimeDlyResume (INT8U prio)
{
10006f20:	fa61001c 	swi	r19, r1, 28
10006f24:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (prio >= OS_LOWEST_PRIO) {
10006f28:	14852003 	cmpu	r4, r5, r4
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0u
INT8U  OSTimeDlyResume (INT8U prio)
{
10006f2c:	12650000 	addk	r19, r5, r0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    if (prio >= OS_LOWEST_PRIO) {
10006f30:	be4400d4 	bltid	r4, 212		// 10007004
10006f34:	3060002a 	addik	r3, r0, 42
        return (OS_ERR_PRIO_INVALID);
    }
    OS_ENTER_CRITICAL();
10006f38:	b9f40ff4 	brlid	r15, 4084	// 10007f2c <OS_CPU_SR_Save>
10006f3c:	66730402 	bslli	r19, r19, 2
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
10006f40:	b0001000 	imm	4096
10006f44:	e893e0a4 	lwi	r4, r19, -8028
    if (ptcb == (OS_TCB *)0) {
10006f48:	be040010 	beqid	r4, 16		// 10006f58
10006f4c:	10a30000 	addk	r5, r3, r0
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
    }
    if (ptcb == OS_TCB_RESERVED) {
10006f50:	a8640001 	xori	r3, r4, 1
10006f54:	bc230014 	bnei	r3, 20		// 10006f68
        OS_EXIT_CRITICAL();
10006f58:	b9f41004 	brlid	r15, 4100	// 10007f5c <OS_CPU_SR_Restore>
10006f5c:	80000000 	or	r0, r0, r0
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
10006f60:	b81000a4 	brid	164		// 10007004
10006f64:	30600043 	addik	r3, r0, 67
    }
    if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
10006f68:	e8640030 	lwi	r3, r4, 48
10006f6c:	bc230014 	bnei	r3, 20		// 10006f80
        OS_EXIT_CRITICAL();
10006f70:	b9f40fec 	brlid	r15, 4076	// 10007f5c <OS_CPU_SR_Restore>
10006f74:	80000000 	or	r0, r0, r0
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
10006f78:	b810008c 	brid	140		// 10007004
10006f7c:	30600050 	addik	r3, r0, 80	// 50 <STK_OFFSET_R22>
    }

    ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
10006f80:	e0c40034 	lbui	r6, r4, 52
10006f84:	a4660037 	andi	r3, r6, 55
10006f88:	be030014 	beqid	r3, 20		// 10006f9c
10006f8c:	f8040030 	swi	r0, r4, 48
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
10006f90:	a4c6ffc8 	andi	r6, r6, -56
10006f94:	f0c40034 	sbi	r6, r4, 52
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
10006f98:	30600001 	addik	r3, r0, 1
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
10006f9c:	e2640034 	lbui	r19, r4, 52
10006fa0:	a6730008 	andi	r19, r19, 8
10006fa4:	be330054 	bneid	r19, 84		// 10006ff8
10006fa8:	f0640035 	sbi	r3, r4, 53
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
10006fac:	e0c4003a 	lbui	r6, r4, 58
10006fb0:	b0001000 	imm	4096
10006fb4:	e060d3f8 	lbui	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
10006fb8:	80661800 	or	r3, r6, r3
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10006fbc:	e0c40038 	lbui	r6, r4, 56
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
10006fc0:	b0001000 	imm	4096
10006fc4:	f060d3f8 	sbi	r3, r0, -11272	// 1000d3f8 <OSRdyGrp>
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
10006fc8:	e0640039 	lbui	r3, r4, 57
10006fcc:	b0001000 	imm	4096
10006fd0:	e0e6d3fc 	lbui	r7, r6, -11268
10006fd4:	80671800 	or	r3, r7, r3
10006fd8:	b0001000 	imm	4096
10006fdc:	f066d3fc 	sbi	r3, r6, -11268
        OS_EXIT_CRITICAL();
10006fe0:	b9f40f7c 	brlid	r15, 3964	// 10007f5c <OS_CPU_SR_Restore>
10006fe4:	80000000 	or	r0, r0, r0
        OS_Sched();                                            /* See if this is new highest priority  */
10006fe8:	b9f4b7d8 	brlid	r15, -18472	// 100027c0 <OS_Sched>
10006fec:	80000000 	or	r0, r0, r0
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
10006ff0:	b8100014 	brid	20		// 10007004
10006ff4:	10730000 	addk	r3, r19, r0
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
10006ff8:	b9f40f64 	brlid	r15, 3940	// 10007f5c <OS_CPU_SR_Restore>
10006ffc:	80000000 	or	r0, r0, r0
    }
    return (OS_ERR_NONE);
10007000:	10600000 	addk	r3, r0, r0
}
10007004:	e9e10000 	lwi	r15, r1, 0
10007008:	ea61001c 	lwi	r19, r1, 28
1000700c:	b60f0008 	rtsd	r15, 8
10007010:	30210020 	addik	r1, r1, 32

10007014 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0u
INT32U  OSTimeGet (void)
{
10007014:	3021ffe0 	addik	r1, r1, -32
10007018:	f9e10000 	swi	r15, r1, 0
    OS_CPU_SR  cpu_sr = 0u;
#endif



    OS_ENTER_CRITICAL();
1000701c:	b9f40f10 	brlid	r15, 3856	// 10007f2c <OS_CPU_SR_Save>
10007020:	fa61001c 	swi	r19, r1, 28
    ticks = OSTime;
    OS_EXIT_CRITICAL();
10007024:	10a30000 	addk	r5, r3, r0
#endif



    OS_ENTER_CRITICAL();
    ticks = OSTime;
10007028:	b0001000 	imm	4096
1000702c:	ea60d614 	lwi	r19, r0, -10732	// 1000d614 <OSTime>
    OS_EXIT_CRITICAL();
10007030:	b9f40f2c 	brlid	r15, 3884	// 10007f5c <OS_CPU_SR_Restore>
10007034:	80000000 	or	r0, r0, r0
    return (ticks);
}
10007038:	10730000 	addk	r3, r19, r0
1000703c:	e9e10000 	lwi	r15, r1, 0
10007040:	ea61001c 	lwi	r19, r1, 28
10007044:	b60f0008 	rtsd	r15, 8
10007048:	30210020 	addik	r1, r1, 32

1000704c <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0u
void  OSTimeSet (INT32U ticks)
{
1000704c:	3021ffe0 	addik	r1, r1, -32
10007050:	f9e10000 	swi	r15, r1, 0
10007054:	fa61001c 	swi	r19, r1, 28
    OS_CPU_SR  cpu_sr = 0u;
#endif



    OS_ENTER_CRITICAL();
10007058:	b9f40ed4 	brlid	r15, 3796	// 10007f2c <OS_CPU_SR_Save>
1000705c:	12650000 	addk	r19, r5, r0
    OSTime = ticks;
    OS_EXIT_CRITICAL();
10007060:	10a30000 	addk	r5, r3, r0
#endif



    OS_ENTER_CRITICAL();
    OSTime = ticks;
10007064:	b0001000 	imm	4096
10007068:	fa60d614 	swi	r19, r0, -10732	// 1000d614 <OSTime>
    OS_EXIT_CRITICAL();
1000706c:	b9f40ef0 	brlid	r15, 3824	// 10007f5c <OS_CPU_SR_Restore>
10007070:	80000000 	or	r0, r0, r0
}
10007074:	e9e10000 	lwi	r15, r1, 0
10007078:	ea61001c 	lwi	r19, r1, 28
1000707c:	b60f0008 	rtsd	r15, 8
10007080:	30210020 	addik	r1, r1, 32

10007084 <OSTmr_Link>:
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
10007084:	30600003 	addik	r3, r0, 3
10007088:	f0650025 	sbi	r3, r5, 37
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
1000708c:	a8c60001 	xori	r6, r6, 1
10007090:	b0001000 	imm	4096
10007094:	e860d610 	lwi	r3, r0, -10736	// 1000d610 <OSTmrTime>
10007098:	bc06000c 	beqi	r6, 12		// 100070a4
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
    } else {
        if (ptmr->OSTmrDly == 0u) {
1000709c:	e8850018 	lwi	r4, r5, 24
100070a0:	bc240008 	bnei	r4, 8		// 100070a8
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
100070a4:	e885001c 	lwi	r4, r5, 28
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
100070a8:	10632000 	addk	r3, r3, r4
100070ac:	f8650014 	swi	r3, r5, 20
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
100070b0:	e8c50014 	lwi	r6, r5, 20
    pspoke = &OSTmrWheelTbl[spoke];
100070b4:	b0001000 	imm	4096
100070b8:	3060cdd0 	addik	r3, r0, -12848	// 1000cdd0 <OSTmrWheelTbl>
100070bc:	a4c60007 	andi	r6, r6, 7
100070c0:	64c60403 	bslli	r6, r6, 3

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
100070c4:	b0001000 	imm	4096
100070c8:	e886cdd0 	lwi	r4, r6, -12848
        pspoke->OSTmrFirst   = ptmr;
100070cc:	b0001000 	imm	4096
100070d0:	f8a6cdd0 	swi	r5, r6, -12848
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
    pspoke = &OSTmrWheelTbl[spoke];
100070d4:	10661800 	addk	r3, r6, r3

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
100070d8:	be240010 	bneid	r4, 16		// 100070e8
100070dc:	f885000c 	swi	r4, r5, 12
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (OS_TMR *)0;
        pspoke->OSTmrEntries = 1u;
100070e0:	b8100014 	brid	20		// 100070f4
100070e4:	30800001 	addik	r4, r0, 1
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
        pspoke->OSTmrFirst   = ptmr;
        ptmr->OSTmrNext      = (void *)ptmr1;
        ptmr1->OSTmrPrev     = (void *)ptmr;
100070e8:	f8a40010 	swi	r5, r4, 16
        pspoke->OSTmrEntries++;
100070ec:	e4830004 	lhui	r4, r3, 4
100070f0:	30840001 	addik	r4, r4, 1
100070f4:	f4830004 	shi	r4, r3, 4
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
}
100070f8:	b60f0008 	rtsd	r15, 8
100070fc:	f8050010 	swi	r0, r5, 16

10007100 <OSTmr_Unlink>:
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
10007100:	e8850014 	lwi	r4, r5, 20
    pspoke = &OSTmrWheelTbl[spoke];
10007104:	b0001000 	imm	4096
10007108:	30c0cdd0 	addik	r6, r0, -12848	// 1000cdd0 <OSTmrWheelTbl>
1000710c:	a4840007 	andi	r4, r4, 7
10007110:	64840403 	bslli	r4, r4, 3

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
10007114:	b0001000 	imm	4096
10007118:	e864cdd0 	lwi	r3, r4, -12848
1000711c:	88e32800 	xor	r7, r3, r5
10007120:	be270020 	bneid	r7, 32		// 10007140
10007124:	10c43000 	addk	r6, r4, r6
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
10007128:	e863000c 	lwi	r3, r3, 12
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
1000712c:	b0001000 	imm	4096
10007130:	f864cdd0 	swi	r3, r4, -12848
        if (ptmr1 != (OS_TMR *)0) {
10007134:	bc030020 	beqi	r3, 32		// 10007154
            ptmr1->OSTmrPrev = (void *)0;
10007138:	b810001c 	brid	28		// 10007154
1000713c:	f8e30010 	swi	r7, r3, 16
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
10007140:	e8850010 	lwi	r4, r5, 16
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
10007144:	e865000c 	lwi	r3, r5, 12
        ptmr1->OSTmrNext = ptmr2;
        if (ptmr2 != (OS_TMR *)0) {
10007148:	be03000c 	beqid	r3, 12		// 10007154
1000714c:	f864000c 	swi	r3, r4, 12
            ptmr2->OSTmrPrev = (void *)ptmr1;
10007150:	f8830010 	swi	r4, r3, 16
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
10007154:	30600001 	addik	r3, r0, 1
10007158:	f0650025 	sbi	r3, r5, 37
    ptmr->OSTmrNext  = (void *)0;
    ptmr->OSTmrPrev  = (void *)0;
    pspoke->OSTmrEntries--;
1000715c:	e4660004 	lhui	r3, r6, 4
        if (ptmr2 != (OS_TMR *)0) {
            ptmr2->OSTmrPrev = (void *)ptmr1;
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
    ptmr->OSTmrNext  = (void *)0;
10007160:	f805000c 	swi	r0, r5, 12
    ptmr->OSTmrPrev  = (void *)0;
10007164:	f8050010 	swi	r0, r5, 16
    pspoke->OSTmrEntries--;
10007168:	3063ffff 	addik	r3, r3, -1
}
1000716c:	b60f0008 	rtsd	r15, 8
10007170:	f4660004 	shi	r3, r6, 4

10007174 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
static  void  OSTmr_Task (void *p_arg)
{
10007174:	3021ffd4 	addik	r1, r1, -44
10007178:	fac10024 	swi	r22, r1, 36
        OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
        OSSchedLock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
1000717c:	b0001000 	imm	4096
10007180:	32c0cdd0 	addik	r22, r0, -12848	// 1000cdd0 <OSTmrWheelTbl>
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
static  void  OSTmr_Task (void *p_arg)
{
10007184:	f9e10000 	swi	r15, r1, 0
10007188:	fa610020 	swi	r19, r1, 32
1000718c:	fae10028 	swi	r23, r1, 40
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
10007190:	b0001000 	imm	4096
10007194:	e8a0ce14 	lwi	r5, r0, -12780	// 1000ce14 <OSTmrSemSignal>
10007198:	10c00000 	addk	r6, r0, r0
1000719c:	b9f4ea44 	brlid	r15, -5564	// 10005be0 <OSSemPend>
100071a0:	30e1001c 	addik	r7, r1, 28
        OSSchedLock();
100071a4:	b9f4ae58 	brlid	r15, -20904	// 10001ffc <OSSchedLock>
100071a8:	80000000 	or	r0, r0, r0
        OSTmrTime++;                                             /* Increment the current time                        */
100071ac:	b0001000 	imm	4096
100071b0:	e860d610 	lwi	r3, r0, -10736	// 1000d610 <OSTmrTime>
100071b4:	30630001 	addik	r3, r3, 1
100071b8:	b0001000 	imm	4096
100071bc:	f860d610 	swi	r3, r0, -10736	// 1000d610 <OSTmrTime>
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
100071c0:	a4630007 	andi	r3, r3, 7
100071c4:	64630403 	bslli	r3, r3, 3
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
100071c8:	b8100068 	brid	104		// 10007230
100071cc:	ca63b000 	lw	r19, r3, r22
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
100071d0:	e8730014 	lwi	r3, r19, 20
100071d4:	b0001000 	imm	4096
100071d8:	e880d610 	lwi	r4, r0, -10736	// 1000d610 <OSTmrTime>
100071dc:	88641800 	xor	r3, r4, r3
100071e0:	be23004c 	bneid	r3, 76		// 1000722c
100071e4:	eaf3000c 	lwi	r23, r19, 12
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
100071e8:	b9f4ff18 	brlid	r15, -232	// 10007100 <OSTmr_Unlink>
100071ec:	10b30000 	addk	r5, r19, r0
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
100071f0:	e0730024 	lbui	r3, r19, 36
100071f4:	a8630002 	xori	r3, r3, 2
100071f8:	be230018 	bneid	r3, 24		// 10007210
100071fc:	10b30000 	addk	r5, r19, r0
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
10007200:	b9f4fe84 	brlid	r15, -380	// 10007084 <OSTmr_Link>
10007204:	30c00001 	addik	r6, r0, 1
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
10007208:	b8100014 	brid	20		// 1000721c
1000720c:	e8730004 	lwi	r3, r19, 4
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
10007210:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
10007214:	f0730025 	sbi	r3, r19, 37
                }
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
10007218:	e8730004 	lwi	r3, r19, 4
                if (pfnct != (OS_TMR_CALLBACK)0) {
1000721c:	be030010 	beqid	r3, 16		// 1000722c
10007220:	10b30000 	addk	r5, r19, r0
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
10007224:	99fc1800 	brald	r15, r3
10007228:	e8d30008 	lwi	r6, r19, 8
1000722c:	12770000 	addk	r19, r23, r0
        OSSchedLock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
10007230:	bc33ffa0 	bnei	r19, -96		// 100071d0
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
                }
            }
            ptmr = ptmr_next;
        }
        OSSchedUnlock();
10007234:	b9f4b630 	brlid	r15, -18896	// 10002864 <OSSchedUnlock>
10007238:	80000000 	or	r0, r0, r0
    }
1000723c:	b800ff54 	bri	-172		// 10007190

10007240 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
10007240:	3021ffc0 	addik	r1, r1, -64
10007244:	fac10020 	swi	r22, r1, 32
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
10007248:	b0001000 	imm	4096
1000724c:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
10007250:	fae10024 	swi	r23, r1, 36
10007254:	fb010028 	swi	r24, r1, 40
10007258:	fb21002c 	swi	r25, r1, 44
1000725c:	fb410030 	swi	r26, r1, 48
10007260:	fb610034 	swi	r27, r1, 52
10007264:	fb810038 	swi	r28, r1, 56
10007268:	fba1003c 	swi	r29, r1, 60
1000726c:	f9e10000 	swi	r15, r1, 0
10007270:	fa61001c 	swi	r19, r1, 28
10007274:	13a50000 	addk	r29, r5, r0
10007278:	13860000 	addk	r28, r6, r0
1000727c:	13670000 	addk	r27, r7, r0
10007280:	13480000 	addk	r26, r8, r0
10007284:	13290000 	addk	r25, r9, r0
10007288:	130a0000 	addk	r24, r10, r0
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
1000728c:	be160018 	beqid	r22, 24		// 100072a4
10007290:	eae1005c 	lwi	r23, r1, 92
        *perr  = OS_ERR_TMR_ISR;
10007294:	3060ff8b 	addik	r3, r0, -117
10007298:	f0770000 	sbi	r3, r23, 0
        return ((OS_TMR *)0);
1000729c:	b8100094 	brid	148		// 10007330
100072a0:	12600000 	addk	r19, r0, r0
    }
    OSSchedLock();
100072a4:	b9f4ad58 	brlid	r15, -21160	// 10001ffc <OSSchedLock>
100072a8:	80000000 	or	r0, r0, r0
static  OS_TMR  *OSTmr_Alloc (void)
{
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
100072ac:	b0001000 	imm	4096
100072b0:	ea60cdcc 	lwi	r19, r0, -12852	// 1000cdcc <OSTmrFreeList>
100072b4:	bc13006c 	beqi	r19, 108		// 10007320
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
100072b8:	e873000c 	lwi	r3, r19, 12
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
100072bc:	fad30010 	swi	r22, r19, 16
    if (OSTmrFreeList == (OS_TMR *)0) {
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
100072c0:	fad3000c 	swi	r22, r19, 12

    if (OSTmrFreeList == (OS_TMR *)0) {
        return ((OS_TMR *)0);
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
100072c4:	b0001000 	imm	4096
100072c8:	f860cdcc 	swi	r3, r0, -12852	// 1000cdcc <OSTmrFreeList>
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
100072cc:	b0001000 	imm	4096
100072d0:	e460ce20 	lhui	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
        OSSchedUnlock();
        *perr = OS_ERR_TMR_NON_AVAIL;
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
    ptmr->OSTmrDly         = dly;
100072d4:	fbb30018 	swi	r29, r19, 24
    ptmr->OSTmrPeriod      = period;
100072d8:	fb93001c 	swi	r28, r19, 28
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
100072dc:	30630001 	addik	r3, r3, 1
100072e0:	b0001000 	imm	4096
100072e4:	f460ce20 	shi	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
    OSTmrFree--;
100072e8:	b0001000 	imm	4096
100072ec:	e460d37c 	lhui	r3, r0, -11396	// 1000d37c <OSTmrFree>
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
    ptmr->OSTmrDly         = dly;
    ptmr->OSTmrPeriod      = period;
    ptmr->OSTmrOpt         = opt;
100072f0:	f3730024 	sbi	r27, r19, 36
    ptmr->OSTmrCallback    = callback;
100072f4:	fb530004 	swi	r26, r19, 4
    ptmr            = (OS_TMR *)OSTmrFreeList;
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
    ptmr->OSTmrNext = (OS_TCB *)0;
    ptmr->OSTmrPrev = (OS_TCB *)0;
    OSTmrUsed++;
    OSTmrFree--;
100072f8:	3063ffff 	addik	r3, r3, -1
100072fc:	b0001000 	imm	4096
10007300:	f460d37c 	shi	r3, r0, -11396	// 1000d37c <OSTmrFree>
    if (ptmr == (OS_TMR *)0) {
        OSSchedUnlock();
        *perr = OS_ERR_TMR_NON_AVAIL;
        return ((OS_TMR *)0);
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
10007304:	30600001 	addik	r3, r0, 1
10007308:	f0730025 	sbi	r3, r19, 37
    ptmr->OSTmrDly         = dly;
    ptmr->OSTmrPeriod      = period;
    ptmr->OSTmrOpt         = opt;
    ptmr->OSTmrCallback    = callback;
    ptmr->OSTmrCallbackArg = callback_arg;
1000730c:	fb330008 	swi	r25, r19, 8
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = pname;
#endif
    OSSchedUnlock();
10007310:	b9f4b554 	brlid	r15, -19116	// 10002864 <OSSchedUnlock>
10007314:	fb130020 	swi	r24, r19, 32
    *perr = OS_ERR_NONE;
    return (ptmr);
10007318:	b8100018 	brid	24		// 10007330
1000731c:	f2d70000 	sbi	r22, r23, 0
        return ((OS_TMR *)0);
    }
    OSSchedLock();
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
    if (ptmr == (OS_TMR *)0) {
        OSSchedUnlock();
10007320:	b9f4b544 	brlid	r15, -19132	// 10002864 <OSSchedUnlock>
10007324:	80000000 	or	r0, r0, r0
        *perr = OS_ERR_TMR_NON_AVAIL;
10007328:	3060ff86 	addik	r3, r0, -122
1000732c:	f0770000 	sbi	r3, r23, 0
    ptmr->OSTmrName        = pname;
#endif
    OSSchedUnlock();
    *perr = OS_ERR_NONE;
    return (ptmr);
}
10007330:	10730000 	addk	r3, r19, r0
10007334:	e9e10000 	lwi	r15, r1, 0
10007338:	ea61001c 	lwi	r19, r1, 28
1000733c:	eac10020 	lwi	r22, r1, 32
10007340:	eae10024 	lwi	r23, r1, 36
10007344:	eb010028 	lwi	r24, r1, 40
10007348:	eb21002c 	lwi	r25, r1, 44
1000734c:	eb410030 	lwi	r26, r1, 48
10007350:	eb610034 	lwi	r27, r1, 52
10007354:	eb810038 	lwi	r28, r1, 56
10007358:	eba1003c 	lwi	r29, r1, 60
1000735c:	b60f0008 	rtsd	r15, 8
10007360:	30210040 	addik	r1, r1, 64

10007364 <OSTmrDel>:
*/

#if OS_TMR_EN > 0u
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
10007364:	3021ffd0 	addik	r1, r1, -48
10007368:	fa61001c 	swi	r19, r1, 28
1000736c:	fb010028 	swi	r24, r1, 40
10007370:	f9e10000 	swi	r15, r1, 0
10007374:	fac10020 	swi	r22, r1, 32
10007378:	fae10024 	swi	r23, r1, 36
1000737c:	fb21002c 	swi	r25, r1, 44
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
10007380:	e0650000 	lbui	r3, r5, 0
*/

#if OS_TMR_EN > 0u
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
10007384:	12650000 	addk	r19, r5, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
10007388:	a8630064 	xori	r3, r3, 100
1000738c:	be030018 	beqid	r3, 24		// 100073a4
10007390:	13060000 	addk	r24, r6, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007394:	3060ff89 	addik	r3, r0, -119
10007398:	f0660000 	sbi	r3, r6, 0
        return (OS_FALSE);
1000739c:	b8100170 	brid	368		// 1000750c
100073a0:	12c00000 	addk	r22, r0, r0
    }
    if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
100073a4:	b0001000 	imm	4096
100073a8:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>
100073ac:	be160014 	beqid	r22, 20		// 100073c0
100073b0:	3080ff8b 	addik	r4, r0, -117
        *perr  = OS_ERR_TMR_ISR;
100073b4:	f0860000 	sbi	r4, r6, 0
        return (OS_FALSE);
100073b8:	b8100154 	brid	340		// 1000750c
100073bc:	12c30000 	addk	r22, r3, r0
    }
    OSSchedLock();
100073c0:	b9f4ac3c 	brlid	r15, -21444	// 10001ffc <OSSchedLock>
100073c4:	80000000 	or	r0, r0, r0
    switch (ptmr->OSTmrState) {
100073c8:	e2f30025 	lbui	r23, r19, 37
100073cc:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
100073d0:	14771803 	cmpu	r3, r23, r3
100073d4:	be430014 	bltid	r3, 20		// 100073e8
100073d8:	33200001 	addik	r25, r0, 1
100073dc:	16f9b803 	cmpu	r23, r25, r23
100073e0:	bcb70090 	bgei	r23, 144		// 10007470
100073e4:	b8000104 	bri	260		// 100074e8
100073e8:	aaf70003 	xori	r23, r23, 3
100073ec:	be370110 	bneid	r23, 272		// 100074fc
100073f0:	10b30000 	addk	r5, r19, r0
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
100073f4:	b9f4fd0c 	brlid	r15, -756	// 10007100 <OSTmr_Unlink>
100073f8:	32c00001 	addik	r22, r0, 1
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
100073fc:	b0001000 	imm	4096
10007400:	30608b10 	addik	r3, r0, -29936
*/

#if OS_TMR_EN > 0u
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
10007404:	f2f30025 	sbi	r23, r19, 37
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
10007408:	f2f30024 	sbi	r23, r19, 36
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
1000740c:	f8730020 	swi	r3, r19, 32
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
10007410:	b0001000 	imm	4096
10007414:	e860cdcc 	lwi	r3, r0, -12852	// 1000cdcc <OSTmrFreeList>
#if OS_TMR_EN > 0u
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
    ptmr->OSTmrPeriod      = 0u;
10007418:	faf3001c 	swi	r23, r19, 28
    ptmr->OSTmrMatch       = 0u;
1000741c:	faf30014 	swi	r23, r19, 20
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
10007420:	f873000c 	swi	r3, r19, 12
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
10007424:	b0001000 	imm	4096
10007428:	e460ce20 	lhui	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
1000742c:	faf30004 	swi	r23, r19, 4
    ptmr->OSTmrCallbackArg = (void *)0;
10007430:	faf30008 	swi	r23, r19, 8

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
10007434:	3063ffff 	addik	r3, r3, -1
10007438:	b0001000 	imm	4096
1000743c:	f460ce20 	shi	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
    OSTmrFree++;
10007440:	b0001000 	imm	4096
10007444:	e460d37c 	lhui	r3, r0, -11396	// 1000d37c <OSTmrFree>
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
10007448:	faf30010 	swi	r23, r19, 16
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;
1000744c:	b0001000 	imm	4096
10007450:	fa60cdcc 	swi	r19, r0, -12852	// 1000cdcc <OSTmrFreeList>

    OSTmrUsed--;                                       /* Update timer object statistics                              */
    OSTmrFree++;
10007454:	30630001 	addik	r3, r3, 1
10007458:	b0001000 	imm	4096
1000745c:	f460d37c 	shi	r3, r0, -11396	// 1000d37c <OSTmrFree>
    OSSchedLock();
    switch (ptmr->OSTmrState) {
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
             OSSchedUnlock();
10007460:	b9f4b404 	brlid	r15, -19452	// 10002864 <OSSchedUnlock>
10007464:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_NONE;
             return (OS_TRUE);
10007468:	b81000a4 	brid	164		// 1000750c
1000746c:	f2f80000 	sbi	r23, r24, 0
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
10007470:	b0001000 	imm	4096
10007474:	30608b10 	addik	r3, r0, -29936
*/

#if OS_TMR_EN > 0u
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
10007478:	f2d30025 	sbi	r22, r19, 37
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
1000747c:	f2d30024 	sbi	r22, r19, 36
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
10007480:	f8730020 	swi	r3, r19, 32
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
10007484:	b0001000 	imm	4096
10007488:	e860cdcc 	lwi	r3, r0, -12852	// 1000cdcc <OSTmrFreeList>
#if OS_TMR_EN > 0u
static  void  OSTmr_Free (OS_TMR *ptmr)
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
    ptmr->OSTmrPeriod      = 0u;
1000748c:	fad3001c 	swi	r22, r19, 28
    ptmr->OSTmrMatch       = 0u;
10007490:	fad30014 	swi	r22, r19, 20
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
10007494:	f873000c 	swi	r3, r19, 12
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
10007498:	b0001000 	imm	4096
1000749c:	e460ce20 	lhui	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
{
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
    ptmr->OSTmrPeriod      = 0u;
    ptmr->OSTmrMatch       = 0u;
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
100074a0:	fad30004 	swi	r22, r19, 4
    ptmr->OSTmrCallbackArg = (void *)0;
100074a4:	fad30008 	swi	r22, r19, 8

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;

    OSTmrUsed--;                                       /* Update timer object statistics                              */
100074a8:	3063ffff 	addik	r3, r3, -1
100074ac:	b0001000 	imm	4096
100074b0:	f460ce20 	shi	r3, r0, -12768	// 1000ce20 <OSTmrUsed>
    OSTmrFree++;
100074b4:	b0001000 	imm	4096
100074b8:	e460d37c 	lhui	r3, r0, -11396	// 1000d37c <OSTmrFree>
    ptmr->OSTmrCallbackArg = (void *)0;
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr->OSTmrName        = (INT8U *)"?";
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
100074bc:	fad30010 	swi	r22, r19, 16
    ptmr->OSTmrNext        = OSTmrFreeList;
    OSTmrFreeList          = ptmr;
100074c0:	b0001000 	imm	4096
100074c4:	fa60cdcc 	swi	r19, r0, -12852	// 1000cdcc <OSTmrFreeList>

    OSTmrUsed--;                                       /* Update timer object statistics                              */
    OSTmrFree++;
100074c8:	30630001 	addik	r3, r3, 1
100074cc:	b0001000 	imm	4096
100074d0:	f460d37c 	shi	r3, r0, -11396	// 1000d37c <OSTmrFree>
             return (OS_TRUE);

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
             OSSchedUnlock();
100074d4:	b9f4b390 	brlid	r15, -19568	// 10002864 <OSSchedUnlock>
100074d8:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_NONE;
100074dc:	f2d80000 	sbi	r22, r24, 0
             return (OS_TRUE);
100074e0:	b810002c 	brid	44		// 1000750c
100074e4:	12d90000 	addk	r22, r25, r0

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSSchedUnlock();
100074e8:	b9f4b37c 	brlid	r15, -19588	// 10002864 <OSSchedUnlock>
100074ec:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INACTIVE;
100074f0:	3060ff87 	addik	r3, r0, -121
             return (OS_FALSE);
100074f4:	b8100018 	brid	24		// 1000750c
100074f8:	f0780000 	sbi	r3, r24, 0

        default:
             OSSchedUnlock();
100074fc:	b9f4b368 	brlid	r15, -19608	// 10002864 <OSSchedUnlock>
10007500:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INVALID_STATE;
10007504:	3080ff8d 	addik	r4, r0, -115
10007508:	f0980000 	sbi	r4, r24, 0
             return (OS_FALSE);
    }
}
1000750c:	10760000 	addk	r3, r22, r0
10007510:	e9e10000 	lwi	r15, r1, 0
10007514:	ea61001c 	lwi	r19, r1, 28
10007518:	eac10020 	lwi	r22, r1, 32
1000751c:	eae10024 	lwi	r23, r1, 36
10007520:	eb010028 	lwi	r24, r1, 40
10007524:	eb21002c 	lwi	r25, r1, 44
10007528:	b60f0008 	rtsd	r15, 8
1000752c:	30210030 	addik	r1, r1, 48

10007530 <OSTmrNameGet>:

#if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                     INT8U   **pdest,
                     INT8U    *perr)
{
10007530:	3021ffcc 	addik	r1, r1, -52
10007534:	fa610020 	swi	r19, r1, 32
10007538:	fb01002c 	swi	r24, r1, 44
1000753c:	fb210030 	swi	r25, r1, 48
10007540:	f9e10000 	swi	r15, r1, 0
10007544:	fac10024 	swi	r22, r1, 36
10007548:	fae10028 	swi	r23, r1, 40
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
1000754c:	e0650000 	lbui	r3, r5, 0

#if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                     INT8U   **pdest,
                     INT8U    *perr)
{
10007550:	13050000 	addk	r24, r5, r0
10007554:	13260000 	addk	r25, r6, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
10007558:	a8630064 	xori	r3, r3, 100
1000755c:	be030018 	beqid	r3, 24		// 10007574
10007560:	12670000 	addk	r19, r7, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007564:	3060ff89 	addik	r3, r0, -119
10007568:	f0670000 	sbi	r3, r7, 0
        return (0u);
1000756c:	b8100088 	brid	136		// 100075f4
10007570:	10600000 	addk	r3, r0, r0
    }
    if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
10007574:	b0001000 	imm	4096
10007578:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>
1000757c:	be160010 	beqid	r22, 16		// 1000758c
10007580:	30800011 	addik	r4, r0, 17
        *perr = OS_ERR_NAME_GET_ISR;
        return (0u);
10007584:	b8100070 	brid	112		// 100075f4
10007588:	f0870000 	sbi	r4, r7, 0
    }
    OSSchedLock();
1000758c:	b9f4aa70 	brlid	r15, -21904	// 10001ffc <OSSchedLock>
10007590:	80000000 	or	r0, r0, r0
    switch (ptmr->OSTmrState) {
10007594:	e2f80025 	lbui	r23, r24, 37
10007598:	bc170030 	beqi	r23, 48		// 100075c8
1000759c:	30600003 	addik	r3, r0, 3
100075a0:	16f71803 	cmpu	r23, r23, r3
100075a4:	bc57003c 	blti	r23, 60		// 100075e0
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             *pdest = ptmr->OSTmrName;
100075a8:	e8b80020 	lwi	r5, r24, 32
             len    = OS_StrLen(*pdest);
100075ac:	b9f4b678 	brlid	r15, -18824	// 10002c24 <OS_StrLen>
100075b0:	f8b90000 	swi	r5, r25, 0
             OSSchedUnlock();
100075b4:	b9f4b2b0 	brlid	r15, -19792	// 10002864 <OSSchedUnlock>
100075b8:	f861001c 	swi	r3, r1, 28
             *perr = OS_ERR_NONE;
100075bc:	f2d30000 	sbi	r22, r19, 0
             return (len);
100075c0:	b8100034 	brid	52		// 100075f4
100075c4:	e861001c 	lwi	r3, r1, 28

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSSchedUnlock();
100075c8:	b9f4b29c 	brlid	r15, -19812	// 10002864 <OSSchedUnlock>
100075cc:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INACTIVE;
100075d0:	3060ff87 	addik	r3, r0, -121
100075d4:	f0730000 	sbi	r3, r19, 0
             return (0u);
100075d8:	b810001c 	brid	28		// 100075f4
100075dc:	10770000 	addk	r3, r23, r0

        default:
             OSSchedUnlock();
100075e0:	b9f4b284 	brlid	r15, -19836	// 10002864 <OSSchedUnlock>
100075e4:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INVALID_STATE;
             return (0u);
100075e8:	10760000 	addk	r3, r22, r0
             *perr = OS_ERR_TMR_INACTIVE;
             return (0u);

        default:
             OSSchedUnlock();
             *perr = OS_ERR_TMR_INVALID_STATE;
100075ec:	3080ff8d 	addik	r4, r0, -115
100075f0:	f0930000 	sbi	r4, r19, 0
             return (0u);
    }
}
100075f4:	e9e10000 	lwi	r15, r1, 0
100075f8:	ea610020 	lwi	r19, r1, 32
100075fc:	eac10024 	lwi	r22, r1, 36
10007600:	eae10028 	lwi	r23, r1, 40
10007604:	eb01002c 	lwi	r24, r1, 44
10007608:	eb210030 	lwi	r25, r1, 48
1000760c:	b60f0008 	rtsd	r15, 8
10007610:	30210034 	addik	r1, r1, 52

10007614 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0u
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
10007614:	3021ffd0 	addik	r1, r1, -48
10007618:	fa61001c 	swi	r19, r1, 28
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
1000761c:	e2650000 	lbui	r19, r5, 0
*/

#if OS_TMR_EN > 0u
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
10007620:	fac10020 	swi	r22, r1, 32
10007624:	fae10024 	swi	r23, r1, 36
10007628:	f9e10000 	swi	r15, r1, 0
1000762c:	fb010028 	swi	r24, r1, 40
10007630:	fb21002c 	swi	r25, r1, 44
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
10007634:	aa730064 	xori	r19, r19, 100
*/

#if OS_TMR_EN > 0u
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
10007638:	12e50000 	addk	r23, r5, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
1000763c:	be130018 	beqid	r19, 24		// 10007654
10007640:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007644:	3060ff89 	addik	r3, r0, -119
10007648:	f0660000 	sbi	r3, r6, 0
        return (0u);
1000764c:	b81000cc 	brid	204		// 10007718
10007650:	12600000 	addk	r19, r0, r0
    }
    if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
10007654:	b0001000 	imm	4096
10007658:	e300d608 	lbui	r24, r0, -10744	// 1000d608 <OSIntNesting>
1000765c:	be180010 	beqid	r24, 16		// 1000766c
10007660:	3060ff8b 	addik	r3, r0, -117
        *perr = OS_ERR_TMR_ISR;
        return (0u);
10007664:	b81000b4 	brid	180		// 10007718
10007668:	f0660000 	sbi	r3, r6, 0
    }
    OSSchedLock();
1000766c:	b9f4a990 	brlid	r15, -22128	// 10001ffc <OSSchedLock>
10007670:	80000000 	or	r0, r0, r0
    switch (ptmr->OSTmrState) {
10007674:	e0770025 	lbui	r3, r23, 37
10007678:	ab230001 	xori	r25, r3, 1
1000767c:	be190034 	beqid	r25, 52		// 100076b0
10007680:	30800001 	addik	r4, r0, 1
10007684:	14841803 	cmpu	r4, r4, r3
10007688:	bc440070 	blti	r4, 112		// 100076f8
1000768c:	aa630002 	xori	r19, r3, 2
10007690:	be130058 	beqid	r19, 88		// 100076e8
10007694:	ab230003 	xori	r25, r3, 3
10007698:	bc390070 	bnei	r25, 112		// 10007708
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
1000769c:	e8770014 	lwi	r3, r23, 20
100076a0:	b0001000 	imm	4096
100076a4:	ea60d610 	lwi	r19, r0, -10736	// 1000d610 <OSTmrTime>
100076a8:	b8100030 	brid	48		// 100076d8
100076ac:	16731800 	rsubk	r19, r19, r3
             OSSchedUnlock();
             *perr  = OS_ERR_NONE;
             return (remain);

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
100076b0:	e0770024 	lbui	r3, r23, 36
100076b4:	a8630002 	xori	r3, r3, 2
100076b8:	be230020 	bneid	r3, 32		// 100076d8
100076bc:	ea770018 	lwi	r19, r23, 24
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0u) {
100076c0:	bc330008 	bnei	r19, 8		// 100076c8
                          remain = ptmr->OSTmrPeriod;
100076c4:	ea77001c 	lwi	r19, r23, 28
                      } else {
                          remain = ptmr->OSTmrDly;
                      }
                      OSSchedUnlock();
100076c8:	b9f4b19c 	brlid	r15, -20068	// 10002864 <OSSchedUnlock>
100076cc:	80000000 	or	r0, r0, r0
                      *perr  = OS_ERR_NONE;
                      break;
100076d0:	b8100048 	brid	72		// 10007718
100076d4:	f0160000 	sbi	r0, r22, 0

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
                      OSSchedUnlock();
100076d8:	b9f4b18c 	brlid	r15, -20084	// 10002864 <OSSchedUnlock>
100076dc:	80000000 	or	r0, r0, r0
                      *perr  = OS_ERR_NONE;
                      break;
100076e0:	b8100038 	brid	56		// 10007718
100076e4:	f3360000 	sbi	r25, r22, 0
             }
             return (remain);

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSSchedUnlock();
100076e8:	b9f4b17c 	brlid	r15, -20100	// 10002864 <OSSchedUnlock>
100076ec:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_NONE;
             return (0u);
100076f0:	b8100028 	brid	40		// 10007718
100076f4:	f2760000 	sbi	r19, r22, 0

        case OS_TMR_STATE_UNUSED:
             OSSchedUnlock();
100076f8:	b9f4b16c 	brlid	r15, -20116	// 10002864 <OSSchedUnlock>
100076fc:	12780000 	addk	r19, r24, r0
             *perr = OS_ERR_TMR_INACTIVE;
10007700:	b8100014 	brid	20		// 10007714
10007704:	3060ff87 	addik	r3, r0, -121
             return (0u);

        default:
             OSSchedUnlock();
10007708:	b9f4b15c 	brlid	r15, -20132	// 10002864 <OSSchedUnlock>
1000770c:	12780000 	addk	r19, r24, r0
             *perr = OS_ERR_TMR_INVALID_STATE;
10007710:	3060ff8d 	addik	r3, r0, -115
10007714:	f0760000 	sbi	r3, r22, 0
             return (0u);
    }
}
10007718:	10730000 	addk	r3, r19, r0
1000771c:	e9e10000 	lwi	r15, r1, 0
10007720:	ea61001c 	lwi	r19, r1, 28
10007724:	eac10020 	lwi	r22, r1, 32
10007728:	eae10024 	lwi	r23, r1, 36
1000772c:	eb010028 	lwi	r24, r1, 40
10007730:	eb21002c 	lwi	r25, r1, 44
10007734:	b60f0008 	rtsd	r15, 8
10007738:	30210030 	addik	r1, r1, 48

1000773c <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0u
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
1000773c:	3021ffd4 	addik	r1, r1, -44
10007740:	fa61001c 	swi	r19, r1, 28
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
10007744:	e2650000 	lbui	r19, r5, 0
*/

#if OS_TMR_EN > 0u
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
10007748:	fac10020 	swi	r22, r1, 32
1000774c:	fb010028 	swi	r24, r1, 40
10007750:	f9e10000 	swi	r15, r1, 0
10007754:	fae10024 	swi	r23, r1, 36
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
10007758:	aa730064 	xori	r19, r19, 100
*/

#if OS_TMR_EN > 0u
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
1000775c:	13050000 	addk	r24, r5, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (0u);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
10007760:	be130018 	beqid	r19, 24		// 10007778
10007764:	12c60000 	addk	r22, r6, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007768:	3060ff89 	addik	r3, r0, -119
1000776c:	f0660000 	sbi	r3, r6, 0
        return (0u);
10007770:	b8100050 	brid	80		// 100077c0
10007774:	12600000 	addk	r19, r0, r0
    }
    if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
10007778:	b0001000 	imm	4096
1000777c:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>
10007780:	be170010 	beqid	r23, 16		// 10007790
10007784:	3060ff8b 	addik	r3, r0, -117
        *perr = OS_ERR_TMR_ISR;
        return (0u);
10007788:	b8100038 	brid	56		// 100077c0
1000778c:	f0660000 	sbi	r3, r6, 0
    }
    OSSchedLock();
10007790:	b9f4a86c 	brlid	r15, -22420	// 10001ffc <OSSchedLock>
10007794:	80000000 	or	r0, r0, r0
    state = ptmr->OSTmrState;
10007798:	e2780025 	lbui	r19, r24, 37
    switch (state) {
1000779c:	30600003 	addik	r3, r0, 3
100077a0:	14731803 	cmpu	r3, r19, r3
100077a4:	be430010 	bltid	r3, 16		// 100077b4
100077a8:	3060ff8d 	addik	r3, r0, -115
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
             break;
100077ac:	b810000c 	brid	12		// 100077b8
100077b0:	f2f60000 	sbi	r23, r22, 0
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
100077b4:	f0760000 	sbi	r3, r22, 0
             break;
    }
    OSSchedUnlock();
100077b8:	b9f4b0ac 	brlid	r15, -20308	// 10002864 <OSSchedUnlock>
100077bc:	80000000 	or	r0, r0, r0
    return (state);
}
100077c0:	10730000 	addk	r3, r19, r0
100077c4:	e9e10000 	lwi	r15, r1, 0
100077c8:	ea61001c 	lwi	r19, r1, 28
100077cc:	eac10020 	lwi	r22, r1, 32
100077d0:	eae10024 	lwi	r23, r1, 36
100077d4:	eb010028 	lwi	r24, r1, 40
100077d8:	b60f0008 	rtsd	r15, 8
100077dc:	3021002c 	addik	r1, r1, 44

100077e0 <OSTmrStart>:
*/

#if OS_TMR_EN > 0u
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
100077e0:	3021ffd0 	addik	r1, r1, -48
100077e4:	fa61001c 	swi	r19, r1, 28
100077e8:	fae10024 	swi	r23, r1, 36
100077ec:	f9e10000 	swi	r15, r1, 0
100077f0:	fac10020 	swi	r22, r1, 32
100077f4:	fb010028 	swi	r24, r1, 40
100077f8:	fb21002c 	swi	r25, r1, 44
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
100077fc:	e0650000 	lbui	r3, r5, 0
*/

#if OS_TMR_EN > 0u
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
10007800:	12e50000 	addk	r23, r5, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
10007804:	a8630064 	xori	r3, r3, 100
10007808:	be030018 	beqid	r3, 24		// 10007820
1000780c:	12660000 	addk	r19, r6, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007810:	3060ff89 	addik	r3, r0, -119
10007814:	f0660000 	sbi	r3, r6, 0
        return (OS_FALSE);
10007818:	b81000c0 	brid	192		// 100078d8
1000781c:	10600000 	addk	r3, r0, r0
    }
    if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
10007820:	b0001000 	imm	4096
10007824:	e2c0d608 	lbui	r22, r0, -10744	// 1000d608 <OSIntNesting>
10007828:	be160010 	beqid	r22, 16		// 10007838
1000782c:	3080ff8b 	addik	r4, r0, -117
        *perr  = OS_ERR_TMR_ISR;
        return (OS_FALSE);
10007830:	b81000a8 	brid	168		// 100078d8
10007834:	f0860000 	sbi	r4, r6, 0
    }
    OSSchedLock();
10007838:	b9f4a7c4 	brlid	r15, -22588	// 10001ffc <OSSchedLock>
1000783c:	80000000 	or	r0, r0, r0
    switch (ptmr->OSTmrState) {
10007840:	e3170025 	lbui	r24, r23, 37
10007844:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
10007848:	14781803 	cmpu	r3, r24, r3
1000784c:	be430018 	bltid	r3, 24		// 10007864
10007850:	33200001 	addik	r25, r0, 1
10007854:	1719c003 	cmpu	r24, r25, r24
10007858:	beb8003c 	bgeid	r24, 60		// 10007894
1000785c:	10b70000 	addk	r5, r23, r0
10007860:	b8000050 	bri	80		// 100078b0
10007864:	ab180003 	xori	r24, r24, 3
10007868:	bc38005c 	bnei	r24, 92		// 100078c4
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
1000786c:	b9f4f894 	brlid	r15, -1900	// 10007100 <OSTmr_Unlink>
10007870:	10b70000 	addk	r5, r23, r0
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
10007874:	10b70000 	addk	r5, r23, r0
10007878:	b9f4f80c 	brlid	r15, -2036	// 10007084 <OSTmr_Link>
1000787c:	10d80000 	addk	r6, r24, r0
             OSSchedUnlock();
10007880:	b9f4afe4 	brlid	r15, -20508	// 10002864 <OSSchedUnlock>
10007884:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_NONE;
             return (OS_TRUE);
10007888:	30600001 	addik	r3, r0, 1
1000788c:	b810004c 	brid	76		// 100078d8
10007890:	f3130000 	sbi	r24, r19, 0

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
10007894:	b9f4f7f0 	brlid	r15, -2064	// 10007084 <OSTmr_Link>
10007898:	10d60000 	addk	r6, r22, r0
             OSSchedUnlock();
1000789c:	b9f4afc8 	brlid	r15, -20536	// 10002864 <OSSchedUnlock>
100078a0:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_NONE;
             return (OS_TRUE);
100078a4:	10790000 	addk	r3, r25, r0
100078a8:	b8100030 	brid	48		// 100078d8
100078ac:	f2d30000 	sbi	r22, r19, 0

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSSchedUnlock();
100078b0:	b9f4afb4 	brlid	r15, -20556	// 10002864 <OSSchedUnlock>
100078b4:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INACTIVE;
100078b8:	3060ff87 	addik	r3, r0, -121
100078bc:	b8100018 	brid	24		// 100078d4
100078c0:	f0730000 	sbi	r3, r19, 0
             return (OS_FALSE);

        default:
             OSSchedUnlock();
100078c4:	b9f4afa0 	brlid	r15, -20576	// 10002864 <OSSchedUnlock>
100078c8:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INVALID_STATE;
100078cc:	3080ff8d 	addik	r4, r0, -115
100078d0:	f0930000 	sbi	r4, r19, 0
             return (OS_FALSE);
100078d4:	10760000 	addk	r3, r22, r0
    }
}
100078d8:	e9e10000 	lwi	r15, r1, 0
100078dc:	ea61001c 	lwi	r19, r1, 28
100078e0:	eac10020 	lwi	r22, r1, 32
100078e4:	eae10024 	lwi	r23, r1, 36
100078e8:	eb010028 	lwi	r24, r1, 40
100078ec:	eb21002c 	lwi	r25, r1, 44
100078f0:	b60f0008 	rtsd	r15, 8
100078f4:	30210030 	addik	r1, r1, 48

100078f8 <OSTmrStop>:
#if OS_TMR_EN > 0u
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
100078f8:	3021ffcc 	addik	r1, r1, -52
100078fc:	fa61001c 	swi	r19, r1, 28
10007900:	fac10020 	swi	r22, r1, 32
10007904:	fb010028 	swi	r24, r1, 40
10007908:	fb410030 	swi	r26, r1, 48
1000790c:	f9e10000 	swi	r15, r1, 0
10007910:	fae10024 	swi	r23, r1, 36
10007914:	fb21002c 	swi	r25, r1, 44
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
10007918:	e0650000 	lbui	r3, r5, 0
#if OS_TMR_EN > 0u
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
1000791c:	12c50000 	addk	r22, r5, r0
10007920:	13060000 	addk	r24, r6, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
10007924:	a8630064 	xori	r3, r3, 100
#if OS_TMR_EN > 0u
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
10007928:	13470000 	addk	r26, r7, r0
    if (ptmr == (OS_TMR *)0) {
        *perr = OS_ERR_TMR_INVALID;
        return (OS_FALSE);
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
1000792c:	be030018 	beqid	r3, 24		// 10007944
10007930:	12680000 	addk	r19, r8, r0
        *perr = OS_ERR_TMR_INVALID_TYPE;
10007934:	3060ff89 	addik	r3, r0, -119
10007938:	f0680000 	sbi	r3, r8, 0
        return (OS_FALSE);
1000793c:	b8100110 	brid	272		// 10007a4c
10007940:	10600000 	addk	r3, r0, r0
    }
    if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
10007944:	b0001000 	imm	4096
10007948:	e2e0d608 	lbui	r23, r0, -10744	// 1000d608 <OSIntNesting>
1000794c:	be170010 	beqid	r23, 16		// 1000795c
10007950:	3080ff8b 	addik	r4, r0, -117
        *perr  = OS_ERR_TMR_ISR;
        return (OS_FALSE);
10007954:	b81000f8 	brid	248		// 10007a4c
10007958:	f0880000 	sbi	r4, r8, 0
    }
    OSSchedLock();
1000795c:	b9f4a6a0 	brlid	r15, -22880	// 10001ffc <OSSchedLock>
10007960:	80000000 	or	r0, r0, r0
    switch (ptmr->OSTmrState) {
10007964:	e0960025 	lbui	r4, r22, 37
10007968:	30600002 	addik	r3, r0, 2	// 2 <CPU_IE_BIT>
1000796c:	14641803 	cmpu	r3, r4, r3
10007970:	be430018 	bltid	r3, 24		// 10007988
10007974:	ab240003 	xori	r25, r4, 3
10007978:	32c00001 	addik	r22, r0, 1
1000797c:	14962003 	cmpu	r4, r22, r4
10007980:	bca4008c 	bgei	r4, 140		// 10007a0c
10007984:	b80000a0 	bri	160		// 10007a24
10007988:	bc3900b0 	bnei	r25, 176		// 10007a38
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
1000798c:	b9f4f774 	brlid	r15, -2188	// 10007100 <OSTmr_Unlink>
10007990:	10b60000 	addk	r5, r22, r0
             *perr = OS_ERR_NONE;
             switch (opt) {
10007994:	a8780003 	xori	r3, r24, 3
10007998:	be03001c 	beqid	r3, 28		// 100079b4
1000799c:	f3330000 	sbi	r25, r19, 0
100079a0:	a8780004 	xori	r3, r24, 4
100079a4:	bc03002c 	beqi	r3, 44		// 100079d0
100079a8:	bc180054 	beqi	r24, 84		// 100079fc

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
100079ac:	b810004c 	brid	76		// 100079f8
100079b0:	3060ff84 	addik	r3, r0, -124
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
             *perr = OS_ERR_NONE;
             switch (opt) {
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
100079b4:	e8760004 	lwi	r3, r22, 4
                      if (pfnct != (OS_TMR_CALLBACK)0) {
100079b8:	be030010 	beqid	r3, 16		// 100079c8
100079bc:	10b60000 	addk	r5, r22, r0
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
100079c0:	b8100020 	brid	32		// 100079e0
100079c4:	e8d60008 	lwi	r6, r22, 8
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
100079c8:	b8100030 	brid	48		// 100079f8
100079cc:	3060ff8f 	addik	r3, r0, -113
                      }
                      break;

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
100079d0:	e8760004 	lwi	r3, r22, 4
                      if (pfnct != (OS_TMR_CALLBACK)0) {
100079d4:	be030018 	beqid	r3, 24		// 100079ec
100079d8:	10b60000 	addk	r5, r22, r0
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
100079dc:	10da0000 	addk	r6, r26, r0
100079e0:	99fc1800 	brald	r15, r3
100079e4:	80000000 	or	r0, r0, r0
100079e8:	b8000014 	bri	20		// 100079fc
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
100079ec:	3080ff8f 	addik	r4, r0, -113
100079f0:	b810000c 	brid	12		// 100079fc
100079f4:	f0930000 	sbi	r4, r19, 0

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
100079f8:	f0730000 	sbi	r3, r19, 0
                     break;
             }
             OSSchedUnlock();
100079fc:	b9f4ae68 	brlid	r15, -20888	// 10002864 <OSSchedUnlock>
10007a00:	80000000 	or	r0, r0, r0
             return (OS_TRUE);
10007a04:	b8100048 	brid	72		// 10007a4c
10007a08:	30600001 	addik	r3, r0, 1

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSSchedUnlock();
10007a0c:	b9f4ae58 	brlid	r15, -20904	// 10002864 <OSSchedUnlock>
10007a10:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_STOPPED;
10007a14:	3080ff8e 	addik	r4, r0, -114
10007a18:	f0930000 	sbi	r4, r19, 0
             return (OS_TRUE);
10007a1c:	b8100030 	brid	48		// 10007a4c
10007a20:	10760000 	addk	r3, r22, r0

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSSchedUnlock();
10007a24:	b9f4ae40 	brlid	r15, -20928	// 10002864 <OSSchedUnlock>
10007a28:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INACTIVE;
10007a2c:	3060ff87 	addik	r3, r0, -121
10007a30:	b8100018 	brid	24		// 10007a48
10007a34:	f0730000 	sbi	r3, r19, 0
             return (OS_FALSE);

        default:
             OSSchedUnlock();
10007a38:	b9f4ae2c 	brlid	r15, -20948	// 10002864 <OSSchedUnlock>
10007a3c:	80000000 	or	r0, r0, r0
             *perr = OS_ERR_TMR_INVALID_STATE;
10007a40:	3080ff8d 	addik	r4, r0, -115
10007a44:	f0930000 	sbi	r4, r19, 0
             return (OS_FALSE);
10007a48:	10770000 	addk	r3, r23, r0
    }
}
10007a4c:	e9e10000 	lwi	r15, r1, 0
10007a50:	ea61001c 	lwi	r19, r1, 28
10007a54:	eac10020 	lwi	r22, r1, 32
10007a58:	eae10024 	lwi	r23, r1, 36
10007a5c:	eb010028 	lwi	r24, r1, 40
10007a60:	eb21002c 	lwi	r25, r1, 44
10007a64:	eb410030 	lwi	r26, r1, 48
10007a68:	b60f0008 	rtsd	r15, 8
10007a6c:	30210034 	addik	r1, r1, 52

10007a70 <OSTmrSignal>:
INT8U  OSTmrSignal (void)
{
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
10007a70:	b0001000 	imm	4096
10007a74:	e8a0ce14 	lwi	r5, r0, -12780	// 1000ce14 <OSTmrSemSignal>
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
INT8U  OSTmrSignal (void)
{
10007a78:	3021ffe4 	addik	r1, r1, -28
10007a7c:	f9e10000 	swi	r15, r1, 0
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
10007a80:	b9f4e3a0 	brlid	r15, -7264	// 10005e20 <OSSemPost>
10007a84:	80000000 	or	r0, r0, r0
    return (err);
}
10007a88:	e9e10000 	lwi	r15, r1, 0
10007a8c:	b60f0008 	rtsd	r15, 8
10007a90:	3021001c 	addik	r1, r1, 28

10007a94 <OSTmr_Init>:
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
10007a94:	b0001000 	imm	4096
10007a98:	30a0ce74 	addik	r5, r0, -12684	// 1000ce74 <OSTmrTbl>
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
void  OSTmr_Init (void)
{
10007a9c:	3021ffd0 	addik	r1, r1, -48
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
10007aa0:	30c00280 	addik	r6, r0, 640
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
void  OSTmr_Init (void)
{
10007aa4:	f9e10000 	swi	r15, r1, 0
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
10007aa8:	b9f4aa54 	brlid	r15, -21932	// 100024fc <OS_MemClr>
10007aac:	fa61002c 	swi	r19, r1, 44
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
10007ab0:	b0001000 	imm	4096
10007ab4:	30a0cdd0 	addik	r5, r0, -12848	// 1000cdd0 <OSTmrWheelTbl>
10007ab8:	b9f4aa44 	brlid	r15, -21948	// 100024fc <OS_MemClr>
10007abc:	30c00040 	addik	r6, r0, 64	// 40 <STK_OFFSET_R18>
* Returns    : none
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
void  OSTmr_Init (void)
10007ac0:	b0001000 	imm	4096
10007ac4:	30c0ce9c 	addik	r6, r0, -12644
    for (i = 0u; i < (OS_TMR_CFG_MAX - 1u); i++) {                      /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
#if OS_TMR_CFG_NAME_EN > 0u
        ptmr1->OSTmrName    = (INT8U *)"?";
10007ac8:	b0001000 	imm	4096
10007acc:	30a08b10 	addik	r5, r0, -29936
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
10007ad0:	10600000 	addk	r3, r0, r0

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0u; i < (OS_TMR_CFG_MAX - 1u); i++) {                      /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
10007ad4:	30e00064 	addik	r7, r0, 100	// 64 <STK_OFFSET_R27>
10007ad8:	b0001000 	imm	4096
10007adc:	f0e3ce74 	sbi	r7, r3, -12684
* Returns    : none
************************************************************************************************************************
*/

#if OS_TMR_EN > 0u
void  OSTmr_Init (void)
10007ae0:	10e61800 	addk	r7, r6, r3

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0u; i < (OS_TMR_CFG_MAX - 1u); i++) {                      /* Init. list of free TMRs                    */
        ptmr1->OSTmrType    = OS_TMR_TYPE;
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
10007ae4:	b0001000 	imm	4096
10007ae8:	f003ce99 	sbi	r0, r3, -12647
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
10007aec:	b0001000 	imm	4096
10007af0:	f8e3ce80 	swi	r7, r3, -12672
#if OS_TMR_CFG_NAME_EN > 0u
        ptmr1->OSTmrName    = (INT8U *)"?";
10007af4:	b0001000 	imm	4096
10007af8:	f8a3ce94 	swi	r5, r3, -12652
10007afc:	30630028 	addik	r3, r3, 40
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0u; i < (OS_TMR_CFG_MAX - 1u); i++) {                      /* Init. list of free TMRs                    */
10007b00:	aa630258 	xori	r19, r3, 600
        ptmr1->OSTmrType    = OS_TMR_TYPE;
10007b04:	b0001000 	imm	4096
10007b08:	3080ce74 	addik	r4, r0, -12684	// 1000ce74 <OSTmrTbl>
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0u; i < (OS_TMR_CFG_MAX - 1u); i++) {                      /* Init. list of free TMRs                    */
10007b0c:	be33ffc8 	bneid	r19, -56		// 10007ad4
10007b10:	30e00010 	addik	r7, r0, 16	// 10 <STK_OFFSET_R05>
        ptmr1->OSTmrName    = (INT8U *)"?";
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
10007b14:	30600064 	addik	r3, r0, 100	// 64 <STK_OFFSET_R27>
10007b18:	f0640258 	sbi	r3, r4, 600
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr1->OSTmrName    = (INT8U *)"?";
10007b1c:	b0001000 	imm	4096
10007b20:	30608b10 	addik	r3, r0, -29936
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
10007b24:	f264027d 	sbi	r19, r4, 637
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
10007b28:	fa640264 	swi	r19, r4, 612
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr1->OSTmrName    = (INT8U *)"?";
10007b2c:	f8640278 	swi	r3, r4, 632
#endif
    OSTmrTime           = 0u;
    OSTmrUsed           = 0u;
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
10007b30:	b0001000 	imm	4096
10007b34:	f880cdcc 	swi	r4, r0, -12852	// 1000cdcc <OSTmrFreeList>
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr1->OSTmrName    = (INT8U *)"?";
#endif
    OSTmrTime           = 0u;
    OSTmrUsed           = 0u;
    OSTmrFree           = OS_TMR_CFG_MAX;
10007b38:	b0001000 	imm	4096
10007b3c:	f4e0d37c 	shi	r7, r0, -11396	// 1000d37c <OSTmrFree>
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
#if OS_TMR_CFG_NAME_EN > 0u
    ptmr1->OSTmrName    = (INT8U *)"?";
#endif
    OSTmrTime           = 0u;
10007b40:	b0001000 	imm	4096
10007b44:	fa60d610 	swi	r19, r0, -10736	// 1000d610 <OSTmrTime>
    OSTmrUsed           = 0u;
10007b48:	b0001000 	imm	4096
10007b4c:	f660ce20 	shi	r19, r0, -12768	// 1000ce20 <OSTmrUsed>
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1u);
10007b50:	b9f4de9c 	brlid	r15, -8548	// 100059ec <OSSemCreate>
10007b54:	30a00001 	addik	r5, r0, 1
10007b58:	b0001000 	imm	4096
10007b5c:	f860d618 	swi	r3, r0, -10728	// 1000d618 <OSTmrSem>
    OSTmrSemSignal      = OSSemCreate(0u);
10007b60:	b9f4de8c 	brlid	r15, -8564	// 100059ec <OSSemCreate>
10007b64:	10b30000 	addk	r5, r19, r0

#if OS_EVENT_NAME_EN > 0u
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
10007b68:	b0001000 	imm	4096
10007b6c:	e8a0d618 	lwi	r5, r0, -10728	// 1000d618 <OSTmrSem>
10007b70:	b0001000 	imm	4096
10007b74:	30c08b14 	addik	r6, r0, -29932
    OSTmrTime           = 0u;
    OSTmrUsed           = 0u;
    OSTmrFree           = OS_TMR_CFG_MAX;
    OSTmrFreeList       = &OSTmrTbl[0];
    OSTmrSem            = OSSemCreate(1u);
    OSTmrSemSignal      = OSSemCreate(0u);
10007b78:	b0001000 	imm	4096
10007b7c:	f860ce14 	swi	r3, r0, -12780	// 1000ce14 <OSTmrSemSignal>

#if OS_EVENT_NAME_EN > 0u
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
10007b80:	b9f4a2f4 	brlid	r15, -23820	// 10001e74 <OSEventNameSet>
10007b84:	30e10029 	addik	r7, r1, 41
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
10007b88:	b0001000 	imm	4096
10007b8c:	e8a0ce14 	lwi	r5, r0, -12780	// 1000ce14 <OSTmrSemSignal>
10007b90:	b0001000 	imm	4096
10007b94:	30c08b28 	addik	r6, r0, -29912
10007b98:	b9f4a2dc 	brlid	r15, -23844	// 10001e74 <OSEventNameSet>
10007b9c:	30e10029 	addik	r7, r1, 41
#endif


#if OS_TASK_CREATE_EXT_EN > 0u
    #if OS_STK_GROWTH == 1u
    (void)OSTaskCreateExt(OSTmr_Task,
10007ba0:	10d30000 	addk	r6, r19, r0
10007ba4:	b0000000 	imm	0
10007ba8:	3120fffd 	addik	r9, r0, -3
10007bac:	b0001000 	imm	4096
10007bb0:	3140d404 	addik	r10, r0, -11260	// 1000d404 <OSTmrTaskStk>
10007bb4:	b0001000 	imm	4096
10007bb8:	30a07174 	addik	r5, r0, 29044	// 10007174 <OSTmr_Task>
10007bbc:	b0001000 	imm	4096
10007bc0:	30e0d600 	addik	r7, r0, -10752
10007bc4:	30600080 	addik	r3, r0, 128
10007bc8:	f861001c 	swi	r3, r1, 28
10007bcc:	31000009 	addik	r8, r0, 9
10007bd0:	30600003 	addik	r3, r0, 3
10007bd4:	fa610020 	swi	r19, r1, 32
10007bd8:	b9f4f0c4 	brlid	r15, -3900	// 10006c9c <OSTaskCreateExt>
10007bdc:	f8610024 	swi	r3, r1, 36
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_EN > 0u
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
10007be0:	b0001000 	imm	4096
10007be4:	30c08b3c 	addik	r6, r0, -29892
10007be8:	30a00009 	addik	r5, r0, 9
10007bec:	b9f4eb20 	brlid	r15, -5344	// 1000670c <OSTaskNameSet>
10007bf0:	30e10028 	addik	r7, r1, 40
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
#endif

    OSTmr_InitTask();
}
10007bf4:	e9e10000 	lwi	r15, r1, 0
10007bf8:	ea61002c 	lwi	r19, r1, 44
10007bfc:	b60f0008 	rtsd	r15, 8
10007c00:	30210030 	addik	r1, r1, 48

10007c04 <OSInitHookBegin>:
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookBegin (void)
{
}
10007c04:	b60f0008 	rtsd	r15, 8
10007c08:	80000000 	or	r0, r0, r0

10007c0c <OSInitHookEnd>:
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookEnd (void)
{
}
10007c0c:	b60f0008 	rtsd	r15, 8
10007c10:	80000000 	or	r0, r0, r0

10007c14 <OSTaskCreateHook>:
void  OSTaskCreateHook (OS_TCB *ptcb)
{
#if OS_VIEW_MODULE >0
    OSView_TaskCreateHook(ptcb);
#endif
}
10007c14:	b60f0008 	rtsd	r15, 8
10007c18:	80000000 	or	r0, r0, r0

10007c1c <OSTaskDelHook>:
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskDelHook (OS_TCB *ptcb)
{
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
10007c1c:	b60f0008 	rtsd	r15, 8
10007c20:	80000000 	or	r0, r0, r0

10007c24 <OSTaskReturnHook>:
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskReturnHook (OS_TCB *ptcb)
{
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
10007c24:	b60f0008 	rtsd	r15, 8
10007c28:	80000000 	or	r0, r0, r0

10007c2c <OSTaskIdleHook>:
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
void  OSTaskIdleHook (void)
{
}
10007c2c:	b60f0008 	rtsd	r15, 8
10007c30:	80000000 	or	r0, r0, r0

10007c34 <OSTaskStatHook>:
*/

#if OS_CPU_HOOKS_EN > 0 
void  OSTaskStatHook (void)
{
}
10007c34:	b60f0008 	rtsd	r15, 8
10007c38:	80000000 	or	r0, r0, r0

10007c3c <OSTaskStkInit>:
{
    INT32U  *pstk;
	 INT32U  msr_val;


    __asm__ __volatile__ ("mfs\t%0,rmsr\n" : "=r"(msr_val));     
10007c3c:	94608001 	mfs	r3, rmsr

    opt     = opt;                    /* 'opt' is not used, prevent warning                            */
    pstk    = (INT32U *)ptos;         /* Load stack pointer                                            */
    pstk--;                           /* Make sure we point to free entry ...                          */
    pstk--;                           /* ... compiler uses top-of-stack so free an extra one.          */
    *pstk-- = (INT32U)0x31313131;     /* R31                                                           */
10007c40:	b0003131 	imm	12593
10007c44:	30803131 	addik	r4, r0, 12593
	 INT32U  msr_val;


    __asm__ __volatile__ ("mfs\t%0,rmsr\n" : "=r"(msr_val));     

    msr_val &= 0x000000A0;	           /* Ensure that the status of the caches is not changed           */
10007c48:	a46300a0 	andi	r3, r3, 160
    *pstk-- = (INT32U)0x06060606;     /* R06                                                           */
    *pstk-- = (INT32U)p_arg;          /* R05                                                           */
    *pstk-- = (INT32U)0x04040404;     /* R04                                                           */
    *pstk-- = (INT32U)0x03030303;     /* R03                                                           */
    *pstk-- = (INT32U)&_SDA2_BASE_;   /* R02                                                           */
    *pstk   = msr_val | 0x00000002;   /* MSR with interrupts enabled                                   */
10007c4c:	a0630002 	ori	r3, r3, 2

    opt     = opt;                    /* 'opt' is not used, prevent warning                            */
    pstk    = (INT32U *)ptos;         /* Load stack pointer                                            */
    pstk--;                           /* Make sure we point to free entry ...                          */
    pstk--;                           /* ... compiler uses top-of-stack so free an extra one.          */
    *pstk-- = (INT32U)0x31313131;     /* R31                                                           */
10007c50:	f887fff8 	swi	r4, r7, -8
    *pstk-- = (INT32U)0x30303030;     /* R30                                                           */
10007c54:	b0003030 	imm	12336
10007c58:	30803030 	addik	r4, r0, 12336
    *pstk-- = (INT32U)0x06060606;     /* R06                                                           */
    *pstk-- = (INT32U)p_arg;          /* R05                                                           */
    *pstk-- = (INT32U)0x04040404;     /* R04                                                           */
    *pstk-- = (INT32U)0x03030303;     /* R03                                                           */
    *pstk-- = (INT32U)&_SDA2_BASE_;   /* R02                                                           */
    *pstk   = msr_val | 0x00000002;   /* MSR with interrupts enabled                                   */
10007c5c:	f867ff84 	swi	r3, r7, -124
    *pstk-- = (INT32U)0x20202020;     /* R20                                                           */
    *pstk-- = (INT32U)0x19191919;     /* R19                                                           */
    *pstk-- = (INT32U)0x18181818;     /* R18                                                           */
    *pstk-- = (INT32U)0x17171717;     /* R17                                                           */
    *pstk-- = (INT32U)task - 8;       /* R15 = task return address (assuming function call)            */
    *pstk-- = (INT32U)task;           /* R14 = task (Interrupt return address)                         */
10007c60:	f8a7ffb8 	swi	r5, r7, -72
    opt     = opt;                    /* 'opt' is not used, prevent warning                            */
    pstk    = (INT32U *)ptos;         /* Load stack pointer                                            */
    pstk--;                           /* Make sure we point to free entry ...                          */
    pstk--;                           /* ... compiler uses top-of-stack so free an extra one.          */
    *pstk-- = (INT32U)0x31313131;     /* R31                                                           */
    *pstk-- = (INT32U)0x30303030;     /* R30                                                           */
10007c64:	f887fff4 	swi	r4, r7, -12
    *pstk-- = (INT32U)0x29292929;     /* R29                                                           */
10007c68:	b0002929 	imm	10537
10007c6c:	30802929 	addik	r4, r0, 10537
    *pstk-- = (INT32U)0x10101010;     /* R10                                                           */
    *pstk-- = (INT32U)0x09090909;     /* R09                                                           */
    *pstk-- = (INT32U)0x08080808;     /* R08                                                           */
    *pstk-- = (INT32U)0x07070707;     /* R07                                                           */
    *pstk-- = (INT32U)0x06060606;     /* R06                                                           */
    *pstk-- = (INT32U)p_arg;          /* R05                                                           */
10007c70:	f8c7ff94 	swi	r6, r7, -108
    *pstk-- = (INT32U)0x03030303;     /* R03                                                           */
    *pstk-- = (INT32U)&_SDA2_BASE_;   /* R02                                                           */
    *pstk   = msr_val | 0x00000002;   /* MSR with interrupts enabled                                   */

    return ((OS_STK *)pstk);          /* Return new top of stack                                       */
}
10007c74:	3067ff84 	addik	r3, r7, -124
    pstk    = (INT32U *)ptos;         /* Load stack pointer                                            */
    pstk--;                           /* Make sure we point to free entry ...                          */
    pstk--;                           /* ... compiler uses top-of-stack so free an extra one.          */
    *pstk-- = (INT32U)0x31313131;     /* R31                                                           */
    *pstk-- = (INT32U)0x30303030;     /* R30                                                           */
    *pstk-- = (INT32U)0x29292929;     /* R29                                                           */
10007c78:	f887fff0 	swi	r4, r7, -16
    *pstk-- = (INT32U)0x28282828;     /* R28                                                           */
10007c7c:	b0002828 	imm	10280
10007c80:	30802828 	addik	r4, r0, 10280
10007c84:	f887ffec 	swi	r4, r7, -20
    *pstk-- = (INT32U)0x27272727;     /* R27                                                           */
10007c88:	b0002727 	imm	10023
10007c8c:	30802727 	addik	r4, r0, 10023
10007c90:	f887ffe8 	swi	r4, r7, -24
    *pstk-- = (INT32U)0x26262626;     /* R26                                                           */
10007c94:	b0002626 	imm	9766
10007c98:	30802626 	addik	r4, r0, 9766
10007c9c:	f887ffe4 	swi	r4, r7, -28
    *pstk-- = (INT32U)0x25252525;     /* R25                                                           */
10007ca0:	b0002525 	imm	9509
10007ca4:	30802525 	addik	r4, r0, 9509
10007ca8:	f887ffe0 	swi	r4, r7, -32
    *pstk-- = (INT32U)0x24242424;     /* R24                                                           */
10007cac:	b0002424 	imm	9252
10007cb0:	30802424 	addik	r4, r0, 9252
10007cb4:	f887ffdc 	swi	r4, r7, -36
    *pstk-- = (INT32U)0x23232323;     /* R23                                                           */
10007cb8:	b0002323 	imm	8995
10007cbc:	30802323 	addik	r4, r0, 8995
10007cc0:	f887ffd8 	swi	r4, r7, -40
    *pstk-- = (INT32U)0x22222222;     /* R22                                                           */
10007cc4:	b0002222 	imm	8738
10007cc8:	30802222 	addik	r4, r0, 8738
10007ccc:	f887ffd4 	swi	r4, r7, -44
    *pstk-- = (INT32U)0x21212121;     /* R21                                                           */
10007cd0:	b0002121 	imm	8481
10007cd4:	30802121 	addik	r4, r0, 8481
10007cd8:	f887ffd0 	swi	r4, r7, -48
    *pstk-- = (INT32U)0x20202020;     /* R20                                                           */
10007cdc:	b0002020 	imm	8224
10007ce0:	30802020 	addik	r4, r0, 8224
10007ce4:	f887ffcc 	swi	r4, r7, -52
    *pstk-- = (INT32U)0x19191919;     /* R19                                                           */
10007ce8:	b0001919 	imm	6425
10007cec:	30801919 	addik	r4, r0, 6425
10007cf0:	f887ffc8 	swi	r4, r7, -56
    *pstk-- = (INT32U)0x18181818;     /* R18                                                           */
10007cf4:	b0001818 	imm	6168
10007cf8:	30801818 	addik	r4, r0, 6168
10007cfc:	f887ffc4 	swi	r4, r7, -60
    *pstk-- = (INT32U)0x17171717;     /* R17                                                           */
10007d00:	b0001717 	imm	5911
10007d04:	30801717 	addik	r4, r0, 5911
10007d08:	f887ffc0 	swi	r4, r7, -64
    *pstk-- = (INT32U)task - 8;       /* R15 = task return address (assuming function call)            */
10007d0c:	3085fff8 	addik	r4, r5, -8
10007d10:	f887ffbc 	swi	r4, r7, -68
    *pstk-- = (INT32U)task;           /* R14 = task (Interrupt return address)                         */
    *pstk-- = (INT32U)&_SDA_BASE_;    /* R13                                                           */
10007d14:	b0001000 	imm	4096
10007d18:	30808d38 	addik	r4, r0, -29384	// 10008d38 <_SDA_BASE_>
10007d1c:	f887ffb4 	swi	r4, r7, -76
    *pstk-- = (INT32U)0x12121212;     /* R12                                                           */
10007d20:	b0001212 	imm	4626
10007d24:	30801212 	addik	r4, r0, 4626
10007d28:	f887ffb0 	swi	r4, r7, -80
    *pstk-- = (INT32U)0x11111111;     /* R11                                                           */
10007d2c:	b0001111 	imm	4369
10007d30:	30801111 	addik	r4, r0, 4369
10007d34:	f887ffac 	swi	r4, r7, -84
    *pstk-- = (INT32U)0x10101010;     /* R10                                                           */
10007d38:	b0001010 	imm	4112
10007d3c:	30801010 	addik	r4, r0, 4112
10007d40:	f887ffa8 	swi	r4, r7, -88
    *pstk-- = (INT32U)0x09090909;     /* R09                                                           */
10007d44:	b0000909 	imm	2313
10007d48:	30800909 	addik	r4, r0, 2313
10007d4c:	f887ffa4 	swi	r4, r7, -92
    *pstk-- = (INT32U)0x08080808;     /* R08                                                           */
10007d50:	b0000808 	imm	2056
10007d54:	30800808 	addik	r4, r0, 2056
10007d58:	f887ffa0 	swi	r4, r7, -96
    *pstk-- = (INT32U)0x07070707;     /* R07                                                           */
10007d5c:	b0000707 	imm	1799
10007d60:	30800707 	addik	r4, r0, 1799
10007d64:	f887ff9c 	swi	r4, r7, -100
    *pstk-- = (INT32U)0x06060606;     /* R06                                                           */
10007d68:	b0000606 	imm	1542
10007d6c:	30800606 	addik	r4, r0, 1542
10007d70:	f887ff98 	swi	r4, r7, -104
    *pstk-- = (INT32U)p_arg;          /* R05                                                           */
    *pstk-- = (INT32U)0x04040404;     /* R04                                                           */
10007d74:	b0000404 	imm	1028
10007d78:	30800404 	addik	r4, r0, 1028
10007d7c:	f887ff90 	swi	r4, r7, -112
    *pstk-- = (INT32U)0x03030303;     /* R03                                                           */
10007d80:	b0000303 	imm	771
10007d84:	30800303 	addik	r4, r0, 771
10007d88:	f887ff8c 	swi	r4, r7, -116
    *pstk-- = (INT32U)&_SDA2_BASE_;   /* R02                                                           */
10007d8c:	b0001000 	imm	4096
10007d90:	30808c20 	addik	r4, r0, -29664	// 10008c20 <_SDA2_BASE_>
    *pstk   = msr_val | 0x00000002;   /* MSR with interrupts enabled                                   */

    return ((OS_STK *)pstk);          /* Return new top of stack                                       */
}
10007d94:	b60f0008 	rtsd	r15, 8
10007d98:	f887ff88 	swi	r4, r7, -120

10007d9c <OSTaskSwHook>:
void  OSTaskSwHook (void)
{
#if OS_VIEW_MODULE > 0
    OSView_TaskSwHook();
#endif	 
}
10007d9c:	b60f0008 	rtsd	r15, 8
10007da0:	80000000 	or	r0, r0, r0

10007da4 <OSTCBInitHook>:
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSTCBInitHook (OS_TCB *ptcb)
{
    ptcb = ptcb;                                           /* Prevent Compiler warning                 */
}
10007da4:	b60f0008 	rtsd	r15, 8
10007da8:	80000000 	or	r0, r0, r0

10007dac <OSTimeTickHook>:
void  OSTimeTickHook (void)
{
#if OS_VIEW_MODULE > 0
    OSView_TickHook();
#endif
}
10007dac:	b60f0008 	rtsd	r15, 8
10007db0:	80000000 	or	r0, r0, r0

10007db4 <OSDebugInit>:
    ptemp = (void *)&OSVersionNbr;

    ptemp = (void *)&OSDataSize;

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
10007db4:	b60f0008 	rtsd	r15, 8
10007db8:	80000000 	or	r0, r0, r0

10007dbc <BSP_TmrInit>:
 * \brief Timer 1 initialization
 * \param[in] threshold Threshold value
 */
static __inline__ void timer_1_init(const sb_uint32_t threshold)
{
  WRITE_REG32(TIMER_1_CONTROL_REG,TIMER_RESET_BIT);
10007dbc:	b0005000 	imm	20480
10007dc0:	30600000 	addik	r3, r0, 0
  WRITE_REG32(TIMER_1_THRESHOLD_REG,threshold);
10007dc4:	b0000003 	imm	3
10007dc8:	30a0d090 	addik	r5, r0, -12144
 * \brief Timer 1 initialization
 * \param[in] threshold Threshold value
 */
static __inline__ void timer_1_init(const sb_uint32_t threshold)
{
  WRITE_REG32(TIMER_1_CONTROL_REG,TIMER_RESET_BIT);
10007dcc:	30800002 	addik	r4, r0, 2	// 2 <CPU_IE_BIT>
10007dd0:	f8830000 	swi	r4, r3, 0
  WRITE_REG32(TIMER_1_THRESHOLD_REG,threshold);
10007dd4:	b0005000 	imm	20480
10007dd8:	f8a00004 	swi	r5, r0, 4
 * \fn void timer_1_reset(void)
 * \brief Force reset timer 1
 */
static __inline__ void timer_1_reset(void)
{
  WRITE_REG32(TIMER_1_CONTROL_REG,TIMER_RESET_BIT);
10007ddc:	f8830000 	swi	r4, r3, 0
 * \fn void timer_1_enable(void)
 * \brief Enable timer 1
 */
static __inline__ void timer_1_enable(void)
{
  WRITE_REG32(TIMER_1_CONTROL_REG,TIMER_ENABLE_BIT);
10007de0:	30800001 	addik	r4, r0, 1
10007de4:	f8830000 	swi	r4, r3, 0
  /* reset the timer */
  timer_1_reset();
  
  /* start the timer */
  timer_1_enable();
}
10007de8:	b60f0008 	rtsd	r15, 8
10007dec:	80000000 	or	r0, r0, r0

10007df0 <BSP_InitIntCtrl>:
/**
 * \fn void BSP_InitIntCtrl
 * \brief Interrupt controller initialization for uCOSII operating system
 */
void BSP_InitIntCtrl(void)
{
10007df0:	3021ffe4 	addik	r1, r1, -28
10007df4:	f9e10000 	swi	r15, r1, 0

  /* init interrupt controller */
  intc_init();
10007df8:	b9f484e4 	brlid	r15, -31516	// 100002dc <intc_init>
10007dfc:	80000000 	or	r0, r0, r0

  /* attack timer handler */
  intc_attach_handler(INTC_ID_2,(sb_interrupt_handler)(&OSTimeTick),(void *)0);     
10007e00:	b0001000 	imm	4096
10007e04:	30c02120 	addik	r6, r0, 8480	// 10002120 <OSTimeTick>
10007e08:	30a00002 	addik	r5, r0, 2	// 2 <CPU_IE_BIT>
10007e0c:	b9f48550 	brlid	r15, -31408	// 1000035c <intc_attach_handler>
10007e10:	10e00000 	addk	r7, r0, r0
 * \brief Update the mask register
 * \param[in] mask_it The new mask setting
 */
static __inline__ void intc_set_mask(const sb_uint32_t mask_it)
{
  WRITE_REG32(INTC_MASK_REG,mask_it);
10007e14:	306000fb 	addik	r3, r0, 251
10007e18:	b0004000 	imm	16384
10007e1c:	f8600008 	swi	r3, r0, 8
 * \brief Update the arm register
 * \param[in] arm_it The new arm setting
 */
static __inline__ void intc_set_arm(const sb_uint32_t arm_it)
{
  WRITE_REG32(INTC_ARM_REG,arm_it);
10007e20:	30600004 	addik	r3, r0, 4	// 4 <STK_OFFSET_R02>
10007e24:	b0004000 	imm	16384
10007e28:	f860000c 	swi	r3, r0, 12
  
  /* enable interrupts from the first timer */
  intc_set_mask(0xFB);
  intc_set_arm(0x4);
}
10007e2c:	e9e10000 	lwi	r15, r1, 0
10007e30:	b60f0008 	rtsd	r15, 8
10007e34:	3021001c 	addik	r1, r1, 28

10007e38 <BSP_InitIO>:
/**
 * \fn void BSP_InitIO
 * \brief IO initialization for uCOSII operating system
 */
void BSP_InitIO(void)    
{
10007e38:	3021ffe4 	addik	r1, r1, -28
10007e3c:	f9e10000 	swi	r15, r1, 0

  /* interrupt controller initialization */
  BSP_InitIntCtrl();                       
10007e40:	b9f4ffb0 	brlid	r15, -80	// 10007df0 <BSP_InitIntCtrl>
10007e44:	80000000 	or	r0, r0, r0
  
  /* timer initialization */     
  BSP_TmrInit();                              
10007e48:	b9f4ff74 	brlid	r15, -140	// 10007dbc <BSP_TmrInit>
10007e4c:	80000000 	or	r0, r0, r0
}
10007e50:	e9e10000 	lwi	r15, r1, 0
10007e54:	b60f0008 	rtsd	r15, 8
10007e58:	3021001c 	addik	r1, r1, 28

10007e5c <FirstTask>:
* Returns    : None
*********************************************************************************************************
*/

static  void  FirstTask (void *p_arg)
{
10007e5c:	3021ffd4 	addik	r1, r1, -44
10007e60:	f9e10000 	swi	r15, r1, 0
    p_arg = p_arg;    

    BSP_InitIO();
10007e64:	b9f4ffd4 	brlid	r15, -44	// 10007e38 <BSP_InitIO>
10007e68:	80000000 	or	r0, r0, r0
#if OS_TASK_STAT_EN > 0
    OSStatInit();
10007e6c:	b9f4a248 	brlid	r15, -23992	// 100020b4 <OSStatInit>
10007e70:	80000000 	or	r0, r0, r0

static  void  AppTaskCreate (void)
{
	CPU_INT08U err;
	
	OSTaskCreateExt(SecondTask,
10007e74:	3100000b 	addik	r8, r0, 11
10007e78:	b0001000 	imm	4096
10007e7c:	30a07eec 	addik	r5, r0, 32492	// 10007eec <SecondTask>
10007e80:	b0001000 	imm	4096
10007e84:	30e0cd54 	addik	r7, r0, -12972
10007e88:	11280000 	addk	r9, r8, r0
10007e8c:	b0001000 	imm	4096
10007e90:	3140ad58 	addik	r10, r0, -21160	// 1000ad58 <SecondTaskStk>
10007e94:	30600800 	addik	r3, r0, 2048
10007e98:	f861001c 	swi	r3, r1, 28
10007e9c:	10c00000 	addk	r6, r0, r0
10007ea0:	30600003 	addik	r3, r0, 3
10007ea4:	f8010020 	swi	r0, r1, 32
10007ea8:	b9f4edf4 	brlid	r15, -4620	// 10006c9c <OSTaskCreateExt>
10007eac:	f8610024 	swi	r3, r1, 36
                     &SecondTaskStk[0],
                     TASK_STK_SIZE,
                     (void *)0,
                     OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
      
      OSTaskNameSet(TASK1_PRIO, (CPU_INT08U *)"SecondTask", &err);
10007eb0:	b0001000 	imm	4096
10007eb4:	30c08bc0 	addik	r6, r0, -29760
10007eb8:	30a0000a 	addik	r5, r0, 10
10007ebc:	b9f4e850 	brlid	r15, -6064	// 1000670c <OSTaskNameSet>
10007ec0:	30e10028 	addik	r7, r1, 40
                                                 /* created in a separate function to reduce clutter   */
                                                 /* in main                                            */

    while (1)
    {
        e_printf("First task says Hello World\n");
10007ec4:	b0001000 	imm	4096
10007ec8:	30a08bcc 	addik	r5, r0, -29748
10007ecc:	b9f48a18 	brlid	r15, -30184	// 100008e4 <e_printf>
10007ed0:	80000000 	or	r0, r0, r0
        OSTimeDlyHMSM(0,0,1,0);
10007ed4:	10a00000 	addk	r5, r0, r0
10007ed8:	10c50000 	addk	r6, r5, r0
10007edc:	11050000 	addk	r8, r5, r0
10007ee0:	b9f4efcc 	brlid	r15, -4148	// 10006eac <OSTimeDlyHMSM>
10007ee4:	30e00001 	addik	r7, r0, 1
10007ee8:	b800ffdc 	bri	-36		// 10007ec4

10007eec <SecondTask>:
* Returns    : None
*********************************************************************************************************
*/

static  void  SecondTask (void *p_arg)
{
10007eec:	3021ffe4 	addik	r1, r1, -28
10007ef0:	f9e10000 	swi	r15, r1, 0
    p_arg = p_arg;    

    while (1)
    {
        e_printf("Second task says Hello World\n");
10007ef4:	b0001000 	imm	4096
10007ef8:	30a08bec 	addik	r5, r0, -29716
10007efc:	b9f489e8 	brlid	r15, -30232	// 100008e4 <e_printf>
10007f00:	80000000 	or	r0, r0, r0
        OSTimeDlyHMSM(0,0,3,0);
10007f04:	10a00000 	addk	r5, r0, r0
10007f08:	10c50000 	addk	r6, r5, r0
10007f0c:	11050000 	addk	r8, r5, r0
10007f10:	b9f4ef9c 	brlid	r15, -4196	// 10006eac <OSTimeDlyHMSM>
10007f14:	30e00003 	addik	r7, r0, 3
10007f18:	b800ffdc 	bri	-36		// 10007ef4

10007f1c <CPU_SR_Save>:
*               allows the processor to recognize this instruction.
*********************************************************************************************************
*/

CPU_SR_Save:
    RTSD    r15, 8
10007f1c:	b60f0008 	rtsd	r15, 8
    MSRCLR  r3,  CPU_IE_BIT                  /* Save MSR in r3 and disable interrupts                  */
10007f20:	94710002 	msrclr	r3, 2

10007f24 <CPU_SR_Restore>:
* Note(s)     : None
*********************************************************************************************************
*/

CPU_SR_Restore:
    RTSD    r15, 8
10007f24:	b60f0008 	rtsd	r15, 8
    MTS     rMSR, r5                         /* Move the saved status from r5 into rMSR                */
10007f28:	9405c001 	mts	rmsr, r5

10007f2c <OS_CPU_SR_Save>:
* Note(s)     : None
*********************************************************************************************************
*/

OS_CPU_SR_Save:
    ADDIK   r1, r1, -4            /* Save R4 since it's used as a scratchpad register   */
10007f2c:	3021fffc 	addik	r1, r1, -4
    SW      r4, r1, r0 
10007f30:	d8810000 	sw	r4, r1, r0

    MFS     r3, RMSR               /* Read the MSR.  r3 is used as the return value      */
10007f34:	94608001 	mfs	r3, rmsr
    ANDNI   r4, r3, CPU_IE_BIT     /* Mask off the IE bit                                */
10007f38:	ac830002 	andni	r4, r3, 2
    MTS     RMSR, r4               /* Store the MSR                                      */
10007f3c:	9404c001 	mts	rmsr, r4

    LW      r4, r1, r0             /* Restore R4                                         */
10007f40:	c8810000 	lw	r4, r1, r0
    ADDIK   r1, r1, 4 
10007f44:	30210004 	addik	r1, r1, 4

    AND     r0, r0, r0             /* NO-OP - pipeline flush                             */
10007f48:	84000000 	and	r0, r0, r0
    AND     r0, r0, r0             /* NO-OP - pipeline flush                             */
10007f4c:	84000000 	and	r0, r0, r0
    AND     r0, r0, r0             /* NO-OP - pipeline flush                             */
10007f50:	84000000 	and	r0, r0, r0

    RTSD    r15, 8                 /* Return to caller with R3 containing original RMSR  */
10007f54:	b60f0008 	rtsd	r15, 8
    AND     r0, r0, r0             /* NO-OP                                              */
10007f58:	84000000 	and	r0, r0, r0

10007f5c <OS_CPU_SR_Restore>:
* Note(s)     : None
*********************************************************************************************************
*/

OS_CPU_SR_Restore:
    RTSD    r15, 8
10007f5c:	b60f0008 	rtsd	r15, 8
    MTS     rMSR, r5               /* Move the saved status from r5 into rMSR            */
10007f60:	9405c001 	mts	rmsr, r5

10007f64 <OSStartHighRdy>:
10007f64:	b9f4fe38 	brlid	r15, -456	// 10007d9c <OSTaskSwHook>
*********************************************************************************************************
*/

OSStartHighRdy:

    BRLID   r15, OSTaskSwHook           /* Call OSTaskSwHook()                                         */
10007f68:	84000000 	and	r0, r0, r0
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10007f6c:	80630000 	or	r3, r3, r0

    OR      r3,  r3, r0                 /* OSRunning = TRUE                                            */
10007f70:	30600001 	addik	r3, r0, 1
    ADDIK   r3,  r0, 1
10007f74:	b0001000 	imm	4096
10007f78:	f060ce18 	sbi	r3, r0, -12776	// 1000ce18 <OSRunning>
    SBI     r3,  r0, OSRunning
10007f7c:	b0001000 	imm	4096
10007f80:	e860d3f0 	lwi	r3, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
                                             
    LWI     r3,  r0, OSTCBHighRdy       /* SP       = OSTCBHighRdy->OSTCBStkPtr                        */
10007f84:	c8201800 	lw	r1, r0, r3
    LW      r1,  r0, r3                      
10007f88:	ebe10074 	lwi	r31, r1, 116

    LWI     r31, r1, STK_OFFSET_R31     /* *************** RESTORE TASK'S CONTEXT ***************      */
10007f8c:	ebc10070 	lwi	r30, r1, 112
    LWI     r30, r1, STK_OFFSET_R30
10007f90:	eba1006c 	lwi	r29, r1, 108
    LWI     r29, r1, STK_OFFSET_R29
10007f94:	eb810068 	lwi	r28, r1, 104
    LWI     r28, r1, STK_OFFSET_R28
10007f98:	eb610064 	lwi	r27, r1, 100
    LWI     r27, r1, STK_OFFSET_R27
10007f9c:	eb410060 	lwi	r26, r1, 96
    LWI     r26, r1, STK_OFFSET_R26
10007fa0:	eb21005c 	lwi	r25, r1, 92
    LWI     r25, r1, STK_OFFSET_R25
10007fa4:	eb010058 	lwi	r24, r1, 88
    LWI     r24, r1, STK_OFFSET_R24
10007fa8:	eae10054 	lwi	r23, r1, 84
    LWI     r23, r1, STK_OFFSET_R23
10007fac:	eac10050 	lwi	r22, r1, 80
    LWI     r22, r1, STK_OFFSET_R22
10007fb0:	eaa1004c 	lwi	r21, r1, 76
    LWI     r21, r1, STK_OFFSET_R21
10007fb4:	ea810048 	lwi	r20, r1, 72
    LWI     r20, r1, STK_OFFSET_R20
10007fb8:	ea610044 	lwi	r19, r1, 68
    LWI     r19, r1, STK_OFFSET_R19
10007fbc:	ea410040 	lwi	r18, r1, 64
    LWI     r18, r1, STK_OFFSET_R18
10007fc0:	ea21003c 	lwi	r17, r1, 60
    LWI     r17, r1, STK_OFFSET_R17                   
10007fc4:	e9e10038 	lwi	r15, r1, 56
    LWI     r15, r1, STK_OFFSET_R15
10007fc8:	e9c10034 	lwi	r14, r1, 52
    LWI     r14, r1, STK_OFFSET_R14
10007fcc:	e9a10030 	lwi	r13, r1, 48
    LWI     r13, r1, STK_OFFSET_R13
10007fd0:	e981002c 	lwi	r12, r1, 44
    LWI     r12, r1, STK_OFFSET_R12
10007fd4:	e9610028 	lwi	r11, r1, 40
    LWI     r11, r1, STK_OFFSET_R11
10007fd8:	e9410024 	lwi	r10, r1, 36
    LWI     r10, r1, STK_OFFSET_R10
10007fdc:	e9210020 	lwi	r9, r1, 32
    LWI     r9,  r1, STK_OFFSET_R09
10007fe0:	e901001c 	lwi	r8, r1, 28
    LWI     r8,  r1, STK_OFFSET_R08
10007fe4:	e8e10018 	lwi	r7, r1, 24
    LWI     r7,  r1, STK_OFFSET_R07
10007fe8:	e8c10014 	lwi	r6, r1, 20
    LWI     r6,  r1, STK_OFFSET_R06   
10007fec:	e8a10010 	lwi	r5, r1, 16
    LWI     r5,  r1, STK_OFFSET_R05
10007ff0:	e881000c 	lwi	r4, r1, 12
    LWI     r4,  r1, STK_OFFSET_R04   
10007ff4:	e8410004 	lwi	r2, r1, 4
    LWI     r2,  r1, STK_OFFSET_R02
10007ff8:	e8610000 	lwi	r3, r1, 0

    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10007ffc:	ac630002 	andni	r3, r3, 2
	  ANDNI   r3,  r3, CPU_IE_BIT         /* Clear the IE bit (It will be set by the return from INT.)   */
10008000:	9403c001 	mts	rmsr, r3
    MTS     RMSR,r3
10008004:	e8610008 	lwi	r3, r1, 8
    LWI     r3,  r1, STK_OFFSET_R03     /* Restore R3 (was used a scratchpad register for RMSR)        */
10008008:	30210078 	addik	r1, r1, 120

    ADDIK   r1,  r1, STK_CTX_SIZE       /* Clean up the stack (i.e. de-allocate storage)               */
1000800c:	b62e0000 	rtid	r14, 0

    RTID    r14, 0                      /* Branch to task level code enabling interrupts, IE=1         */
10008010:	84000000 	and	r0, r0, r0

10008014 <OSCtxSw>:
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10008014:	3021ff88 	addik	r1, r1, -120
*********************************************************************************************************
*/

OSCtxSw:
                                        /* *************** SAVE CURRENT TASK'S CONTEXT *************** */
    ADDIK    r1,  r1, -STK_CTX_SIZE     /* Allocate storage for saving registers onto stack            */
10008018:	f8410004 	swi	r2, r1, 4

    SWI     r2,  r1,  STK_OFFSET_R02    /* Save the remaining registers onto the task's stack          */
1000801c:	f8610008 	swi	r3, r1, 8
    SWI     r3,  r1,  STK_OFFSET_R03
10008020:	f881000c 	swi	r4, r1, 12
    SWI     r4,  r1,  STK_OFFSET_R04
10008024:	f8a10010 	swi	r5, r1, 16
    SWI     r5,  r1,  STK_OFFSET_R05
10008028:	f8c10014 	swi	r6, r1, 20
    SWI     r6,  r1,  STK_OFFSET_R06
1000802c:	f8e10018 	swi	r7, r1, 24
    SWI     r7,  r1,  STK_OFFSET_R07
10008030:	f901001c 	swi	r8, r1, 28
    SWI     r8,  r1,  STK_OFFSET_R08
10008034:	f9210020 	swi	r9, r1, 32
    SWI     r9,  r1,  STK_OFFSET_R09
10008038:	f9410024 	swi	r10, r1, 36
    SWI     r10, r1,  STK_OFFSET_R10
1000803c:	f9610028 	swi	r11, r1, 40
    SWI     r11, r1,  STK_OFFSET_R11
10008040:	f981002c 	swi	r12, r1, 44
    SWI     r12, r1,  STK_OFFSET_R12
10008044:	f9a10030 	swi	r13, r1, 48
    SWI     r13, r1,  STK_OFFSET_R13
10008048:	f9c10034 	swi	r14, r1, 52
    SWI     r14, r1,  STK_OFFSET_R14
1000804c:	f9e10038 	swi	r15, r1, 56
    SWI     r15, r1,  STK_OFFSET_R15
10008050:	fa21003c 	swi	r17, r1, 60
    SWI     r17, r1,  STK_OFFSET_R17                   
10008054:	fa410040 	swi	r18, r1, 64
    SWI     r18, r1,  STK_OFFSET_R18
10008058:	fa610044 	swi	r19, r1, 68
    SWI     r19, r1,  STK_OFFSET_R19
1000805c:	fa810048 	swi	r20, r1, 72
    SWI     r20, r1,  STK_OFFSET_R20 
10008060:	faa1004c 	swi	r21, r1, 76
    SWI     r21, r1,  STK_OFFSET_R21
10008064:	fac10050 	swi	r22, r1, 80
    SWI     r22, r1,  STK_OFFSET_R22
10008068:	fae10054 	swi	r23, r1, 84
    SWI     r23, r1,  STK_OFFSET_R23
1000806c:	fb010058 	swi	r24, r1, 88
    SWI     r24, r1,  STK_OFFSET_R24
10008070:	fb21005c 	swi	r25, r1, 92
    SWI     r25, r1,  STK_OFFSET_R25
10008074:	fb410060 	swi	r26, r1, 96
    SWI     r26, r1,  STK_OFFSET_R26
10008078:	fb610064 	swi	r27, r1, 100
    SWI     r27, r1,  STK_OFFSET_R27
1000807c:	fb810068 	swi	r28, r1, 104
    SWI     r28, r1,  STK_OFFSET_R28
10008080:	fba1006c 	swi	r29, r1, 108
    SWI     r29, r1,  STK_OFFSET_R29
10008084:	fbc10070 	swi	r30, r1, 112
    SWI     r30, r1,  STK_OFFSET_R30
10008088:	fbe10074 	swi	r31, r1, 116
    SWI     r31, r1,  STK_OFFSET_R31
1000808c:	94608001 	mfs	r3, rmsr

    MFS     r3,  RMSR                   /* save the MSR (See Note 1)                                   */
10008090:	f8610000 	swi	r3, r1, 0
    SWI     r3,  r1,  STK_OFFSET_RMSR
10008094:	b0001000 	imm	4096
10008098:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
               
    LWI     r3,  r0, OSTCBCur           /* OSTCBCur->OSTCBStkPtr = SP                                  */
1000809c:	d8201800 	sw	r1, r0, r3
    SW      r1,  r0, r3
100080a0:	b9f4fcfc 	brlid	r15, -772	// 10007d9c <OSTaskSwHook>
100080a4:	84000000 	and	r0, r0, r0

    BRLID   r15, OSTaskSwHook           /* Call OSTaskSwHook()                                         */
100080a8:	b0001000 	imm	4096
    AND     r0,  r0, r0                 /* NO-OP                                                       */
100080ac:	e060ce22 	lbui	r3, r0, -12766	// 1000ce22 <OSPrioHighRdy>
100080b0:	b0001000 	imm	4096

    LBUI    r3,  r0, OSPrioHighRdy      /* OSPrioCur = OSPrioHighRdy                                   */
100080b4:	f060d0f4 	sbi	r3, r0, -12044	// 1000d0f4 <OSPrioCur>
100080b8:	b0001000 	imm	4096
    SBI     r3,  r0, OSPrioCur
100080bc:	e860d3f0 	lwi	r3, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
100080c0:	b0001000 	imm	4096

    LWI     r3,  r0, OSTCBHighRdy       /* OSTCBCur  = OSTCBHighRdy                                    */          
100080c4:	f860d60c 	swi	r3, r0, -10740	// 1000d60c <OSTCBCur>
100080c8:	c8201800 	lw	r1, r0, r3
    SWI     r3,  r0, OSTCBCur
100080cc:	ebe10074 	lwi	r31, r1, 116

    LW      r1,  r0, r3                 /* SP = OSTCBHighRdy->OSTCBStkPtr                              */
100080d0:	ebc10070 	lwi	r30, r1, 112
  
    LWI     r31, r1, STK_OFFSET_R31     /* **************** RESTORE NEW TASK'S CONTEXT *************** */
100080d4:	eba1006c 	lwi	r29, r1, 108
    LWI     r30, r1, STK_OFFSET_R30
100080d8:	eb810068 	lwi	r28, r1, 104
    LWI     r29, r1, STK_OFFSET_R29
100080dc:	eb610064 	lwi	r27, r1, 100
    LWI     r28, r1, STK_OFFSET_R28
100080e0:	eb410060 	lwi	r26, r1, 96
    LWI     r27, r1, STK_OFFSET_R27
100080e4:	eb21005c 	lwi	r25, r1, 92
    LWI     r26, r1, STK_OFFSET_R26
100080e8:	eb010058 	lwi	r24, r1, 88
    LWI     r25, r1, STK_OFFSET_R25
100080ec:	eae10054 	lwi	r23, r1, 84
    LWI     r24, r1, STK_OFFSET_R24
100080f0:	eac10050 	lwi	r22, r1, 80
    LWI     r23, r1, STK_OFFSET_R23
100080f4:	eaa1004c 	lwi	r21, r1, 76
    LWI     r22, r1, STK_OFFSET_R22
100080f8:	ea810048 	lwi	r20, r1, 72
    LWI     r21, r1, STK_OFFSET_R21
100080fc:	ea610044 	lwi	r19, r1, 68
    LWI     r20, r1, STK_OFFSET_R20
10008100:	ea410040 	lwi	r18, r1, 64
    LWI     r19, r1, STK_OFFSET_R19
10008104:	ea21003c 	lwi	r17, r1, 60
    LWI     r18, r1, STK_OFFSET_R18
10008108:	e9e10038 	lwi	r15, r1, 56
    LWI     r17, r1, STK_OFFSET_R17                   
1000810c:	e9c10034 	lwi	r14, r1, 52
    LWI     r15, r1, STK_OFFSET_R15
10008110:	e9a10030 	lwi	r13, r1, 48
    LWI     r14, r1, STK_OFFSET_R14
10008114:	e981002c 	lwi	r12, r1, 44
    LWI     r13, r1, STK_OFFSET_R13
10008118:	e9610028 	lwi	r11, r1, 40
    LWI     r12, r1, STK_OFFSET_R12
1000811c:	e9410024 	lwi	r10, r1, 36
    LWI     r11, r1, STK_OFFSET_R11
10008120:	e9210020 	lwi	r9, r1, 32
    LWI     r10, r1, STK_OFFSET_R10
10008124:	e901001c 	lwi	r8, r1, 28
    LWI     r9,  r1, STK_OFFSET_R09
10008128:	e8e10018 	lwi	r7, r1, 24
    LWI     r8,  r1, STK_OFFSET_R08
1000812c:	e8c10014 	lwi	r6, r1, 20
    LWI     r7,  r1, STK_OFFSET_R07
10008130:	e8a10010 	lwi	r5, r1, 16
    LWI     r6,  r1, STK_OFFSET_R06   
10008134:	e881000c 	lwi	r4, r1, 12
    LWI     r5,  r1, STK_OFFSET_R05
10008138:	e8410004 	lwi	r2, r1, 4
    LWI     r4,  r1, STK_OFFSET_R04
1000813c:	e8610000 	lwi	r3, r1, 0
    LWI     r2,  r1, STK_OFFSET_R02
10008140:	a4630002 	andi	r3, r3, 2
    
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008144:	bc23001c 	bnei	r3, 28	// 10008160 <OSCtxSw_SavedByISR>
    ANDI    r3,  r3, CPU_IE_BIT         /* See if IE is 0 (Saved by OSCtxSw()) or 1 (Saved by ISR)     */
10008148:	e8610000 	lwi	r3, r1, 0
    BNEI    r3,  OSCtxSw_SavedByISR     /* Branch if ISR saved context                                 */
1000814c:	9403c001 	mts	rmsr, r3

                                        /* *********** The context was saved by OSCtxSw() ************ */
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008150:	e8610008 	lwi	r3, r1, 8
    MTS     RMSR,r3
10008154:	30210078 	addik	r1, r1, 120
    LWI     r3,  r1, STK_OFFSET_R03     /* Restore R3 (was used a scratchpad register for RMSR)        */
10008158:	b60f0008 	rtsd	r15, 8

    ADDIK    r1,  r1, STK_CTX_SIZE      /* Clean up the stack (deallocate storage)                     */
1000815c:	84000000 	and	r0, r0, r0

10008160 <OSCtxSw_SavedByISR>:

    RTSD    r15, 8                      /* Context was saved by OSCtxSw()                              */
10008160:	e8610000 	lwi	r3, r1, 0
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10008164:	ac630002 	andni	r3, r3, 2

OSCtxSw_SavedByISR:
                                        /* ************ The context was saved by an ISR ************** */
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008168:	9403c001 	mts	rmsr, r3
    ANDNI   r3,  r3, CPU_IE_BIT         /* Clear the IE bit (It will be set by the return from INT.)   */
1000816c:	e8610008 	lwi	r3, r1, 8
    MTS     RMSR,r3 
10008170:	30210078 	addik	r1, r1, 120
    LWI     r3,  r1, STK_OFFSET_R03     /* Restore R3 (was used a scratchpad register for RMSR)        */
10008174:	b62e0000 	rtid	r14, 0

    ADDIK    r1,  r1, STK_CTX_SIZE      /* Clean up the stack (deallocate storage)                     */
10008178:	84000000 	and	r0, r0, r0

1000817c <OSIntCtxSw>:

    RTID    r14, 0                      /* Context was saved by ISR, return address is in R14, Set IE  */
1000817c:	b9f4fc20 	brlid	r15, -992	// 10007d9c <OSTaskSwHook>
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10008180:	84000000 	and	r0, r0, r0
10008184:	b0001000 	imm	4096
*********************************************************************************************************
*/

OSIntCtxSw:

    BRLID   r15, OSTaskSwHook           /* Call OSTaskSwHook()                                         */
10008188:	e060ce22 	lbui	r3, r0, -12766	// 1000ce22 <OSPrioHighRdy>
    AND     r0,  r0, r0                 /* NO-OP                                                       */
1000818c:	b0001000 	imm	4096
10008190:	f060d0f4 	sbi	r3, r0, -12044	// 1000d0f4 <OSPrioCur>

    LBUI    r3,  r0, OSPrioHighRdy      /* OSPrioCur = OSPrioHighRdy                                   */
10008194:	b0001000 	imm	4096
10008198:	e860d3f0 	lwi	r3, r0, -11280	// 1000d3f0 <OSTCBHighRdy>
    SBI     r3,  r0, OSPrioCur
1000819c:	b0001000 	imm	4096
100081a0:	f860d60c 	swi	r3, r0, -10740	// 1000d60c <OSTCBCur>

    LWI     r3,  r0, OSTCBHighRdy       /* OSTCBCur  = OSTCBHighRdy                                    */          
100081a4:	c8201800 	lw	r1, r0, r3
100081a8:	ebe10074 	lwi	r31, r1, 116
    SWI     r3,  r0, OSTCBCur
100081ac:	ebc10070 	lwi	r30, r1, 112

    LW      r1,  r0, r3                 /* SP = OSTCBHighRdy->OSTCBStkPtr                              */
100081b0:	eba1006c 	lwi	r29, r1, 108
    
    LWI     r31, r1, STK_OFFSET_R31     /* **************** RESTORE NEW TASK'S CONTEXT *************** */
100081b4:	eb810068 	lwi	r28, r1, 104
    LWI     r30, r1, STK_OFFSET_R30
100081b8:	eb610064 	lwi	r27, r1, 100
    LWI     r29, r1, STK_OFFSET_R29
100081bc:	eb410060 	lwi	r26, r1, 96
    LWI     r28, r1, STK_OFFSET_R28
100081c0:	eb21005c 	lwi	r25, r1, 92
    LWI     r27, r1, STK_OFFSET_R27
100081c4:	eb010058 	lwi	r24, r1, 88
    LWI     r26, r1, STK_OFFSET_R26
100081c8:	eae10054 	lwi	r23, r1, 84
    LWI     r25, r1, STK_OFFSET_R25
100081cc:	eac10050 	lwi	r22, r1, 80
    LWI     r24, r1, STK_OFFSET_R24
100081d0:	eaa1004c 	lwi	r21, r1, 76
    LWI     r23, r1, STK_OFFSET_R23
100081d4:	ea810048 	lwi	r20, r1, 72
    LWI     r22, r1, STK_OFFSET_R22
100081d8:	ea610044 	lwi	r19, r1, 68
    LWI     r21, r1, STK_OFFSET_R21
100081dc:	ea410040 	lwi	r18, r1, 64
    LWI     r20, r1, STK_OFFSET_R20
100081e0:	ea21003c 	lwi	r17, r1, 60
    LWI     r19, r1, STK_OFFSET_R19
100081e4:	e9e10038 	lwi	r15, r1, 56
    LWI     r18, r1, STK_OFFSET_R18
100081e8:	e9c10034 	lwi	r14, r1, 52
    LWI     r17, r1, STK_OFFSET_R17       
100081ec:	e9a10030 	lwi	r13, r1, 48
    LWI     r15, r1, STK_OFFSET_R15
100081f0:	e981002c 	lwi	r12, r1, 44
    LWI     r14, r1, STK_OFFSET_R14
100081f4:	e9610028 	lwi	r11, r1, 40
    LWI     r13, r1, STK_OFFSET_R13
100081f8:	e9410024 	lwi	r10, r1, 36
    LWI     r12, r1, STK_OFFSET_R12
100081fc:	e9210020 	lwi	r9, r1, 32
    LWI     r11, r1, STK_OFFSET_R11
10008200:	e901001c 	lwi	r8, r1, 28
    LWI     r10, r1, STK_OFFSET_R10
10008204:	e8e10018 	lwi	r7, r1, 24
    LWI     r9,  r1, STK_OFFSET_R09
10008208:	e8c10014 	lwi	r6, r1, 20
    LWI     r8,  r1, STK_OFFSET_R08
1000820c:	e8a10010 	lwi	r5, r1, 16
    LWI     r7,  r1, STK_OFFSET_R07
10008210:	e881000c 	lwi	r4, r1, 12
    LWI     r6,  r1, STK_OFFSET_R06
10008214:	e8410004 	lwi	r2, r1, 4
    LWI     r5,  r1, STK_OFFSET_R05
10008218:	e8610000 	lwi	r3, r1, 0
    LWI     r4,  r1, STK_OFFSET_R04
1000821c:	a4630002 	andi	r3, r3, 2
    LWI     r2,  r1, STK_OFFSET_R02
10008220:	bc23001c 	bnei	r3, 28	// 1000823c <OSIntCtxSw_SavedByISR>
    
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008224:	e8610000 	lwi	r3, r1, 0
    ANDI    r3,  r3, CPU_IE_BIT         /* See if IE is 0 (Saved by OSCtxSw()) or 1 (Saved by ISR)     */
10008228:	9403c001 	mts	rmsr, r3
    BNEI    r3,  OSIntCtxSw_SavedByISR  /* Branch if ISR saved context                                 */
1000822c:	e8610008 	lwi	r3, r1, 8

                                        /* *********** The context was saved by OSCtxSw() ************ */
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008230:	30210078 	addik	r1, r1, 120
    MTS     RMSR,r3 
10008234:	b60f0008 	rtsd	r15, 8
    LWI     r3,  r1, STK_OFFSET_R03     /* Restore R3 (was used a scratchpad register for RMSR)        */
10008238:	84000000 	and	r0, r0, r0

1000823c <OSIntCtxSw_SavedByISR>:

    ADDIK    r1,  r1, STK_CTX_SIZE      /* Clean up the stack (deallocate storage)                     */                   
1000823c:	e8610000 	lwi	r3, r1, 0

    RTSD    r15, 8                      /* Context was saved by OSCtxSw()                              */
10008240:	ac630002 	andni	r3, r3, 2
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10008244:	9403c001 	mts	rmsr, r3

OSIntCtxSw_SavedByISR:                  /* ************ The context was saved by an ISR ************** */
    LWI     r3,  r1, STK_OFFSET_RMSR    /* Get the saved RMSR                                          */
10008248:	e8610008 	lwi	r3, r1, 8
    ANDNI   r3,  r3, CPU_IE_BIT         /* Clear the IE bit (It will be set by the return from INT.)   */
1000824c:	30210078 	addik	r1, r1, 120
    MTS     RMSR,r3 
10008250:	b62e0000 	rtid	r14, 0
    LWI     r3,  r1, STK_OFFSET_R03     /* Restore R3 (was used a scratchpad register for RMSR)        */
10008254:	84000000 	and	r0, r0, r0

10008258 <OS_CPU_ISR>:

    ADDIK   r1,  r1, STK_CTX_SIZE       /* Clean up the stack (deallocate storage)                     */                   
10008258:	3021ff88 	addik	r1, r1, -120

    RTID    r14, 0                      /* Context was saved by ISR, return address is in R14          */
1000825c:	f8410004 	swi	r2, r1, 4
    AND     r0,  r0, r0                 /* NO-OP                                                       */
10008260:	f8610008 	swi	r3, r1, 8
*/

_interrupt_handler:
OS_CPU_ISR:
                                             /* ********** SAVE INTERRUPTED TASK'S CONTEXT *********** */
    ADDIK    r1,  r1, -STK_CTX_SIZE          /* Allocate storage for saving registers onto stack       */
10008264:	f881000c 	swi	r4, r1, 12

    SWI     r2,  r1,  STK_OFFSET_R02         
10008268:	f8a10010 	swi	r5, r1, 16
    SWI     r3,  r1,  STK_OFFSET_R03
1000826c:	f8c10014 	swi	r6, r1, 20
    SWI     r4,  r1,  STK_OFFSET_R04
10008270:	f8e10018 	swi	r7, r1, 24
    SWI     r5,  r1,  STK_OFFSET_R05
10008274:	f901001c 	swi	r8, r1, 28
    SWI     r6,  r1,  STK_OFFSET_R06
10008278:	f9210020 	swi	r9, r1, 32
    SWI     r7,  r1,  STK_OFFSET_R07
1000827c:	f9410024 	swi	r10, r1, 36
    SWI     r8,  r1,  STK_OFFSET_R08
10008280:	f9610028 	swi	r11, r1, 40
    SWI     r9,  r1,  STK_OFFSET_R09
10008284:	f981002c 	swi	r12, r1, 44
    SWI     r10, r1,  STK_OFFSET_R10
10008288:	f9a10030 	swi	r13, r1, 48
    SWI     r11, r1,  STK_OFFSET_R11
1000828c:	f9c10034 	swi	r14, r1, 52
    SWI     r12, r1,  STK_OFFSET_R12
10008290:	f9e10038 	swi	r15, r1, 56
    SWI     r13, r1,  STK_OFFSET_R13
10008294:	fa21003c 	swi	r17, r1, 60
    SWI     r14, r1,  STK_OFFSET_R14
10008298:	fa410040 	swi	r18, r1, 64
    SWI     r15, r1,  STK_OFFSET_R15
1000829c:	fa610044 	swi	r19, r1, 68
    SWI     r17, r1,  STK_OFFSET_R17          
100082a0:	fa810048 	swi	r20, r1, 72
    SWI     r18, r1,  STK_OFFSET_R18
100082a4:	faa1004c 	swi	r21, r1, 76
    SWI     r19, r1,  STK_OFFSET_R19
100082a8:	fac10050 	swi	r22, r1, 80
    SWI     r20, r1,  STK_OFFSET_R20
100082ac:	fae10054 	swi	r23, r1, 84
    SWI     r21, r1,  STK_OFFSET_R21
100082b0:	fb010058 	swi	r24, r1, 88
    SWI     r22, r1,  STK_OFFSET_R22
100082b4:	fb21005c 	swi	r25, r1, 92
    SWI     r23, r1,  STK_OFFSET_R23
100082b8:	fb410060 	swi	r26, r1, 96
    SWI     r24, r1,  STK_OFFSET_R24
100082bc:	fb610064 	swi	r27, r1, 100
    SWI     r25, r1,  STK_OFFSET_R25
100082c0:	fb810068 	swi	r28, r1, 104
    SWI     r26, r1,  STK_OFFSET_R26
100082c4:	fba1006c 	swi	r29, r1, 108
    SWI     r27, r1,  STK_OFFSET_R27
100082c8:	fbc10070 	swi	r30, r1, 112
    SWI     r28, r1,  STK_OFFSET_R28
100082cc:	fbe10074 	swi	r31, r1, 116
    SWI     r29, r1,  STK_OFFSET_R29
100082d0:	94608001 	mfs	r3, rmsr
    SWI     r30, r1,  STK_OFFSET_R30
100082d4:	a0630002 	ori	r3, r3, 2
    SWI     r31, r1,  STK_OFFSET_R31
100082d8:	f8610000 	swi	r3, r1, 0

    MFS     r3,  RMSR                        /* save the MSR                                           */
100082dc:	b0001000 	imm	4096
    ORI     r3,  r3, CPU_IE_BIT              /* Set IE to 1 to return to interrupted task with INT en. */
100082e0:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
    SWI     r3,  r1, STK_OFFSET_RMSR         /* MSR is at top of frame                                 */
100082e4:	bc230010 	bnei	r3, 16	// 100082f4 <OS_CPU_ISR_1>
100082e8:	b0001000 	imm	4096

    LBUI    r3,  r0, OSIntNesting            /* if (OSIntNesting == 0) {                               */
100082ec:	e860d60c 	lwi	r3, r0, -10740	// 1000d60c <OSTCBCur>
    BNEI    r3,  OS_CPU_ISR_1
100082f0:	d8201800 	sw	r1, r0, r3

100082f4 <OS_CPU_ISR_1>:
100082f4:	b0001000 	imm	4096

    LWI     r3,  r0, OSTCBCur                /*     OSTCBCur->OSTCBStkPtr = SP                         */
100082f8:	e060d608 	lbui	r3, r0, -10744	// 1000d608 <OSIntNesting>
    SW      r1,  r0, r3                      /* }                                                      */
100082fc:	30630001 	addik	r3, r3, 1
10008300:	b0001000 	imm	4096

OS_CPU_ISR_1:
    LBUI    r3,  r0, OSIntNesting
10008304:	f060d608 	sbi	r3, r0, -10744	// 1000d608 <OSIntNesting>
    ADDIK   r3,  r3, 1                       /* OSIntNesting++;                                        */
10008308:	b9f48070 	brlid	r15, -32656	// 10000378 <BSP_IntHandler>
1000830c:	84000000 	and	r0, r0, r0
    SBI     r3,  r0, OSIntNesting
10008310:	b9f49c20 	brlid	r15, -25568	// 10001f30 <OSIntExit>
10008314:	84000000 	and	r0, r0, r0

    BRLID   r15, BSP_IntHandler              /* Call the provided C level interrupt handler            */
10008318:	ebe10074 	lwi	r31, r1, 116
    AND     r0,  r0, r0                      /* NO-OP                                                  */
1000831c:	ebc10070 	lwi	r30, r1, 112
10008320:	eba1006c 	lwi	r29, r1, 108
    
    BRLID   r15, OSIntExit                   /* OSIntExit()                                            */
10008324:	eb810068 	lwi	r28, r1, 104
    AND     r0,  r0, r0                      /* NO-OP                                                  */
10008328:	eb610064 	lwi	r27, r1, 100

    LWI     r31, r1, STK_OFFSET_R31          /* ********* RESTORE INTERRUPTED TASK'S CONTEXT ********* */
1000832c:	eb410060 	lwi	r26, r1, 96
    LWI     r30, r1, STK_OFFSET_R30
10008330:	eb21005c 	lwi	r25, r1, 92
    LWI     r29, r1, STK_OFFSET_R29
10008334:	eb010058 	lwi	r24, r1, 88
    LWI     r28, r1, STK_OFFSET_R28
10008338:	eae10054 	lwi	r23, r1, 84
    LWI     r27, r1, STK_OFFSET_R27
1000833c:	eac10050 	lwi	r22, r1, 80
    LWI     r26, r1, STK_OFFSET_R26
10008340:	eaa1004c 	lwi	r21, r1, 76
    LWI     r25, r1, STK_OFFSET_R25
10008344:	ea810048 	lwi	r20, r1, 72
    LWI     r24, r1, STK_OFFSET_R24
10008348:	ea610044 	lwi	r19, r1, 68
    LWI     r23, r1, STK_OFFSET_R23
1000834c:	ea410040 	lwi	r18, r1, 64
    LWI     r22, r1, STK_OFFSET_R22
10008350:	ea21003c 	lwi	r17, r1, 60
    LWI     r21, r1, STK_OFFSET_R21
10008354:	e9e10038 	lwi	r15, r1, 56
    LWI     r20, r1, STK_OFFSET_R20
10008358:	e9c10034 	lwi	r14, r1, 52
    LWI     r19, r1, STK_OFFSET_R19
1000835c:	e9a10030 	lwi	r13, r1, 48
    LWI     r18, r1, STK_OFFSET_R18
10008360:	e981002c 	lwi	r12, r1, 44
    LWI     r17, r1, STK_OFFSET_R17      
10008364:	e9610028 	lwi	r11, r1, 40
    LWI     r15, r1, STK_OFFSET_R15
10008368:	e9410024 	lwi	r10, r1, 36
    LWI     r14, r1, STK_OFFSET_R14
1000836c:	e9210020 	lwi	r9, r1, 32
    LWI     r13, r1, STK_OFFSET_R13
10008370:	e901001c 	lwi	r8, r1, 28
    LWI     r12, r1, STK_OFFSET_R12
10008374:	e8e10018 	lwi	r7, r1, 24
    LWI     r11, r1, STK_OFFSET_R11
10008378:	e8c10014 	lwi	r6, r1, 20
    LWI     r10, r1, STK_OFFSET_R10
1000837c:	e8a10010 	lwi	r5, r1, 16
    LWI     r9,  r1, STK_OFFSET_R09
10008380:	e881000c 	lwi	r4, r1, 12
    LWI     r8,  r1, STK_OFFSET_R08
10008384:	e8410004 	lwi	r2, r1, 4
    LWI     r7,  r1, STK_OFFSET_R07
10008388:	e8610000 	lwi	r3, r1, 0
    LWI     r6,  r1, STK_OFFSET_R06
1000838c:	ac630002 	andni	r3, r3, 2
    LWI     r5,  r1, STK_OFFSET_R05
10008390:	9403c001 	mts	rmsr, r3
    LWI     r4,  r1, STK_OFFSET_R04
10008394:	e8610008 	lwi	r3, r1, 8
    LWI     r2,  r1, STK_OFFSET_R02
10008398:	30210078 	addik	r1, r1, 120
    
    LWI     r3,  r1, STK_OFFSET_RMSR         /* Get RMSR                                               */
1000839c:	b62e0000 	rtid	r14, 0
    ANDNI   r3,  r3, CPU_IE_BIT              /* Clear IE to prevent interrupts until stack is cleaned  */
100083a0:	84000000 	and	r0, r0, r0

100083a4 <_exception_handler>:
100083a4:	b6110000 	rtsd	r17, 0
100083a8:	80000000 	or	r0, r0, r0

100083ac <_hw_exception_handler>:
100083ac:	b6910000 	rted	r17, 0
100083b0:	80000000 	or	r0, r0, r0

100083b4 <_program_clean>:
100083b4:	b60f0008 	rtsd	r15, 8
100083b8:	80000000 	or	r0, r0, r0

100083bc <_program_init>:
100083bc:	b60f0008 	rtsd	r15, 8
100083c0:	80000000 	or	r0, r0, r0

100083c4 <exit>:
100083c4:	3021ffe0 	addik	r1, r1, -32
100083c8:	10c00000 	addk	r6, r0, r0
100083cc:	fa61001c 	swi	r19, r1, 28
100083d0:	f9e10000 	swi	r15, r1, 0
100083d4:	b9f4002c 	brlid	r15, 44	// 10008400 <__call_exitprocs>
100083d8:	12650000 	addk	r19, r5, r0
100083dc:	b0001000 	imm	4096
100083e0:	e8808c18 	lwi	r4, r0, -29672	// 10008c18 <_global_impure_ptr>
100083e4:	e8640028 	lwi	r3, r4, 40
100083e8:	bc03000c 	beqi	r3, 12		// 100083f4
100083ec:	99fc1800 	brald	r15, r3
100083f0:	10a40000 	addk	r5, r4, r0
100083f4:	b000ffff 	imm	-1
100083f8:	b9f47c84 	brlid	r15, 31876	// 1000007c <_exit>
100083fc:	10b30000 	addk	r5, r19, r0

10008400 <__call_exitprocs>:
10008400:	3021ffb8 	addik	r1, r1, -72
10008404:	fbc10040 	swi	r30, r1, 64
10008408:	b0001000 	imm	4096
1000840c:	ebc08c18 	lwi	r30, r0, -29672	// 10008c18 <_global_impure_ptr>
10008410:	fb610034 	swi	r27, r1, 52
10008414:	13660000 	addk	r27, r6, r0
10008418:	fba1003c 	swi	r29, r1, 60
1000841c:	fbe10044 	swi	r31, r1, 68
10008420:	f9e10000 	swi	r15, r1, 0
10008424:	fa61001c 	swi	r19, r1, 28
10008428:	fac10020 	swi	r22, r1, 32
1000842c:	fae10024 	swi	r23, r1, 36
10008430:	fb010028 	swi	r24, r1, 40
10008434:	fb21002c 	swi	r25, r1, 44
10008438:	fb410030 	swi	r26, r1, 48
1000843c:	fb810038 	swi	r28, r1, 56
10008440:	f8a1004c 	swi	r5, r1, 76
10008444:	33fe0048 	addik	r31, r30, 72
10008448:	33a00001 	addik	r29, r0, 1
1000844c:	eafe0048 	lwi	r23, r30, 72
10008450:	be1700d8 	beqid	r23, 216		// 10008528
10008454:	139f0000 	addk	r28, r31, r0
10008458:	e8770004 	lwi	r3, r23, 4
1000845c:	3263ffff 	addik	r19, r3, -1
10008460:	be5300bc 	bltid	r19, 188		// 1000851c
10008464:	eb370088 	lwi	r25, r23, 136
10008468:	be1b0124 	beqid	r27, 292		// 1000858c
1000846c:	32c30001 	addik	r22, r3, 1
10008470:	bc1900ac 	beqi	r25, 172		// 1000851c
10008474:	33030001 	addik	r24, r3, 1
10008478:	66d30402 	bslli	r22, r19, 2
1000847c:	67180402 	bslli	r24, r24, 2
10008480:	12d9b000 	addk	r22, r25, r22
10008484:	b810001c 	brid	28		// 100084a0
10008488:	1317c000 	addk	r24, r23, r24
1000848c:	3273ffff 	addik	r19, r19, -1
10008490:	a873ffff 	xori	r3, r19, -1
10008494:	32d6fffc 	addik	r22, r22, -4
10008498:	be030084 	beqid	r3, 132		// 1000851c
1000849c:	3318fffc 	addik	r24, r24, -4
100084a0:	e8760080 	lwi	r3, r22, 128
100084a4:	8863d800 	xor	r3, r3, r27
100084a8:	bc23ffe4 	bnei	r3, -28		// 1000848c
100084ac:	eb570004 	lwi	r26, r23, 4
100084b0:	30daffff 	addik	r6, r26, -1
100084b4:	88e69800 	xor	r7, r6, r19
100084b8:	be0700b8 	beqid	r7, 184		// 10008570
100084bc:	e8980000 	lwi	r4, r24, 0
100084c0:	f8780000 	swi	r3, r24, 0
100084c4:	be04ffc8 	beqid	r4, -56		// 1000848c
100084c8:	447d9c00 	bsll	r3, r29, r19
100084cc:	e8d90100 	lwi	r6, r25, 256
100084d0:	84c33000 	and	r6, r3, r6
100084d4:	bc06008c 	beqi	r6, 140		// 10008560
100084d8:	e8b90104 	lwi	r5, r25, 260
100084dc:	84632800 	and	r3, r3, r5
100084e0:	be03009c 	beqid	r3, 156		// 1000857c
100084e4:	e8a1004c 	lwi	r5, r1, 76
100084e8:	99fc2000 	brald	r15, r4
100084ec:	e8b60000 	lwi	r5, r22, 0
100084f0:	e8770004 	lwi	r3, r23, 4
100084f4:	8b43d000 	xor	r26, r3, r26
100084f8:	bc3aff54 	bnei	r26, -172		// 1000844c
100084fc:	e87c0000 	lwi	r3, r28, 0
10008500:	8863b800 	xor	r3, r3, r23
10008504:	be23ff48 	bneid	r3, -184		// 1000844c
10008508:	3273ffff 	addik	r19, r19, -1
1000850c:	a873ffff 	xori	r3, r19, -1
10008510:	32d6fffc 	addik	r22, r22, -4
10008514:	be23ff8c 	bneid	r3, -116		// 100084a0
10008518:	3318fffc 	addik	r24, r24, -4
1000851c:	b0000000 	imm	0
10008520:	30600000 	addik	r3, r0, 0
10008524:	bc230194 	bnei	r3, 404		// 100086b8
10008528:	e9e10000 	lwi	r15, r1, 0
1000852c:	ea61001c 	lwi	r19, r1, 28
10008530:	eac10020 	lwi	r22, r1, 32
10008534:	eae10024 	lwi	r23, r1, 36
10008538:	eb010028 	lwi	r24, r1, 40
1000853c:	eb21002c 	lwi	r25, r1, 44
10008540:	eb410030 	lwi	r26, r1, 48
10008544:	eb610034 	lwi	r27, r1, 52
10008548:	eb810038 	lwi	r28, r1, 56
1000854c:	eba1003c 	lwi	r29, r1, 60
10008550:	ebc10040 	lwi	r30, r1, 64
10008554:	ebe10044 	lwi	r31, r1, 68
10008558:	b60f0008 	rtsd	r15, 8
1000855c:	30210048 	addik	r1, r1, 72
10008560:	99fc2000 	brald	r15, r4
10008564:	80000000 	or	r0, r0, r0
10008568:	b810ff8c 	brid	-116		// 100084f4
1000856c:	e8770004 	lwi	r3, r23, 4
10008570:	f8d70004 	swi	r6, r23, 4
10008574:	b810ff50 	brid	-176		// 100084c4
10008578:	13460000 	addk	r26, r6, r0
1000857c:	99fc2000 	brald	r15, r4
10008580:	e8d60000 	lwi	r6, r22, 0
10008584:	b810ff70 	brid	-144		// 100084f4
10008588:	e8770004 	lwi	r3, r23, 4
1000858c:	be1900c8 	beqid	r25, 200		// 10008654
10008590:	66d60402 	bslli	r22, r22, 2
10008594:	67530402 	bslli	r26, r19, 2
10008598:	13030000 	addk	r24, r3, r0
1000859c:	3063ffff 	addik	r3, r3, -1
100085a0:	12d7b000 	addk	r22, r23, r22
100085a4:	88c39800 	xor	r6, r3, r19
100085a8:	1359d000 	addk	r26, r25, r26
100085ac:	be06007c 	beqid	r6, 124		// 10008628
100085b0:	e8960000 	lwi	r4, r22, 0
100085b4:	f8160000 	swi	r0, r22, 0
100085b8:	be040044 	beqid	r4, 68		// 100085fc
100085bc:	447d9c00 	bsll	r3, r29, r19
100085c0:	e8b90100 	lwi	r5, r25, 256
100085c4:	84a32800 	and	r5, r3, r5
100085c8:	bc05006c 	beqi	r5, 108		// 10008634
100085cc:	e8b90104 	lwi	r5, r25, 260
100085d0:	84632800 	and	r3, r3, r5
100085d4:	be230070 	bneid	r3, 112		// 10008644
100085d8:	e8a1004c 	lwi	r5, r1, 76
100085dc:	99fc2000 	brald	r15, r4
100085e0:	e8da0000 	lwi	r6, r26, 0
100085e4:	e8770004 	lwi	r3, r23, 4
100085e8:	8863c000 	xor	r3, r3, r24
100085ec:	bc23fe60 	bnei	r3, -416		// 1000844c
100085f0:	e87c0000 	lwi	r3, r28, 0
100085f4:	8863b800 	xor	r3, r3, r23
100085f8:	bc23fe54 	bnei	r3, -428		// 1000844c
100085fc:	3273ffff 	addik	r19, r19, -1
10008600:	a873ffff 	xori	r3, r19, -1
10008604:	32d6fffc 	addik	r22, r22, -4
10008608:	be03ff14 	beqid	r3, -236		// 1000851c
1000860c:	335afffc 	addik	r26, r26, -4
10008610:	e8770004 	lwi	r3, r23, 4
10008614:	13030000 	addk	r24, r3, r0
10008618:	3063ffff 	addik	r3, r3, -1
1000861c:	88c39800 	xor	r6, r3, r19
10008620:	be26ff94 	bneid	r6, -108		// 100085b4
10008624:	e8960000 	lwi	r4, r22, 0
10008628:	f8770004 	swi	r3, r23, 4
1000862c:	b810ff8c 	brid	-116		// 100085b8
10008630:	13030000 	addk	r24, r3, r0
10008634:	99fc2000 	brald	r15, r4
10008638:	80000000 	or	r0, r0, r0
1000863c:	b810ffac 	brid	-84		// 100085e8
10008640:	e8770004 	lwi	r3, r23, 4
10008644:	99fc2000 	brald	r15, r4
10008648:	e8ba0000 	lwi	r5, r26, 0
1000864c:	b810ff9c 	brid	-100		// 100085e8
10008650:	e8770004 	lwi	r3, r23, 4
10008654:	12d7b000 	addk	r22, r23, r22
10008658:	13030000 	addk	r24, r3, r0
1000865c:	3063ffff 	addik	r3, r3, -1
10008660:	88839800 	xor	r4, r3, r19
10008664:	be040048 	beqid	r4, 72		// 100086ac
10008668:	e8b60000 	lwi	r5, r22, 0
1000866c:	f8160000 	swi	r0, r22, 0
10008670:	bc050024 	beqi	r5, 36		// 10008694
10008674:	99fc2800 	brald	r15, r5
10008678:	80000000 	or	r0, r0, r0
1000867c:	e8770004 	lwi	r3, r23, 4
10008680:	8863c000 	xor	r3, r3, r24
10008684:	bc23fdc8 	bnei	r3, -568		// 1000844c
10008688:	e87c0000 	lwi	r3, r28, 0
1000868c:	8863b800 	xor	r3, r3, r23
10008690:	bc23fdbc 	bnei	r3, -580		// 1000844c
10008694:	3273ffff 	addik	r19, r19, -1
10008698:	a873ffff 	xori	r3, r19, -1
1000869c:	be03fe80 	beqid	r3, -384		// 1000851c
100086a0:	32d6fffc 	addik	r22, r22, -4
100086a4:	b810ffb4 	brid	-76		// 10008658
100086a8:	e8770004 	lwi	r3, r23, 4
100086ac:	f8770004 	swi	r3, r23, 4
100086b0:	b810ffc0 	brid	-64		// 10008670
100086b4:	13030000 	addk	r24, r3, r0
100086b8:	e8770004 	lwi	r3, r23, 4
100086bc:	bc230040 	bnei	r3, 64		// 100086fc
100086c0:	e8770000 	lwi	r3, r23, 0
100086c4:	bc03003c 	beqi	r3, 60		// 10008700
100086c8:	be190014 	beqid	r25, 20		// 100086dc
100086cc:	f87c0000 	swi	r3, r28, 0
100086d0:	b000efff 	imm	-4097
100086d4:	b9f4792c 	brlid	r15, 31020	// 0 <STK_OFFSET_RMSR>
100086d8:	10b90000 	addk	r5, r25, r0
100086dc:	b000efff 	imm	-4097
100086e0:	b9f47920 	brlid	r15, 31008	// 0 <STK_OFFSET_RMSR>
100086e4:	10b70000 	addk	r5, r23, r0
100086e8:	eafc0000 	lwi	r23, r28, 0
100086ec:	be37fd6c 	bneid	r23, -660		// 10008458
100086f0:	e9e10000 	lwi	r15, r1, 0
100086f4:	b810fe3c 	brid	-452		// 10008530
100086f8:	ea61001c 	lwi	r19, r1, 28
100086fc:	e8770000 	lwi	r3, r23, 0
10008700:	13970000 	addk	r28, r23, r0
10008704:	b810ffe8 	brid	-24		// 100086ec
10008708:	12e30000 	addk	r23, r3, r0

1000870c <__do_global_ctors_aux>:
1000870c:	b0001000 	imm	4096
10008710:	e8608d20 	lwi	r3, r0, -29408	// 10008d20 <__data_end>
10008714:	3021ffe0 	addik	r1, r1, -32
10008718:	f9e10000 	swi	r15, r1, 0
1000871c:	a883ffff 	xori	r4, r3, -1
10008720:	be040024 	beqid	r4, 36		// 10008744
10008724:	fa61001c 	swi	r19, r1, 28
10008728:	b0001000 	imm	4096
1000872c:	32608d20 	addik	r19, r0, -29408	// 10008d20 <__data_end>
10008730:	99fc1800 	brald	r15, r3
10008734:	3273fffc 	addik	r19, r19, -4
10008738:	e8730000 	lwi	r3, r19, 0
1000873c:	a883ffff 	xori	r4, r3, -1
10008740:	bc24fff0 	bnei	r4, -16		// 10008730
10008744:	e9e10000 	lwi	r15, r1, 0
10008748:	ea61001c 	lwi	r19, r1, 28
1000874c:	b60f0008 	rtsd	r15, 8
10008750:	30210020 	addik	r1, r1, 32

10008754 <main>:
* Returns    : main() should NEVER return
*********************************************************************************************************
*/

int  main (void)
{
10008754:	3021ffd4 	addik	r1, r1, -44
10008758:	f9e10000 	swi	r15, r1, 0
1000875c:	b0004000 	imm	16384
10008760:	f800000c 	swi	r0, r0, 12
    CPU_INT08U    err;

    BSP_IntDisAll();
    OSInit();                                   /* Initialize uC/OS-II                                 */
10008764:	b9f49dbc 	brlid	r15, -25156	// 10002520 <OSInit>
10008768:	80000000 	or	r0, r0, r0

    OSTaskCreateExt(FirstTask,
1000876c:	3100000a 	addik	r8, r0, 10
10008770:	11280000 	addk	r9, r8, r0
10008774:	b0001000 	imm	4096
10008778:	31408d58 	addik	r10, r0, -29352	// 10008d58 <FirstTaskStk>
1000877c:	b0001000 	imm	4096
10008780:	30a07e5c 	addik	r5, r0, 32348	// 10007e5c <FirstTask>
10008784:	b0001000 	imm	4096
10008788:	30e0ad54 	addik	r7, r0, -21164
1000878c:	30600800 	addik	r3, r0, 2048
10008790:	f861001c 	swi	r3, r1, 28
10008794:	10c00000 	addk	r6, r0, r0
10008798:	30600003 	addik	r3, r0, 3
1000879c:	f8010020 	swi	r0, r1, 32
100087a0:	b9f4e4fc 	brlid	r15, -6916	// 10006c9c <OSTaskCreateExt>
100087a4:	f8610024 	swi	r3, r1, 36
                   &FirstTaskStk[0],
                   TASK_STK_SIZE,
                   (void *)0,
                   OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR); 
    
    OSTaskNameSet(TASK1_PRIO, (CPU_INT08U *)"FirstTask", &err);
100087a8:	b0001000 	imm	4096
100087ac:	30c08c0c 	addik	r6, r0, -29684
100087b0:	30a0000a 	addik	r5, r0, 10
100087b4:	b9f4df58 	brlid	r15, -8360	// 1000670c <OSTaskNameSet>
100087b8:	30e10028 	addik	r7, r1, 40

    OSStart();                                  /* Start Multitasking                                  */
100087bc:	b9f4989c 	brlid	r15, -26468	// 10002058 <OSStart>
100087c0:	80000000 	or	r0, r0, r0

    return 0;                                   /* Process should never reach this point               */
}
100087c4:	e9e10000 	lwi	r15, r1, 0
100087c8:	10600000 	addk	r3, r0, r0
100087cc:	b60f0008 	rtsd	r15, 8
100087d0:	3021002c 	addik	r1, r1, 44

Disassembly of section .init:

100087d4 <__init>:
100087d4:	3021fff8 	addik	r1, r1, -8
100087d8:	d9e00800 	sw	r15, r0, r1
100087dc:	b0001000 	imm	4096
100087e0:	3160e398 	addik	r11, r0, -7272
100087e4:	940bc802 	mts	rshr, r11
100087e8:	b0001000 	imm	4096
100087ec:	3160e2ac 	addik	r11, r0, -7508
100087f0:	940bc800 	mts	rslr, r11
100087f4:	b000ffff 	imm	-1
100087f8:	b9f4793c 	brlid	r15, 31036	// 10000134 <frame_dummy>
100087fc:	80000000 	or	r0, r0, r0
10008800:	b9f4ff0c 	brlid	r15, -244	// 1000870c <__do_global_ctors_aux>
10008804:	80000000 	or	r0, r0, r0
10008808:	c9e00800 	lw	r15, r0, r1
1000880c:	b60f0008 	rtsd	r15, 8
10008810:	30210008 	addik	r1, r1, 8

Disassembly of section .fini:

10008814 <__fini>:
10008814:	3021fff8 	addik	r1, r1, -8
10008818:	d9e00800 	sw	r15, r0, r1
1000881c:	b000ffff 	imm	-1
10008820:	b9f47860 	brlid	r15, 30816	// 10000080 <__do_global_dtors_aux>
10008824:	80000000 	or	r0, r0, r0
10008828:	c9e00800 	lw	r15, r0, r1
1000882c:	b60f0008 	rtsd	r15, 8
10008830:	30210008 	addik	r1, r1, 8

Disassembly of section .rodata:

10008834 <__rodata_start>:
10008834:	286e756c 	addic	r3, r14, 30060
10008838:	6c290000 	get	r1, rfsl0

1000883c <CPU_CntLeadZerosTbl>:
1000883c:	08070606 		r0, r7, r0
10008840:	05050505 	neg	r8, r5
10008844:	04040404 	neg	r0, r4
10008848:	04040404 	neg	r0, r4
1000884c:	03030303 		r24, r3, r0
10008850:	03030303 		r24, r3, r0
10008854:	03030303 		r24, r3, r0
10008858:	03030303 		r24, r3, r0
1000885c:	02020202 		r16, r2, r0
10008860:	02020202 		r16, r2, r0
10008864:	02020202 		r16, r2, r0
10008868:	02020202 		r16, r2, r0
1000886c:	02020202 		r16, r2, r0
10008870:	02020202 		r16, r2, r0
10008874:	02020202 		r16, r2, r0
10008878:	02020202 		r16, r2, r0
1000887c:	01010101 		r8, r1, r0
10008880:	01010101 		r8, r1, r0
10008884:	01010101 		r8, r1, r0
10008888:	01010101 		r8, r1, r0
1000888c:	01010101 		r8, r1, r0
10008890:	01010101 		r8, r1, r0
10008894:	01010101 		r8, r1, r0
10008898:	01010101 		r8, r1, r0
1000889c:	01010101 		r8, r1, r0
100088a0:	01010101 		r8, r1, r0
100088a4:	01010101 		r8, r1, r0
100088a8:	01010101 		r8, r1, r0
100088ac:	01010101 		r8, r1, r0
100088b0:	01010101 		r8, r1, r0
100088b4:	01010101 		r8, r1, r0
100088b8:	01010101 		r8, r1, r0
100088bc:	
1000893c <Str_MultOvfThTbl_Int32U>:
1000893c:	ffffffff 		r31, r31, r31
10008940:	ffffffff 		r31, r31, r31
10008944:	7fffffff 		r31, r31, r31
10008948:	55555555 		r10, r21, r10
1000894c:	3fffffff 	rsubikc	r31, r31, -1
10008950:	33333333 	addik	r25, r19, 13107
10008954:	2aaaaaaa 	addic	r21, r10, -21846
10008958:	24924924 	rsubi	r4, r18, 18724
1000895c:	1fffffff 		r31, r31, r31
10008960:	1c71c71c 		r3, r17, r24
10008964:	19999999 		r12, r25, r19
10008968:	1745d174 		r26, r5, r26
1000896c:	15555555 		r10, r21, r10
10008970:	13b13b13 		r29, r17, r7
10008974:	12492492 		r18, r9, r4
10008978:	11111111 		r8, r17, r2
1000897c:	0fffffff 		r31, r31, r31
10008980:	0f0f0f0f 		r24, r15, r1
10008984:	0e38e38e 		r17, r24, r28
10008988:	0d79435e 		r11, r25, r8
1000898c:	0ccccccc 		r6, r12, r25
10008990:	0c30c30c 		r1, r16, r24
10008994:	0ba2e8ba 		r29, r2, r29
10008998:	0b21642c 		r25, r1, r12
1000899c:	0aaaaaaa 		r21, r10, r21
100089a0:	0a3d70a3 		r17, r29, r14
100089a4:	09d89d89 		r14, r24, r19
100089a8:	097b425e 		r11, r27, r8
100089ac:	09249249 		r9, r4, r18
100089b0:	08d3dcb0 		r6, r19, r27
100089b4:	08888888 		r4, r8, r17
100089b8:	08421084 		r2, r2, r2
100089bc:	07ffffff 	neg	r31, r31
100089c0:	07c1f07c 	neg	r30, r1
100089c4:	07878787 	neg	r28, r7
100089c8:	07507507 	neg	r26, r16
100089cc:	071c71c7 	neg	r24, r28
100089d0:	3f000000 	rsubikc	r24, r0, 0
100089d4:	75432f4f 		r10, r3, r5
100089d8:	532d4949 		r25, r13, r9
100089dc:	2049646c 	addi	r2, r9, 25708
100089e0:	65000000 	bsrli	r8, r0, 0
100089e4:	75432f4f 		r10, r3, r5
100089e8:	532d4949 		r25, r13, r9
100089ec:	20537461 	addi	r2, r19, 29793
100089f0:	74000000 		r0, r0, r0

100089f4 <OSUnMapTbl>:
100089f4:	00000100 		r0, r0, r0
100089f8:	02000100 		r16, r0, r0
100089fc:	03000100 		r24, r0, r0
10008a00:	02000100 		r16, r0, r0
10008a04:	04000100 	neg	r0, r0
10008a08:	02000100 		r16, r0, r0
10008a0c:	03000100 		r24, r0, r0
10008a10:	02000100 		r16, r0, r0
10008a14:	05000100 	neg	r8, r0
10008a18:	02000100 		r16, r0, r0
10008a1c:	03000100 		r24, r0, r0
10008a20:	02000100 		r16, r0, r0
10008a24:	04000100 	neg	r0, r0
10008a28:	02000100 		r16, r0, r0
10008a2c:	03000100 		r24, r0, r0
10008a30:	02000100 		r16, r0, r0
10008a34:	06000100 	neg	r16, r0
10008a38:	02000100 		r16, r0, r0
10008a3c:	03000100 		r24, r0, r0
10008a40:	02000100 		r16, r0, r0
10008a44:	04000100 	neg	r0, r0
10008a48:	02000100 		r16, r0, r0
10008a4c:	03000100 		r24, r0, r0
10008a50:	02000100 		r16, r0, r0
10008a54:	05000100 	neg	r8, r0
10008a58:	02000100 		r16, r0, r0
10008a5c:	03000100 		r24, r0, r0
10008a60:	02000100 		r16, r0, r0
10008a64:	04000100 	neg	r0, r0
10008a68:	02000100 		r16, r0, r0
10008a6c:	03000100 		r24, r0, r0
10008a70:	02000100 		r16, r0, r0
10008a74:	07000100 	neg	r24, r0
10008a78:	02000100 		r16, r0, r0
10008a7c:	03000100 		r24, r0, r0
10008a80:	02000100 		r16, r0, r0
10008a84:	04000100 	neg	r0, r0
10008a88:	02000100 		r16, r0, r0
10008a8c:	03000100 		r24, r0, r0
10008a90:	02000100 		r16, r0, r0
10008a94:	05000100 	neg	r8, r0
10008a98:	02000100 		r16, r0, r0
10008a9c:	03000100 		r24, r0, r0
10008aa0:	02000100 		r16, r0, r0
10008aa4:	04000100 	neg	r0, r0
10008aa8:	02000100 		r16, r0, r0
10008aac:	03000100 		r24, r0, r0
10008ab0:	02000100 		r16, r0, r0
10008ab4:	06000100 	neg	r16, r0
10008ab8:	02000100 		r16, r0, r0
10008abc:	03000100 		r24, r0, r0
10008ac0:	02000100 		r16, r0, r0
10008ac4:	04000100 	neg	r0, r0
10008ac8:	02000100 		r16, r0, r0
10008acc:	03000100 		r24, r0, r0
10008ad0:	02000100 		r16, r0, r0
10008ad4:	05000100 	neg	r8, r0
10008ad8:	02000100 		r16, r0, r0
10008adc:	03000100 		r24, r0, r0
10008ae0:	02000100 		r16, r0, r0
10008ae4:	04000100 	neg	r0, r0
10008ae8:	02000100 		r16, r0, r0
10008aec:	03000100 		r24, r0, r0
10008af0:	02000100 		r16, r0, r0
10008af4:	3f000000 	rsubikc	r24, r0, 0
10008af8:	3f000000 	rsubikc	r24, r0, 0
10008afc:	3f000000 	rsubikc	r24, r0, 0
10008b00:	3f000000 	rsubikc	r24, r0, 0
10008b04:	3f000000 	rsubikc	r24, r0, 0
10008b08:	3f000000 	rsubikc	r24, r0, 0
10008b0c:	3f000000 	rsubikc	r24, r0, 0
10008b10:	3f000000 	rsubikc	r24, r0, 0
10008b14:	75432f4f 		r10, r3, r5
10008b18:	532d4949 		r25, r13, r9
10008b1c:	20546d72 	addi	r2, r20, 28018
10008b20:	4c6f636b 	necagetd	r3, r12
10008b24:	
10008b4c <OSDataSize>:
10008b4c:	13c20040 		r30, r2, r0

10008b4e <OSTmrWheelTblSize>:
10008b4e:	00400008 		r2, r0, r0

10008b50 <OSTmrWheelSize>:
10008b50:	00080280 		r0, r8, r0

10008b52 <OSTmrTblSize>:
10008b52:	02800028 		r20, r0, r0

10008b54 <OSTmrSize>:
10008b54:	0028000a 		r1, r8, r0

10008b56 <OSTmrCfgTicksPerSec>:
10008b56:	000a0008 		r0, r10, r0

10008b58 <OSTmrCfgWheelSize>:
10008b58:	00080001 		r0, r8, r0

10008b5a <OSTmrCfgNameEn>:
10008b5a:	00010010 		r0, r1, r0

10008b5c <OSTmrCfgMax>:
10008b5c:	00100001 		r0, r16, r0

10008b5e <OSTmrEn>:
10008b5e:	00010122 		r0, r1, r0

10008b60 <OSVersionNbr>:
10008b60:	01220001 		r9, r2, r0

10008b62 <OSTimeTickHookEn>:
10008b62:	00010064 		r0, r1, r0

10008b64 <OSTicksPerSec>:
10008b64:	00640058 		r3, r4, r0

10008b66 <OSTCBSize>:
10008b66:	00580040 		r2, r24, r0

10008b68 <OSTCBPrioTblMax>:
10008b68:	00400001 		r2, r0, r0

10008b6a <OSTaskRegTblSize>:
10008b6a:	00010001 		r0, r1, r0

10008b6c <OSTaskSwHookEn>:
10008b6c:	00010001 		r0, r1, r0

10008b6e <OSTaskStatStkChkEn>:
10008b6e:	00010080 		r0, r1, r0

10008b70 <OSTaskStatStkSize>:
10008b70:	00800001 		r4, r0, r0

10008b72 <OSTaskStatEn>:
10008b72:	00010001 		r0, r1, r0

10008b74 <OSTaskNameEn>:
10008b74:	00010016 		r0, r1, r0

10008b76 <OSTaskMax>:
10008b76:	00160001 		r0, r22, r0

10008b78 <OSTaskProfileEn>:
10008b78:	00010080 		r0, r1, r0

10008b7a <OSTaskIdleStkSize>:
10008b7a:	00800001 		r4, r0, r0

10008b7c <OSTaskDelEn>:
10008b7c:	00010001 		r0, r1, r0

10008b7e <OSTaskCreateExtEn>:
10008b7e:	00010001 		r0, r1, r0

10008b80 <OSTaskCreateEn>:
10008b80:	00010004 		r0, r1, r0

10008b82 <OSStkWidth>:
10008b82:	00040001 		r0, r4, r0

10008b84 <OSSemEn>:
10008b84:	00010008 		r0, r1, r0

10008b86 <OSRdyTblSize>:
10008b86:	00080018 		r0, r8, r0

10008b88 <OSQSize>:
10008b88:	00180004 		r0, r24, r0

10008b8a <OSQMax>:
10008b8a:	00040001 		r0, r4, r0

10008b8c <OSQEn>:
10008b8c:	00010004 		r0, r1, r0

10008b8e <OSPtrSize>:
10008b8e:	00040001 		r0, r4, r0

10008b90 <OSMutexEn>:
10008b90:	00010078 		r0, r1, r0

10008b92 <OSMemTblSize>:
10008b92:	00780018 		r3, r24, r0

10008b94 <OSMemSize>:
10008b94:	00180001 		r0, r24, r0

10008b96 <OSMemNameEn>:
10008b96:	00010005 		r0, r1, r0

10008b98 <OSMemMax>:
10008b98:	00050001 		r0, r5, r0

10008b9a <OSMemEn>:
10008b9a:	00010001 		r0, r1, r0

10008b9c <OSMboxEn>:
10008b9c:	0001003f 		r0, r1, r0

10008b9e <OSLowestPrio>:
10008b9e:	003f0001 		r1, r31, r0

10008ba0 <OSFlagNameEn>:
10008ba0:	00010005 		r0, r1, r0

10008ba2 <OSFlagMax>:
10008ba2:	00050002 		r0, r5, r0

10008ba4 <OSFlagWidth>:
10008ba4:	00020014 		r0, r2, r0

10008ba6 <OSFlagNodeSize>:
10008ba6:	00140010 		r0, r20, r0

10008ba8 <OSFlagGrpSize>:
10008ba8:	00100001 		r0, r16, r0

10008baa <OSFlagEn>:
10008baa:	00010001 		r0, r1, r0

10008bac <OSEventMultiEn>:
10008bac:	000100f0 		r0, r1, r0

10008bae <OSEventTblSize>:
10008bae:	00f00018 		r7, r16, r0

10008bb0 <OSEventSize>:
10008bb0:	00180001 		r0, r24, r0

10008bb2 <OSEventNameEn>:
10008bb2:	0001000a 		r0, r1, r0

10008bb4 <OSEventMax>:
10008bb4:	000a0001 		r0, r10, r0

10008bb6 <OSEventEn>:
10008bb6:	00011234 		r0, r1, r2

10008bb8 <OSEndiannessTest>:
10008bb8:	12345678 		r17, r20, r10

10008bbc <OSDebugEn>:
10008bbc:	00010000 	add	r0, r1, r0
10008bc0:	5365636f 		r27, r5, r12
10008bc4:	6e645461 	tneget	r19, rfsl1
10008bc8:	736b0000 		r27, r11, r0
10008bcc:	46697273 	bsra	r19, r9, r14
10008bd0:	74207461 		r1, r0, r14
10008bd4:	736b2073 		r27, r11, r4
10008bd8:	61797320 	muli	r11, r25, 29472
10008bdc:	48656c6c 		r3, r5, r13
10008be0:	6f20576f 	tneget	r25, rfsl15
10008be4:	726c640a 		r19, r12, r12
10008be8:	
10008c18 <_global_impure_ptr>:
10008c18:	10008c2c 		r0, r0, r17
10008c1c:	Address 0x10008c1c is out of bounds.


Disassembly of section .sdata2:

10008c1e <__sbss2_end-0x2>:
10008c1e:	Address 0x10008c1e is out of bounds.


Disassembly of section .data:

10008c20 <__data_start>:
10008c20:	
10008c24 <__dso_handle>:
10008c24:	
10008c28 <_impure_ptr>:
10008c28:	10008c2c 		r0, r0, r17

10008c2c <impure_data>:
10008c2c:	
10008d1c <force_to_data>:
10008d1c:	
Disassembly of section .ctors:

10008d20 <__CTOR_LIST__>:
10008d20:	ffffffff 		r31, r31, r31

10008d24 <__CTOR_END__>:
10008d24:	
Disassembly of section .dtors:

10008d28 <__DTOR_LIST__>:
10008d28:	ffffffff 		r31, r31, r31

10008d2c <__DTOR_END__>:
10008d2c:	
Disassembly of section .eh_frame:

10008d30 <__EH_FRAME_BEGIN__>:
10008d30:	
Disassembly of section .jcr:

10008d34 <__JCR_END__>:
10008d34:	
Disassembly of section .bss:

10008d38 <__bss_start>:
10008d38:	
10008d3c <dtor_idx.2340>:
10008d3c:	
10008d40 <object.2350>:
10008d40:	
10008d58 <FirstTaskStk>:
10008d58:	
1000ad58 <SecondTaskStk>:
1000ad58:	
1000cd58 <it_vector_table>:
1000cd58:	
1000cd98 <it_priority_table>:
1000cd98:	
1000cdb8 <CPU_Name>:
1000cdb8:	
1000cdc8 <Math_RandSeedCur>:
1000cdc8:	
1000cdcc <OSTmrFreeList>:
1000cdcc:	
1000cdd0 <OSTmrWheelTbl>:
1000cdd0:	
1000ce10 <OSLockNesting>:
1000ce10:	
1000ce14 <OSTmrSemSignal>:
1000ce14:	
1000ce18 <OSRunning>:
1000ce18:	
1000ce1c <OSIdleCtr>:
1000ce1c:	
1000ce20 <OSTmrUsed>:
1000ce20:	
1000ce22 <OSPrioHighRdy>:
1000ce22:	
1000ce24 <OSFlagTbl>:
1000ce24:	
1000ce74 <OSTmrTbl>:
1000ce74:	
1000d0f4 <OSPrioCur>:
1000d0f4:	
1000d0f8 <OSTCBList>:
1000d0f8:	
1000d0fc <OSMemTbl>:
1000d0fc:	
1000d174 <OSTickStepState>:
1000d174:	
1000d178 <OSTaskStatStk>:
1000d178:	
1000d378 <OSCtxSwCtr>:
1000d378:	
1000d37c <OSTmrFree>:
1000d37c:	
1000d380 <OSIdleCtrMax>:
1000d380:	
1000d384 <OSTCBFreeList>:
1000d384:	
1000d388 <OSCPUUsage>:
1000d388:	
1000d389 <OSTaskCtr>:
1000d389:	
1000d38c <OSMemFreeList>:
1000d38c:	
1000d390 <OSQTbl>:
1000d390:	
1000d3f0 <OSTCBHighRdy>:
1000d3f0:	
1000d3f4 <OSQFreeList>:
1000d3f4:	
1000d3f8 <OSRdyGrp>:
1000d3f8:	
1000d3fc <OSRdyTbl>:
1000d3fc:	
1000d404 <OSTmrTaskStk>:
1000d404:	
1000d604 <OSEventFreeList>:
1000d604:	
1000d608 <OSIntNesting>:
1000d608:	
1000d60c <OSTCBCur>:
1000d60c:	
1000d610 <OSTmrTime>:
1000d610:	
1000d614 <OSTime>:
1000d614:	
1000d618 <OSTmrSem>:
1000d618:	
1000d61c <OSTaskIdleStk>:
1000d61c:	
1000d81c <OSEventTbl>:
1000d81c:	
1000d90c <OSTCBTbl>:
1000d90c:	
1000e09c <OSFlagFreeList>:
1000e09c:	
1000e0a0 <OSStatRdy>:
1000e0a0:	
1000e0a4 <OSTCBPrioTbl>:
1000e0a4:	
1000e1a4 <OSIdleCtrRun>:
1000e1a4:	
Disassembly of section .heap:

1000e1a8 <_heap>:
1000e1a8:	
Disassembly of section .stack:

1000e2a8 <_stack_end>:
1000e2a8:	
Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	000000a7 		r0, r0, r0
       4:	00020000 	add	r0, r2, r0
       8:	00490101 		r2, r9, r0
       c:	fb0e0d00 	swi	r24, r14, 3328
      10:	01010101 		r8, r1, r0
      14:	00000001 		r0, r0, r0
      18:	0000012f 		r0, r0, r0
      1c:	676e752f 	bslli	r27, r14, 15
      20:	6d625f67 	tneaget	r11, rfsl7
      24:	6e752f2f 	ecaget	r19, rfsl15
      28:	7372632f 		r27, r18, r12
      2c:	6e65776c 	tnecget	r19, rfsl12
      30:	69622f6c 		r11, r2, r5
      34:	6962676c 		r11, r2, r12
      38:	6f73732f 	tncget	r27, rfsl15
      3c:	6d696372 	ncget	r11, rfsl2
      40:	6f626c61 	necaget	r27, rfsl1
      44:	7a650000 		r19, r5, r0
      48:	63727430 	muli	r27, r18, 29744
      4c:	2e530001 	rsubic	r18, r19, 1
      50:	
Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	000000b5 		r0, r0, r0
       4:	00020000 	add	r0, r2, r0
       8:	00000401 		r0, r0, r0
       c:	
Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	01110010 		r8, r17, r0
       4:	06550603 	neg	r18, r21
       8:	081b0825 		r0, r27, r1
       c:	08130500 		r0, r19, r0
      10:	00000111 		r0, r0, r0
      14:	00100655 		r0, r16, r0
      18:	0603081b 	neg	r16, r3
      1c:	08250813 		r1, r5, r1
      20:	05000000 	rsub	r8, r0, r0
      24:	01110010 		r8, r17, r0
      28:	06110112 	neg	r16, r17
      2c:	0103081b 		r8, r3, r1
      30:	08250813 		r1, r5, r1
      34:	05000000 	rsub	r8, r0, r0
      38:	01110125 		r8, r17, r0
      3c:	0e130b03 		r16, r19, r1
      40:	0e1b0e11 		r16, r27, r1
      44:	01120110 		r8, r18, r0
      48:	06000002 	neg	r16, r0
      4c:	24000b0b 	rsubi	r0, r0, 2827
      50:	3e0b030e 	rsubikc	r16, r11, 782
      54:	00000316 		r0, r0, r0
      58:	00030e3a 		r0, r3, r1
      5c:	0b3b0b49 		r25, r27, r1
      60:	13000004 		r24, r0, r0
      64:	24000b0b 	rsubi	r0, r0, 2827
      68:	3e0b0308 	rsubikc	r16, r11, 776
      6c:	0000052e 		r0, r0, r0
      70:	01030e3a 		r8, r3, r1
      74:	0b3b0b27 		r25, r27, r1
      78:	0c200b01 		r1, r0, r1
      7c:	13000006 		r24, r0, r0
      80:	0500030e 	neg	r8, r0
      84:	3a0b3b0b 	addikc	r16, r11, 15115
      88:	49130000 	idiv	r8, r19, r0
      8c:	07260049 	neg	r25, r6
      90:	13000008 		r24, r0, r0
      94:	0f000b0b 		r24, r0, r1
      98:	49130000 	idiv	r8, r19, r0
      9c:	092e0003 		r9, r14, r0
      a0:	0e3a0b3b 		r17, r26, r1
      a4:	0b270c20 		r25, r7, r1
      a8:	0b00000a 		r24, r0, r0
      ac:	2e013f0c 	rsubic	r16, r1, 16140
      b0:	030e3a0b 		r24, r14, r7
      b4:	3b0b270c 	addikc	r24, r11, 9996
      b8:	11011201 		r8, r1, r2
      bc:	400a0113 		r0, r10, r0
      c0:	00000b34 		r0, r0, r1
      c4:	00030e3a 		r0, r3, r1
      c8:	0b3b0b49 		r25, r27, r1
      cc:	13020600 		r24, r2, r0
      d0:	000c2e01 		r0, r12, r5
      d4:	3f0c030e 	rsubikc	r24, r12, 782
      d8:	3a0b3b0b 	addikc	r16, r11, 15115
      dc:	270c1101 	rsubi	r24, r12, 4353
      e0:	12014006 		r16, r1, r8
      e4:	01130000 	add	r8, r19, r0
      e8:	0d050003 		r8, r5, r0
      ec:	083a0b3b 		r1, r26, r1
      f0:	0b491302 		r26, r9, r2
      f4:	0600000e 	neg	r16, r0
      f8:	1d013113 		r8, r1, r6
      fc:	11011201 		r8, r1, r2
     100:	580b590b 		r0, r11, r11
     104:	00000f05 		r0, r0, r1
     108:	00311302 		r1, r17, r2
     10c:	06000010 	neg	r16, r0
     110:	3400030e 	rsubik	r0, r0, 782
     114:	3a0b3b0b 	addikc	r16, r11, 15115
     118:	4913020a 		r8, r19, r0
     11c:	0000111d 		r0, r0, r2
     120:	01311311 		r9, r17, r2
     124:	01120158 		r8, r18, r0
     128:	0b590b01 		r26, r25, r1
     12c:	13000012 		r24, r0, r0
     130:	1d003113 		r8, r0, r6
     134:	11011201 		r8, r1, r2
     138:	580b590b 		r0, r11, r11
     13c:	00001301 		r0, r0, r2
     140:	01491301 		r10, r9, r2
     144:	13000014 		r24, r0, r0
     148:	21004913 	addi	r8, r0, 18707
     14c:	2f0b0000 	rsubic	r24, r11, 0
     150:	15340003 	cmpu	r9, r20, r0
     154:	0e3a0b3b 		r17, r26, r1
     158:	0b491300 		r26, r9, r2
     15c:	00000111 		r0, r0, r0
     160:	01250e13 		r9, r5, r1
     164:	0b030e1b 		r24, r3, r1
     168:	0e110112 		r16, r17, r0
     16c:	01100600 		r8, r16, r0
     170:	00022400 		r0, r2, r4
     174:	0b0b3e0b 		r24, r11, r7
     178:	030e0000 	add	r24, r14, r0
     17c:	03160003 		r24, r22, r0
     180:	0e3a0b3b 		r17, r26, r1
     184:	0b491300 		r26, r9, r2
     188:	00042400 		r0, r4, r4
     18c:	0b0b3e0b 		r24, r11, r7
     190:	03080000 	add	r24, r8, r0
     194:	050f000b 	neg	r8, r15
     198:	0b491300 		r26, r9, r2
     19c:	00061501 		r0, r6, r2
     1a0:	270c0113 	rsubi	r24, r12, 275
     1a4:	00000705 		r0, r0, r0
     1a8:	00491300 		r2, r9, r2
     1ac:	00080f00 		r0, r8, r1
     1b0:	0b0b0000 	addc	r24, r11, r0
     1b4:	0913010b 		r8, r19, r0
     1b8:	0b3a0b3b 		r25, r26, r1
     1bc:	0b011300 		r24, r1, r2
     1c0:	000a0d00 		r0, r10, r1
     1c4:	030e3a0b 		r24, r14, r7
     1c8:	3b0b4913 	addikc	r24, r11, 18707
     1cc:	380a0000 	addikc	r0, r10, 0
     1d0:	0b2e013f 		r25, r14, r0
     1d4:	0c030e3a 		r0, r3, r1
     1d8:	0b3b0b27 		r25, r27, r1
     1dc:	0c110112 		r0, r17, r0
     1e0:	01400a01 		r10, r0, r1
     1e4:	1300000c 		r24, r0, r0
     1e8:	34000308 	rsubik	r0, r0, 776
     1ec:	3a0b3b0b 	addikc	r16, r11, 15115
     1f0:	49130206 		r8, r19, r0
     1f4:	00000d05 		r0, r0, r1
     1f8:	00030e3a 		r0, r3, r1
     1fc:	0b3b0b49 		r25, r27, r1
     200:	13020600 		r24, r2, r0
     204:	000e0500 		r0, r14, r0
     208:	030e3a0b 		r24, r14, r7
     20c:	3b0b4913 	addikc	r24, r11, 18707
     210:	020a0000 	add	r16, r10, r0
     214:	0f260049 		r25, r6, r0
     218:	13000010 		r24, r0, r0
     21c:	2e013f0c 	rsubic	r16, r1, 16140
     220:	030e3a0b 		r24, r14, r7
     224:	3b0b270c 	addikc	r24, r11, 9996
     228:	11011201 		r8, r1, r2
     22c:	40060113 		r0, r6, r0
     230:	00001134 		r0, r0, r2
     234:	00030e3a 		r0, r3, r1
     238:	0b3b0b49 		r25, r27, r1
     23c:	13020600 		r24, r2, r0
     240:	00120101 		r0, r18, r0
     244:	49130113 		r8, r19, r0
     248:	00001321 		r0, r0, r2
     24c:	0049132f 		r2, r9, r2
     250:	0b000014 		r24, r0, r0
     254:	3400030e 	rsubik	r0, r0, 782
     258:	3a0b3b0b 	addikc	r16, r11, 15115
     25c:	49130000 	idiv	r8, r19, r0
     260:	15340003 	cmpu	r9, r20, r0
     264:	0e3a0b3b 		r17, r26, r1
     268:	0b49133f 		r26, r9, r2
     26c:	0c3c0c00 		r1, r28, r1
     270:	00163400 		r0, r22, r6
     274:	030e3a0b 		r24, r14, r7
     278:	3b0b4913 	addikc	r24, r11, 18707
     27c:	3f0c020a 	rsubikc	r24, r12, 522
     280:	00000001 		r0, r0, r0
     284:	1101250e 		r8, r1, r4
     288:	130b030e 		r24, r11, r0
     28c:	1b0e1101 		r24, r14, r2
     290:	12011006 		r16, r1, r2
     294:	00000224 		r0, r0, r0
     298:	000b0b3e 		r0, r11, r1
     29c:	0b030e00 		r24, r3, r1
     2a0:	00031600 		r0, r3, r2
     2a4:	030e3a0b 		r24, r14, r7
     2a8:	3b0b4913 	addikc	r24, r11, 18707
     2ac:	00000424 		r0, r0, r0
     2b0:	000b0b3e 		r0, r11, r1
     2b4:	0b030800 	addc	r24, r3, r1
     2b8:	00052e01 		r0, r5, r5
     2bc:	3f0c030e 	rsubikc	r24, r12, 782
     2c0:	3a0b3b0b 	addikc	r16, r11, 15115
     2c4:	270c1101 	rsubi	r24, r12, 4353
     2c8:	12014006 		r16, r1, r8
     2cc:	01130000 	add	r8, r19, r0
     2d0:	06050003 	neg	r16, r5
     2d4:	083a0b3b 		r1, r26, r1
     2d8:	0b491302 		r26, r9, r2
     2dc:	06000007 	neg	r16, r0
     2e0:	0f000b0b 		r24, r0, r1
     2e4:	49130000 	idiv	r8, r19, r0
     2e8:	082e013f 		r1, r14, r0
     2ec:	0c030e3a 		r0, r3, r1
     2f0:	0b3b0b27 		r25, r27, r1
     2f4:	0c491311 		r2, r9, r2
     2f8:	01120140 		r8, r18, r0
     2fc:	06011300 	neg	r16, r1
     300:	00090500 		r0, r9, r0
     304:	030e3a0b 		r24, r14, r7
     308:	3b0b4913 	addikc	r24, r11, 18707
     30c:	02060000 	add	r16, r6, r0
     310:	0a340003 		r17, r20, r0
     314:	083a0b3b 		r1, r26, r1
     318:	0b491302 		r26, r9, r2
     31c:	0600000b 	neg	r16, r0
     320:	3400030e 	rsubik	r0, r0, 782
     324:	3a0b3b0b 	addikc	r16, r11, 15115
     328:	49130206 		r8, r19, r0
     32c:	00000c0b 		r0, r0, r1
     330:	01110112 		r8, r17, r0
     334:	0100000d 		r8, r0, r0
     338:	34000308 	rsubik	r0, r0, 776
     33c:	3a0b3b0b 	addikc	r16, r11, 15115
     340:	49130000 	idiv	r8, r19, r0
     344:	0e260049 		r17, r6, r0
     348:	1300000f 		r24, r0, r0
     34c:	0500030e 	neg	r8, r0
     350:	3a0b3b0b 	addikc	r16, r11, 15115
     354:	4913020a 		r8, r19, r0
     358:	00001034 		r0, r0, r2
     35c:	00030e3a 		r0, r3, r1
     360:	0b3b0b49 		r25, r27, r1
     364:	13020a00 		r24, r2, r1
     368:	00110101 		r0, r17, r0
     36c:	49130113 		r8, r19, r0
     370:	00001221 		r0, r0, r2
     374:	0049132f 		r2, r9, r2
     378:	0b000013 		r24, r0, r0
     37c:	34000308 	rsubik	r0, r0, 776
     380:	3a0b3b0b 	addikc	r16, r11, 15115
     384:	4913020a 		r8, r19, r0
     388:	0000140a 		r0, r0, r2
     38c:	0003083a 		r0, r3, r1
     390:	0b3b0b11 		r25, r27, r1
     394:	01000015 		r8, r0, r0
     398:	18000000 	addkc	r0, r0, r0
     39c:	16340003 	cmpu	r17, r20, r0
     3a0:	0e3a0b3b 		r17, r26, r1
     3a4:	0b491300 		r26, r9, r2
     3a8:	00000111 		r0, r0, r0
     3ac:	01250e13 		r9, r5, r1
     3b0:	0b030e1b 		r24, r3, r1
     3b4:	0e110112 		r16, r17, r0
     3b8:	01100600 		r8, r16, r0
     3bc:	00021600 		r0, r2, r2
     3c0:	030e3a0b 		r24, r14, r7
     3c4:	3b0b4913 	addikc	r24, r11, 18707
     3c8:	00000324 		r0, r0, r0
     3cc:	000b0b3e 		r0, r11, r1
     3d0:	0b030e00 		r24, r3, r1
     3d4:	00042400 		r0, r4, r4
     3d8:	0b0b3e0b 		r24, r11, r7
     3dc:	03080000 	add	r24, r8, r0
     3e0:	05160003 	neg	r8, r22
     3e4:	0e3a0b3b 		r17, r26, r1
     3e8:	05491300 	neg	r10, r9
     3ec:	00062e00 		r0, r6, r5
     3f0:	030e3a0b 		r24, r14, r7
     3f4:	3b05270c 	addikc	r24, r5, 9996
     3f8:	200b0000 	addi	r0, r11, 0
     3fc:	072e013f 	neg	r25, r14
     400:	0c030e3a 		r0, r3, r1
     404:	0b3b0b27 		r25, r27, r1
     408:	0c110112 		r0, r17, r0
     40c:	01400601 		r10, r0, r0
     410:	13000008 		r24, r0, r0
     414:	3400030e 	rsubik	r0, r0, 782
     418:	3a0b3b0b 	addikc	r16, r11, 15115
     41c:	49130206 		r8, r19, r0
     420:	0000091d 		r0, r0, r1
     424:	00311311 		r1, r17, r2
     428:	01120158 		r8, r18, r0
     42c:	0b590b00 		r26, r25, r1
     430:	000a2e01 		r0, r10, r5
     434:	3f0c030e 	rsubikc	r24, r12, 782
     438:	3a0b3b05 	addikc	r16, r11, 15109
     43c:	270c1101 	rsubi	r24, r12, 4353
     440:	12014006 		r16, r1, r8
     444:	01130000 	add	r8, r19, r0
     448:	0b050003 		r24, r5, r0
     44c:	0e3a0b3b 		r17, r26, r1
     450:	05491302 	neg	r10, r9
     454:	0600000c 	neg	r16, r0
     458:	3400030e 	rsubik	r0, r0, 782
     45c:	3a0b3b05 	addikc	r16, r11, 15109
     460:	49130206 		r8, r19, r0
     464:	00000d0f 		r0, r0, r1
     468:	000b0b49 		r0, r11, r1
     46c:	1300000e 		r24, r0, r0
     470:	34000308 	rsubik	r0, r0, 776
     474:	3a0b3b05 	addikc	r16, r11, 15109
     478:	49130206 		r8, r19, r0
     47c:	00000f2e 		r0, r0, r1
     480:	013f0c03 		r9, r31, r1
     484:	0e3a0b3b 		r17, r26, r1
     488:	05270c49 	neg	r9, r7
     48c:	13110112 		r24, r17, r0
     490:	01400a01 		r10, r0, r1
     494:	13000010 		r24, r0, r0
     498:	05000308 	neg	r8, r0
     49c:	3a0b3b05 	addikc	r16, r11, 15109
     4a0:	49130206 		r8, r19, r0
     4a4:	00001101 		r0, r0, r2
     4a8:	01491301 		r10, r9, r2
     4ac:	13000012 		r24, r0, r0
     4b0:	21004913 	addi	r8, r0, 18707
     4b4:	2f0b0000 	rsubic	r24, r11, 0
     4b8:	13340003 		r25, r20, r0
     4bc:	0e3a0b3b 		r17, r26, r1
     4c0:	0b49133f 		r26, r9, r2
     4c4:	0c3c0c00 		r1, r28, r1
     4c8:	00143400 		r0, r20, r6
     4cc:	030e3a0b 		r24, r14, r7
     4d0:	3b0b4913 	addikc	r24, r11, 18707
     4d4:	020a0000 	add	r16, r10, r0
     4d8:	15260049 		r9, r6, r0
     4dc:	13000016 		r24, r0, r0
     4e0:	3400030e 	rsubik	r0, r0, 782
     4e4:	3a0b3b0b 	addikc	r16, r11, 15115
     4e8:	49133f0c 		r8, r19, r7
     4ec:	020a0000 	add	r16, r10, r0
     4f0:	00011101 		r0, r1, r2
     4f4:	250e130b 	rsubi	r8, r14, 4875
     4f8:	030e1b0e 		r24, r14, r3
     4fc:	11011201 		r8, r1, r2
     500:	10060000 	addk	r0, r6, r0
     504:	02160003 		r16, r22, r0
     508:	0e3a0b3b 		r17, r26, r1
     50c:	0b491300 		r26, r9, r2
     510:	00032400 		r0, r3, r4
     514:	0b0b3e0b 		r24, r11, r7
     518:	030e0000 	add	r24, r14, r0
     51c:	0424000b 	neg	r1, r4
     520:	0b3e0b03 		r25, r30, r1
     524:	08000005 		r0, r0, r0
     528:	2e013f0c 	rsubic	r16, r1, 16140
     52c:	030e3a0b 		r24, r14, r7
     530:	3b0b270c 	addikc	r24, r11, 9996
     534:	49131101 		r8, r19, r2
     538:	1201400a 		r16, r1, r8
     53c:	01130000 	add	r8, r19, r0
     540:	06050003 	neg	r16, r5
     544:	083a0b3b 		r1, r26, r1
     548:	0b491302 		r26, r9, r2
     54c:	06000007 	neg	r16, r0
     550:	3400030e 	rsubik	r0, r0, 782
     554:	3a0b3b0b 	addikc	r16, r11, 15115
     558:	49130206 		r8, r19, r0
     55c:	00000834 		r0, r0, r1
     560:	00030e3a 		r0, r3, r1
     564:	0b3b0b49 		r25, r27, r1
     568:	13020a00 		r24, r2, r1
     56c:	00092e01 		r0, r9, r5
     570:	3f0c030e 	rsubikc	r24, r12, 782
     574:	3a0b3b05 	addikc	r16, r11, 15109
     578:	270c4913 	rsubi	r24, r12, 18707
     57c:	11011201 		r8, r1, r2
     580:	400a0113 		r0, r10, r0
     584:	00000a05 		r0, r0, r1
     588:	0003083a 		r0, r3, r1
     58c:	0b3b0549 		r25, r27, r0
     590:	13020600 		r24, r2, r0
     594:	000b3400 		r0, r11, r6
     598:	03083a0b 		r24, r8, r7
     59c:	3b054913 	addikc	r24, r5, 18707
     5a0:	02060000 	add	r16, r6, r0
     5a4:	0c340003 		r1, r20, r0
     5a8:	0e3a0b3b 		r17, r26, r1
     5ac:	05491302 	neg	r10, r9
     5b0:	0600000d 	neg	r16, r0
     5b4:	05000308 	neg	r8, r0
     5b8:	3a0b3b05 	addikc	r16, r11, 15109
     5bc:	4913020a 		r8, r19, r0
     5c0:	00000e34 		r0, r0, r1
     5c4:	00030e3a 		r0, r3, r1
     5c8:	0b3b0549 		r25, r27, r0
     5cc:	13020a00 		r24, r2, r1
     5d0:	000f2e01 		r0, r15, r5
     5d4:	3f0c030e 	rsubikc	r24, r12, 782
     5d8:	3a0b3b05 	addikc	r16, r11, 15109
     5dc:	270c4913 	rsubi	r24, r12, 18707
     5e0:	11011201 		r8, r1, r2
     5e4:	400a0000 	mul	r0, r10, r0
     5e8:	10340003 		r1, r20, r0
     5ec:	083a0b3b 		r1, r26, r1
     5f0:	05491302 	neg	r10, r9
     5f4:	0a000000 	addc	r16, r0, r0
     5f8:	01110125 		r8, r17, r0
     5fc:	0e130b03 		r16, r19, r1
     600:	0e1b0e11 		r16, r27, r1
     604:	01120110 		r8, r18, r0
     608:	06000002 	neg	r16, r0
     60c:	24000b0b 	rsubi	r0, r0, 2827
     610:	3e0b030e 	rsubikc	r16, r11, 782
     614:	00000316 		r0, r0, r0
     618:	00030e3a 		r0, r3, r1
     61c:	0b3b0b49 		r25, r27, r1
     620:	13000004 		r24, r0, r0
     624:	24000b0b 	rsubi	r0, r0, 2827
     628:	3e0b0308 	rsubikc	r16, r11, 776
     62c:	00000516 		r0, r0, r0
     630:	00030e3a 		r0, r3, r1
     634:	0b3b0549 		r25, r27, r0
     638:	13000006 		r24, r0, r0
     63c:	2e013f0c 	rsubic	r16, r1, 16140
     640:	030e3a0b 		r24, r14, r7
     644:	3b05270c 	addikc	r24, r5, 9996
     648:	4913200b 		r8, r19, r4
     64c:	01130000 	add	r8, r19, r0
     650:	07050003 	neg	r24, r5
     654:	0e3a0b3b 		r17, r26, r1
     658:	05491300 	neg	r10, r9
     65c:	00083400 		r0, r8, r6
     660:	030e3a0b 		r24, r14, r7
     664:	3b054913 	addikc	r24, r5, 18707
     668:	0000092e 		r0, r0, r1
     66c:	013f0c03 		r9, r31, r1
     670:	0e3a0b3b 		r17, r26, r1
     674:	0b270c11 		r25, r7, r1
     678:	01120140 		r8, r18, r0
     67c:	06011300 	neg	r16, r1
     680:	000a0500 		r0, r10, r0
     684:	030e3a0b 		r24, r14, r7
     688:	3b0b4913 	addikc	r24, r11, 18707
     68c:	02060000 	add	r16, r6, r0
     690:	0b340003 		r25, r20, r0
     694:	0e3a0b3b 		r17, r26, r1
     698:	0b491302 		r26, r9, r2
     69c:	0600000c 	neg	r16, r0
     6a0:	2e003f0c 	rsubic	r16, r0, 16140
     6a4:	030e3a0b 		r24, r14, r7
     6a8:	3b0b270c 	addikc	r24, r11, 9996
     6ac:	11011201 		r8, r1, r2
     6b0:	40060000 	mul	r0, r6, r0
     6b4:	0d2e013f 		r9, r14, r0
     6b8:	0c030e3a 		r0, r3, r1
     6bc:	0b3b0b27 		r25, r27, r1
     6c0:	0c491311 		r2, r9, r2
     6c4:	01120140 		r8, r18, r0
     6c8:	06011300 	neg	r16, r1
     6cc:	000e3400 		r0, r14, r6
     6d0:	030e3a0b 		r24, r14, r7
     6d4:	3b0b4913 	addikc	r24, r11, 18707
     6d8:	020a0000 	add	r16, r10, r0
     6dc:	0f1d0131 		r24, r29, r0
     6e0:	13110112 		r24, r17, r0
     6e4:	01580b59 		r10, r24, r1
     6e8:	0b000010 		r24, r0, r0
     6ec:	05003113 	neg	r8, r0
     6f0:	02060000 	add	r16, r6, r0
     6f4:	110b0111 		r8, r11, r0
     6f8:	01120100 		r8, r18, r0
     6fc:	00123400 		r0, r18, r6
     700:	31130206 	addik	r8, r19, 518
     704:	0000132e 		r0, r0, r2
     708:	01311311 		r9, r17, r2
     70c:	01120140 		r8, r18, r0
     710:	0a011300 		r16, r1, r2
     714:	00140500 		r0, r20, r0
     718:	3113020a 	addik	r8, r19, 522
     71c:	00001534 		r0, r0, r2
     720:	00311302 		r1, r17, r2
     724:	0a000016 		r16, r0, r0
     728:	3400030e 	rsubik	r0, r0, 782
     72c:	3a0b3b0b 	addikc	r16, r11, 15115
     730:	49133f0c 		r8, r19, r7
     734:	3c0c0000 	rsubikc	r0, r12, 0
     738:	17340003 	cmpu	r25, r20, r0
     73c:	0e3a0b3b 		r17, r26, r1
     740:	0b49133f 		r26, r9, r2
     744:	0c020a00 		r0, r2, r1
     748:	00000111 		r0, r0, r0
     74c:	01250e13 		r9, r5, r1
     750:	0b030e1b 		r24, r3, r1
     754:	0e110112 		r16, r17, r0
     758:	01100600 		r8, r16, r0
     75c:	00022400 		r0, r2, r4
     760:	0b0b3e0b 		r24, r11, r7
     764:	030e0000 	add	r24, r14, r0
     768:	03160003 		r24, r22, r0
     76c:	0e3a0b3b 		r17, r26, r1
     770:	0b491300 		r26, r9, r2
     774:	00042400 		r0, r4, r4
     778:	0b0b3e0b 		r24, r11, r7
     77c:	03080000 	add	r24, r8, r0
     780:	050f000b 	neg	r8, r15
     784:	0b000006 		r24, r0, r0
     788:	2e003f0c 	rsubic	r16, r0, 16140
     78c:	030e3a0b 		r24, r14, r7
     790:	3b0b270c 	addikc	r24, r11, 9996
     794:	11011201 		r8, r1, r2
     798:	400a0000 	mul	r0, r10, r0
     79c:	072e013f 	neg	r25, r14
     7a0:	0c030e3a 		r0, r3, r1
     7a4:	0b3b0527 		r25, r27, r0
     7a8:	0c110112 		r0, r17, r0
     7ac:	01400a01 		r10, r0, r1
     7b0:	13000008 		r24, r0, r0
     7b4:	0500030e 	neg	r8, r0
     7b8:	3a0b3b05 	addikc	r16, r11, 15109
     7bc:	49130206 		r8, r19, r0
     7c0:	00000905 		r0, r0, r1
     7c4:	00030e3a 		r0, r3, r1
     7c8:	0b3b0549 		r25, r27, r0
     7cc:	13020a00 		r24, r2, r1
     7d0:	000a3400 		r0, r10, r6
     7d4:	030e3a0b 		r24, r14, r7
     7d8:	3b054913 	addikc	r24, r5, 18707
     7dc:	02060000 	add	r16, r6, r0
     7e0:	0b340003 		r25, r20, r0
     7e4:	083a0b3b 		r1, r26, r1
     7e8:	05491302 	neg	r10, r9
     7ec:	0600000c 	neg	r16, r0
     7f0:	0f000b0b 		r24, r0, r1
     7f4:	49130000 	idiv	r8, r19, r0
     7f8:	0d2e013f 		r9, r14, r0
     7fc:	0c030e3a 		r0, r3, r1
     800:	0b3b0b27 		r25, r27, r1
     804:	0c110112 		r0, r17, r0
     808:	01400601 		r10, r0, r0
     80c:	1300000e 		r24, r0, r0
     810:	0500030e 	neg	r8, r0
     814:	3a0b3b0b 	addikc	r16, r11, 15115
     818:	49130206 		r8, r19, r0
     81c:	00000f34 		r0, r0, r1
     820:	00030e3a 		r0, r3, r1
     824:	0b3b0549 		r25, r27, r0
     828:	13000010 		r24, r0, r0
     82c:	2e013f0c 	rsubic	r16, r1, 16140
     830:	030e3a0b 		r24, r14, r7
     834:	3b05270c 	addikc	r24, r5, 9996
     838:	49131101 		r8, r19, r2
     83c:	1201400a 		r16, r1, r8
     840:	00000001 		r0, r0, r0
     844:	1101250e 		r8, r1, r4
     848:	130b030e 		r24, r11, r0
     84c:	1b0e1101 		r24, r14, r2
     850:	12011006 		r16, r1, r2
     854:	00000216 		r0, r0, r0
     858:	00030e3a 		r0, r3, r1
     85c:	0b3b0b49 		r25, r27, r1
     860:	13000003 		r24, r0, r0
     864:	24000b0b 	rsubi	r0, r0, 2827
     868:	3e0b030e 	rsubikc	r16, r11, 782
     86c:	00000424 		r0, r0, r0
     870:	000b0b3e 		r0, r11, r1
     874:	0b030800 	addc	r24, r3, r1
     878:	00052e01 		r0, r5, r5
     87c:	030e3a0b 		r24, r14, r7
     880:	3b05270c 	addikc	r24, r5, 9996
     884:	4913200b 		r8, r19, r4
     888:	01130000 	add	r8, r19, r0
     88c:	06050003 	neg	r16, r5
     890:	0e3a0b3b 		r17, r26, r1
     894:	05491300 	neg	r10, r9
     898:	00073400 		r0, r7, r6
     89c:	030e3a0b 		r24, r14, r7
     8a0:	3b054913 	addikc	r24, r5, 18707
     8a4:	00000834 		r0, r0, r1
     8a8:	0003083a 		r0, r3, r1
     8ac:	0b3b0549 		r25, r27, r0
     8b0:	13000009 		r24, r0, r0
     8b4:	0f000b0b 		r24, r0, r1
     8b8:	49130000 	idiv	r8, r19, r0
     8bc:	0a2e013f 		r17, r14, r0
     8c0:	0c030e3a 		r0, r3, r1
     8c4:	0b3b0527 		r25, r27, r0
     8c8:	0c491320 		r2, r9, r2
     8cc:	0b011300 		r24, r1, r2
     8d0:	000b2e01 		r0, r11, r5
     8d4:	030e3a0b 		r24, r14, r7
     8d8:	3b05270c 	addikc	r24, r5, 9996
     8dc:	49131101 		r8, r19, r2
     8e0:	12014006 		r16, r1, r8
     8e4:	01130000 	add	r8, r19, r0
     8e8:	0c050003 		r0, r5, r0
     8ec:	083a0b3b 		r1, r26, r1
     8f0:	05491302 	neg	r10, r9
     8f4:	0600000d 	neg	r16, r0
     8f8:	0500030e 	neg	r8, r0
     8fc:	3a0b3b05 	addikc	r16, r11, 15109
     900:	49130206 		r8, r19, r0
     904:	00000e05 		r0, r0, r1
     908:	0003083a 		r0, r3, r1
     90c:	0b3b0549 		r25, r27, r0
     910:	13020a00 		r24, r2, r1
     914:	000f0500 		r0, r15, r0
     918:	030e3a0b 		r24, r14, r7
     91c:	3b054913 	addikc	r24, r5, 18707
     920:	020a0000 	add	r16, r10, r0
     924:	10340003 		r1, r20, r0
     928:	0e3a0b3b 		r17, r26, r1
     92c:	05491302 	neg	r10, r9
     930:	06000011 	neg	r16, r0
     934:	34000308 	rsubik	r0, r0, 776
     938:	3a0b3b05 	addikc	r16, r11, 15109
     93c:	49130206 		r8, r19, r0
     940:	0000122e 		r0, r0, r2
     944:	01311311 		r9, r17, r2
     948:	01120140 		r8, r18, r0
     94c:	06011300 	neg	r16, r1
     950:	00130500 		r0, r19, r0
     954:	31130206 	addik	r8, r19, 518
     958:	00001434 		r0, r0, r2
     95c:	00311300 		r1, r17, r2
     960:	00153400 		r0, r21, r6
     964:	31130206 	addik	r8, r19, 518
     968:	00001634 		r0, r0, r2
     96c:	00311302 		r1, r17, r2
     970:	0a000017 		r16, r0, r0
     974:	1d013113 		r8, r1, r6
     978:	11011201 		r8, r1, r2
     97c:	580b5905 		r0, r11, r11
     980:	0000180b 		r0, r0, r3
     984:	01550600 		r10, r21, r0
     988:	00192e01 		r0, r25, r5
     98c:	3f0c030e 	rsubikc	r24, r12, 782
     990:	3a0b3b05 	addikc	r16, r11, 15109
     994:	270c4913 	rsubi	r24, r12, 18707
     998:	11011201 		r8, r1, r2
     99c:	400a0113 		r0, r10, r0
     9a0:	00001a34 		r0, r0, r3
     9a4:	00030e3a 		r0, r3, r1
     9a8:	0b3b0549 		r25, r27, r0
     9ac:	13020a00 		r24, r2, r1
     9b0:	001b2e01 		r0, r27, r5
     9b4:	3f0c030e 	rsubikc	r24, r12, 782
     9b8:	3a0b3b0b 	addikc	r16, r11, 15115
     9bc:	270c4913 	rsubi	r24, r12, 18707
     9c0:	11011201 		r8, r1, r2
     9c4:	40060113 		r0, r6, r0
     9c8:	00001c05 		r0, r0, r3
     9cc:	00030e3a 		r0, r3, r1
     9d0:	0b3b0b49 		r25, r27, r1
     9d4:	13020600 		r24, r2, r0
     9d8:	001d3400 		r0, r29, r6
     9dc:	03083a0b 		r24, r8, r7
     9e0:	3b0b4913 	addikc	r24, r11, 18707
     9e4:	020a0000 	add	r16, r10, r0
     9e8:	1e2e013f 		r17, r14, r0
     9ec:	0c030e3a 		r0, r3, r1
     9f0:	0b3b0527 		r25, r27, r0
     9f4:	0c491311 		r2, r9, r2
     9f8:	01120140 		r8, r18, r0
     9fc:	06011300 	neg	r16, r1
     a00:	001f2e01 		r0, r31, r5
     a04:	31131101 	addik	r8, r19, 4353
     a08:	1201400a 		r16, r1, r8
     a0c:	01130000 	add	r8, r19, r0
     a10:	20050031 	addi	r0, r5, 49
     a14:	13020a00 		r24, r2, r1
     a18:	00210b01 		r1, r1, r1
     a1c:	11011201 		r8, r1, r2
     a20:	00002234 		r0, r0, r4
     a24:	0003083a 		r0, r3, r1
     a28:	0b3b0549 		r25, r27, r0
     a2c:	13020a00 		r24, r2, r1
     a30:	00230101 		r1, r3, r0
     a34:	49130113 		r8, r19, r0
     a38:	00002421 		r0, r0, r4
     a3c:	0049132f 		r2, r9, r2
     a40:	0b000025 		r24, r0, r0
     a44:	3400030e 	rsubik	r0, r0, 782
     a48:	3a0b3b0b 	addikc	r16, r11, 15115
     a4c:	4913020a 		r8, r19, r0
     a50:	00002626 		r0, r0, r4
     a54:	00491300 		r2, r9, r2
     a58:	00000111 		r0, r0, r0
     a5c:	01250e13 		r9, r5, r1
     a60:	0b030e1b 		r24, r3, r1
     a64:	0e110112 		r16, r17, r0
     a68:	01100600 		r8, r16, r0
     a6c:	00021600 		r0, r2, r2
     a70:	030e3a0b 		r24, r14, r7
     a74:	3b0b4913 	addikc	r24, r11, 18707
     a78:	00000324 		r0, r0, r0
     a7c:	000b0b3e 		r0, r11, r1
     a80:	0b030e00 		r24, r3, r1
     a84:	00042400 		r0, r4, r4
     a88:	0b0b3e0b 		r24, r11, r7
     a8c:	03080000 	add	r24, r8, r0
     a90:	05130103 	neg	r8, r19
     a94:	0e0b0b3a 		r16, r11, r1
     a98:	0b3b0501 		r25, r27, r0
     a9c:	13000006 		r24, r0, r0
     aa0:	0d00030e 		r8, r0, r0
     aa4:	3a0b3b05 	addikc	r16, r11, 15109
     aa8:	4913380a 		r8, r19, r7
     aac:	0000070f 		r0, r0, r0
     ab0:	000b0b00 		r0, r11, r1
     ab4:	00080101 		r0, r8, r0
     ab8:	49130113 		r8, r19, r0
     abc:	00000921 		r0, r0, r1
     ac0:	0049132f 		r2, r9, r2
     ac4:	0b00000a 		r24, r0, r0
     ac8:	0f000b0b 		r24, r0, r1
     acc:	49130000 	idiv	r8, r19, r0
     ad0:	0b160003 		r24, r22, r0
     ad4:	0e3a0b3b 		r17, r26, r1
     ad8:	05491300 	neg	r10, r9
     adc:	000c1501 		r0, r12, r2
     ae0:	270c0113 	rsubi	r24, r12, 275
     ae4:	00000d05 		r0, r0, r1
     ae8:	00491300 		r2, r9, r2
     aec:	000e2e00 		r0, r14, r5
     af0:	030e3a0b 		r24, r14, r7
     af4:	3b05270c 	addikc	r24, r5, 9996
     af8:	200b0000 	addi	r0, r11, 0
     afc:	0f2e0103 		r25, r14, r0
     b00:	0e3a0b3b 		r17, r26, r1
     b04:	05270c20 	neg	r9, r7
     b08:	0b011300 		r24, r1, r2
     b0c:	00103400 		r0, r16, r6
     b10:	03083a0b 		r24, r8, r7
     b14:	3b054913 	addikc	r24, r5, 18707
     b18:	00001134 		r0, r0, r2
     b1c:	00030e3a 		r0, r3, r1
     b20:	0b3b0549 		r25, r27, r0
     b24:	13000012 		r24, r0, r0
     b28:	2e01030e 	rsubic	r16, r1, 782
     b2c:	3a0b3b05 	addikc	r16, r11, 15109
     b30:	270c1101 	rsubi	r24, r12, 4353
     b34:	1201400a 		r16, r1, r8
     b38:	01130000 	add	r8, r19, r0
     b3c:	13340003 		r25, r20, r0
     b40:	083a0b3b 		r1, r26, r1
     b44:	05491302 	neg	r10, r9
     b48:	06000014 	neg	r16, r0
     b4c:	2e013f0c 	rsubic	r16, r1, 16140
     b50:	030e3a0b 		r24, r14, r7
     b54:	3b05270c 	addikc	r24, r5, 9996
     b58:	11011201 		r8, r1, r2
     b5c:	40060113 		r0, r6, r0
     b60:	00001505 		r0, r0, r2
     b64:	00030e3a 		r0, r3, r1
     b68:	0b3b0549 		r25, r27, r0
     b6c:	13020600 		r24, r2, r0
     b70:	00163400 		r0, r22, r6
     b74:	030e3a0b 		r24, r14, r7
     b78:	3b054913 	addikc	r24, r5, 18707
     b7c:	02060000 	add	r16, r6, r0
     b80:	172e013f 		r25, r14, r0
     b84:	0c030e3a 		r0, r3, r1
     b88:	0b3b0b27 		r25, r27, r1
     b8c:	0c110112 		r0, r17, r0
     b90:	01400601 		r10, r0, r0
     b94:	13000018 		r24, r0, r0
     b98:	0500030e 	neg	r8, r0
     b9c:	3a0b3b0b 	addikc	r16, r11, 15115
     ba0:	49130206 		r8, r19, r0
     ba4:	00001934 		r0, r0, r3
     ba8:	00030e3a 		r0, r3, r1
     bac:	0b3b0b49 		r25, r27, r1
     bb0:	13020600 		r24, r2, r0
     bb4:	001a2e00 		r0, r26, r5
     bb8:	3f0c030e 	rsubikc	r24, r12, 782
     bbc:	3a0b3b05 	addikc	r16, r11, 15109
     bc0:	270c1101 	rsubi	r24, r12, 4353
     bc4:	1201400a 		r16, r1, r8
     bc8:	00001b2e 		r0, r0, r3
     bcc:	003f0c03 		r1, r31, r1
     bd0:	0e3a0b3b 		r17, r26, r1
     bd4:	05270c11 	neg	r9, r7
     bd8:	01120140 		r8, r18, r0
     bdc:	0600001c 	neg	r16, r0
     be0:	2e003f0c 	rsubic	r16, r0, 16140
     be4:	030e3a0b 		r24, r14, r7
     be8:	3b05270c 	addikc	r24, r5, 9996
     bec:	49131101 		r8, r19, r2
     bf0:	1201400a 		r16, r1, r8
     bf4:	00001d2e 		r0, r0, r3
     bf8:	013f0c03 		r9, r31, r1
     bfc:	0e3a0b3b 		r17, r26, r1
     c00:	05270c11 	neg	r9, r7
     c04:	01120140 		r8, r18, r0
     c08:	0a011300 		r16, r1, r2
     c0c:	001e3400 		r0, r30, r6
     c10:	03083a0b 		r24, r8, r7
     c14:	3b054913 	addikc	r24, r5, 18707
     c18:	020a0000 	add	r16, r10, r0
     c1c:	1f050003 		r24, r5, r0
     c20:	0e3a0b3b 		r17, r26, r1
     c24:	05491302 	neg	r10, r9
     c28:	0a000020 		r16, r0, r0
     c2c:	2e013f0c 	rsubic	r16, r1, 16140
     c30:	030e3a0b 		r24, r14, r7
     c34:	3b05270c 	addikc	r24, r5, 9996
     c38:	49131101 		r8, r19, r2
     c3c:	12014006 		r16, r1, r8
     c40:	01130000 	add	r8, r19, r0
     c44:	21050003 	addi	r8, r5, 3
     c48:	083a0b3b 		r1, r26, r1
     c4c:	05491302 	neg	r10, r9
     c50:	06000022 	neg	r16, r0
     c54:	1d003113 		r8, r0, r6
     c58:	11011201 		r8, r1, r2
     c5c:	580b5905 		r0, r11, r11
     c60:	0000231d 		r0, r0, r4
     c64:	01311352 		r9, r17, r2
     c68:	01550658 		r10, r21, r0
     c6c:	0b590501 		r26, r25, r0
     c70:	13000024 		r24, r0, r0
     c74:	0b015506 		r24, r1, r10
     c78:	00002534 		r0, r0, r4
     c7c:	00311302 		r1, r17, r2
     c80:	06000026 	neg	r16, r0
     c84:	1d013113 		r8, r1, r6
     c88:	11011201 		r8, r1, r2
     c8c:	580b5905 		r0, r11, r11
     c90:	01130000 	add	r8, r19, r0
     c94:	270b0111 	rsubi	r24, r11, 273
     c98:	01120100 		r8, r18, r0
     c9c:	00283400 		r1, r8, r6
     ca0:	3113020a 	addik	r8, r19, 522
     ca4:	0000291d 		r0, r0, r5
     ca8:	01311311 		r9, r17, r2
     cac:	01120158 		r8, r18, r0
     cb0:	0b590500 		r26, r25, r0
     cb4:	002a2e01 		r1, r10, r5
     cb8:	3f0c030e 	rsubikc	r24, r12, 782
     cbc:	3a0b3b05 	addikc	r16, r11, 15109
     cc0:	270c4913 	rsubi	r24, r12, 18707
     cc4:	11011201 		r8, r1, r2
     cc8:	400a0113 		r0, r10, r0
     ccc:	00002b2e 		r0, r0, r5
     cd0:	013f0c03 		r9, r31, r1
     cd4:	0e3a0b3b 		r17, r26, r1
     cd8:	0b270c49 		r25, r7, r1
     cdc:	13110112 		r24, r17, r0
     ce0:	01400601 		r10, r0, r0
     ce4:	1300002c 		r24, r0, r0
     ce8:	34000308 	rsubik	r0, r0, 776
     cec:	3a0b3b0b 	addikc	r16, r11, 15115
     cf0:	49130206 		r8, r19, r0
     cf4:	00002d34 		r0, r0, r5
     cf8:	00030e3a 		r0, r3, r1
     cfc:	0b3b0549 		r25, r27, r0
     d00:	13020a00 		r24, r2, r1
     d04:	002e0500 		r1, r14, r0
     d08:	03083a0b 		r24, r8, r7
     d0c:	3b054913 	addikc	r24, r5, 18707
     d10:	020a0000 	add	r16, r10, r0
     d14:	2f340003 	rsubic	r25, r20, 3
     d18:	0e3a0b3b 		r17, r26, r1
     d1c:	0549133f 	neg	r10, r9
     d20:	0c3c0c00 		r1, r28, r1
     d24:	00303500 		r1, r16, r6
     d28:	49130000 	idiv	r8, r19, r0
     d2c:	31260049 	addik	r9, r6, 73
     d30:	13000032 		r24, r0, r0
     d34:	3400030e 	rsubik	r0, r0, 782
     d38:	3a0b3b05 	addikc	r16, r11, 15109
     d3c:	49133f0c 		r8, r19, r7
     d40:	020a0000 	add	r16, r10, r0
     d44:	33340003 	addik	r25, r20, 3
     d48:	0e3a0b3b 		r17, r26, r1
     d4c:	0b49133f 		r26, r9, r2
     d50:	0c020a00 		r0, r2, r1
     d54:	00000111 		r0, r0, r0
     d58:	01250e13 		r9, r5, r1
     d5c:	0b030e1b 		r24, r3, r1
     d60:	0e110112 		r16, r17, r0
     d64:	01100600 		r8, r16, r0
     d68:	00021600 		r0, r2, r2
     d6c:	030e3a0b 		r24, r14, r7
     d70:	3b0b4913 	addikc	r24, r11, 18707
     d74:	00000324 		r0, r0, r0
     d78:	000b0b3e 		r0, r11, r1
     d7c:	0b030e00 		r24, r3, r1
     d80:	00042400 		r0, r4, r4
     d84:	0b0b3e0b 		r24, r11, r7
     d88:	03080000 	add	r24, r8, r0
     d8c:	05130103 	neg	r8, r19
     d90:	0e0b0b3a 		r16, r11, r1
     d94:	0b3b0501 		r25, r27, r0
     d98:	13000006 		r24, r0, r0
     d9c:	0d00030e 		r8, r0, r0
     da0:	3a0b3b05 	addikc	r16, r11, 15109
     da4:	4913380a 		r8, r19, r7
     da8:	0000070f 		r0, r0, r0
     dac:	000b0b00 		r0, r11, r1
     db0:	00080101 		r0, r8, r0
     db4:	49130113 		r8, r19, r0
     db8:	00000921 		r0, r0, r1
     dbc:	0049132f 		r2, r9, r2
     dc0:	0b00000a 		r24, r0, r0
     dc4:	0f000b0b 		r24, r0, r1
     dc8:	49130000 	idiv	r8, r19, r0
     dcc:	0b160003 		r24, r22, r0
     dd0:	0e3a0b3b 		r17, r26, r1
     dd4:	05491300 	neg	r10, r9
     dd8:	000c2e01 		r0, r12, r5
     ddc:	030e3a0b 		r24, r14, r7
     de0:	3b05270c 	addikc	r24, r5, 9996
     de4:	200b0113 	addi	r0, r11, 275
     de8:	00000d05 		r0, r0, r1
     dec:	00030e3a 		r0, r3, r1
     df0:	0b3b0549 		r25, r27, r0
     df4:	1300000e 		r24, r0, r0
     df8:	3400030e 	rsubik	r0, r0, 782
     dfc:	3a0b3b05 	addikc	r16, r11, 15109
     e00:	49130000 	idiv	r8, r19, r0
     e04:	0f340003 		r25, r20, r0
     e08:	083a0b3b 		r1, r26, r1
     e0c:	05491300 	neg	r10, r9
     e10:	00102e01 		r0, r16, r5
     e14:	31131101 	addik	r8, r19, 4353
     e18:	1201400a 		r16, r1, r8
     e1c:	01130000 	add	r8, r19, r0
     e20:	11050031 		r8, r5, r0
     e24:	13020600 		r24, r2, r0
     e28:	00120500 		r0, r18, r0
     e2c:	3113020a 	addik	r8, r19, 522
     e30:	00001334 		r0, r0, r2
     e34:	00311302 		r1, r17, r2
     e38:	06000014 	neg	r16, r0
     e3c:	34003113 	rsubik	r0, r0, 12563
     e40:	0000151d 		r0, r0, r2
     e44:	01311311 		r9, r17, r2
     e48:	01120158 		r8, r18, r0
     e4c:	0b590500 		r26, r25, r0
     e50:	00160b01 		r0, r22, r1
     e54:	11011201 		r8, r1, r2
     e58:	00001705 		r0, r0, r2
     e5c:	00311300 		r1, r17, r2
     e60:	00182e01 		r0, r24, r5
     e64:	3f0c030e 	rsubikc	r24, r12, 782
     e68:	3a0b3b0b 	addikc	r16, r11, 15115
     e6c:	270c4913 	rsubi	r24, r12, 18707
     e70:	11011201 		r8, r1, r2
     e74:	40060113 		r0, r6, r0
     e78:	00001905 		r0, r0, r3
     e7c:	00030e3a 		r0, r3, r1
     e80:	0b3b0b49 		r25, r27, r1
     e84:	13020600 		r24, r2, r0
     e88:	001a3400 		r0, r26, r6
     e8c:	030e3a0b 		r24, r14, r7
     e90:	3b0b4913 	addikc	r24, r11, 18707
     e94:	02060000 	add	r16, r6, r0
     e98:	1b2e013f 		r25, r14, r0
     e9c:	0c030e3a 		r0, r3, r1
     ea0:	0b3b0527 		r25, r27, r0
     ea4:	0c491311 		r2, r9, r2
     ea8:	01120140 		r8, r18, r0
     eac:	06011300 	neg	r16, r1
     eb0:	001c0500 		r0, r28, r0
     eb4:	030e3a0b 		r24, r14, r7
     eb8:	3b054913 	addikc	r24, r5, 18707
     ebc:	02060000 	add	r16, r6, r0
     ec0:	1d340003 		r9, r20, r0
     ec4:	083a0b3b 		r1, r26, r1
     ec8:	05491302 	neg	r10, r9
     ecc:	0600001e 	neg	r16, r0
     ed0:	3400030e 	rsubik	r0, r0, 782
     ed4:	3a0b3b05 	addikc	r16, r11, 15109
     ed8:	49130206 		r8, r19, r0
     edc:	00001f2e 		r0, r0, r3
     ee0:	013f0c03 		r9, r31, r1
     ee4:	0e3a0b3b 		r17, r26, r1
     ee8:	05270c11 	neg	r9, r7
     eec:	01120140 		r8, r18, r0
     ef0:	06011300 	neg	r16, r1
     ef4:	00202e01 		r1, r0, r5
     ef8:	3f0c030e 	rsubikc	r24, r12, 782
     efc:	3a0b3b05 	addikc	r16, r11, 15109
     f00:	270c1101 	rsubi	r24, r12, 4353
     f04:	1201400a 		r16, r1, r8
     f08:	01130000 	add	r8, r19, r0
     f0c:	21340003 	addi	r9, r20, 3
     f10:	0e3a0b3b 		r17, r26, r1
     f14:	05491302 	neg	r10, r9
     f18:	0a000022 		r16, r0, r0
     f1c:	2e01030e 	rsubic	r16, r1, 782
     f20:	3a0b3b05 	addikc	r16, r11, 15109
     f24:	270c4913 	rsubi	r24, r12, 18707
     f28:	11011201 		r8, r1, r2
     f2c:	40060113 		r0, r6, r0
     f30:	00002305 		r0, r0, r4
     f34:	0003083a 		r0, r3, r1
     f38:	0b3b0549 		r25, r27, r0
     f3c:	13020600 		r24, r2, r0
     f40:	00243400 		r1, r4, r6
     f44:	030e3a0b 		r24, r14, r7
     f48:	3b054913 	addikc	r24, r5, 18707
     f4c:	3f0c3c0c 	rsubikc	r24, r12, 15372
     f50:	00000001 		r0, r0, r0
     f54:	1101250e 		r8, r1, r4
     f58:	130b030e 		r24, r11, r0
     f5c:	1b0e1101 		r24, r14, r2
     f60:	12011006 		r16, r1, r2
     f64:	00000216 		r0, r0, r0
     f68:	00030e3a 		r0, r3, r1
     f6c:	0b3b0b49 		r25, r27, r1
     f70:	13000003 		r24, r0, r0
     f74:	24000b0b 	rsubi	r0, r0, 2827
     f78:	3e0b030e 	rsubikc	r16, r11, 782
     f7c:	00000424 		r0, r0, r0
     f80:	000b0b3e 		r0, r11, r1
     f84:	0b030800 	addc	r24, r3, r1
     f88:	00051301 		r0, r5, r2
     f8c:	030e0b0b 		r24, r14, r1
     f90:	3a0b3b05 	addikc	r16, r11, 15109
     f94:	01130000 	add	r8, r19, r0
     f98:	060d0003 	neg	r16, r13
     f9c:	0e3a0b3b 		r17, r26, r1
     fa0:	05491338 	neg	r10, r9
     fa4:	0a000007 		r16, r0, r0
     fa8:	0f000b0b 		r24, r0, r1
     fac:	00000801 		r0, r0, r1
     fb0:	01491301 		r10, r9, r2
     fb4:	13000009 		r24, r0, r0
     fb8:	21004913 	addi	r8, r0, 18707
     fbc:	2f0b0000 	rsubic	r24, r11, 0
     fc0:	0a0f000b 		r16, r15, r0
     fc4:	0b491300 		r26, r9, r2
     fc8:	000b1600 		r0, r11, r2
     fcc:	030e3a0b 		r24, r14, r7
     fd0:	3b054913 	addikc	r24, r5, 18707
     fd4:	00000c2e 		r0, r0, r1
     fd8:	013f0c03 		r9, r31, r1
     fdc:	0e3a0b3b 		r17, r26, r1
     fe0:	0b270c49 		r25, r7, r1
     fe4:	13110112 		r24, r17, r0
     fe8:	01400601 		r10, r0, r0
     fec:	1300000d 		r24, r0, r0
     ff0:	0500030e 	neg	r8, r0
     ff4:	3a0b3b0b 	addikc	r16, r11, 15115
     ff8:	49130206 		r8, r19, r0
     ffc:	00000e34 		r0, r0, r1
    1000:	00030e3a 		r0, r3, r1
    1004:	0b3b0b49 		r25, r27, r1
    1008:	13020600 		r24, r2, r0
    100c:	000f0500 		r0, r15, r0
    1010:	03083a0b 		r24, r8, r7
    1014:	3b0b4913 	addikc	r24, r11, 18707
    1018:	02060000 	add	r16, r6, r0
    101c:	102e013f 		r1, r14, r0
    1020:	0c030e3a 		r0, r3, r1
    1024:	0b3b0527 		r25, r27, r0
    1028:	0c491311 		r2, r9, r2
    102c:	01120140 		r8, r18, r0
    1030:	06011300 	neg	r16, r1
    1034:	00110500 		r0, r17, r0
    1038:	030e3a0b 		r24, r14, r7
    103c:	3b054913 	addikc	r24, r5, 18707
    1040:	02060000 	add	r16, r6, r0
    1044:	12340003 		r17, r20, r0
    1048:	0e3a0b3b 		r17, r26, r1
    104c:	05491302 	neg	r10, r9
    1050:	06000013 	neg	r16, r0
    1054:	05000308 	neg	r8, r0
    1058:	3a0b3b05 	addikc	r16, r11, 15109
    105c:	49130206 		r8, r19, r0
    1060:	00001434 		r0, r0, r2
    1064:	0003083a 		r0, r3, r1
    1068:	0b3b0549 		r25, r27, r0
    106c:	13020600 		r24, r2, r0
    1070:	00153400 		r0, r21, r6
    1074:	030e3a0b 		r24, r14, r7
    1078:	3b054913 	addikc	r24, r5, 18707
    107c:	3f0c3c0c 	rsubikc	r24, r12, 15372
    1080:	00000001 		r0, r0, r0
    1084:	1101250e 		r8, r1, r4
    1088:	130b030e 		r24, r11, r0
    108c:	1b0e1101 		r24, r14, r2
    1090:	12011006 		r16, r1, r2
    1094:	00000224 		r0, r0, r0
    1098:	000b0b3e 		r0, r11, r1
    109c:	0b030e00 		r24, r3, r1
    10a0:	00031600 		r0, r3, r2
    10a4:	030e3a0b 		r24, r14, r7
    10a8:	3b0b4913 	addikc	r24, r11, 18707
    10ac:	00000424 		r0, r0, r0
    10b0:	000b0b3e 		r0, r11, r1
    10b4:	0b030800 	addc	r24, r3, r1
    10b8:	00050f00 		r0, r5, r1
    10bc:	0b0b0000 	addc	r24, r11, r0
    10c0:	060f000b 	neg	r16, r15
    10c4:	0b491300 		r26, r9, r2
    10c8:	00071301 		r0, r7, r2
    10cc:	030e0b0b 		r24, r14, r1
    10d0:	3a0b3b05 	addikc	r16, r11, 15109
    10d4:	01130000 	add	r8, r19, r0
    10d8:	080d0003 		r0, r13, r0
    10dc:	0e3a0b3b 		r17, r26, r1
    10e0:	05491338 	neg	r10, r9
    10e4:	0a000009 		r16, r0, r0
    10e8:	1600030e 		r16, r0, r0
    10ec:	3a0b3b05 	addikc	r16, r11, 15109
    10f0:	49130000 	idiv	r8, r19, r0
    10f4:	0a2e013f 		r17, r14, r0
    10f8:	0c030e3a 		r0, r3, r1
    10fc:	0b3b0b27 		r25, r27, r1
    1100:	0c491311 		r2, r9, r2
    1104:	01120140 		r8, r18, r0
    1108:	06011300 	neg	r16, r1
    110c:	000b0500 		r0, r11, r0
    1110:	030e3a0b 		r24, r14, r7
    1114:	3b0b4913 	addikc	r24, r11, 18707
    1118:	02060000 	add	r16, r6, r0
    111c:	0c340003 		r1, r20, r0
    1120:	0e3a0b3b 		r17, r26, r1
    1124:	0b491302 		r26, r9, r2
    1128:	0600000d 	neg	r16, r0
    112c:	34000308 	rsubik	r0, r0, 776
    1130:	3a0b3b0b 	addikc	r16, r11, 15115
    1134:	49130206 		r8, r19, r0
    1138:	00000e2e 		r0, r0, r1
    113c:	013f0c03 		r9, r31, r1
    1140:	0e3a0b3b 		r17, r26, r1
    1144:	05270c11 	neg	r9, r7
    1148:	01120140 		r8, r18, r0
    114c:	06011300 	neg	r16, r1
    1150:	000f0500 		r0, r15, r0
    1154:	030e3a0b 		r24, r14, r7
    1158:	3b054913 	addikc	r24, r5, 18707
    115c:	02060000 	add	r16, r6, r0
    1160:	10340003 		r1, r20, r0
    1164:	0e3a0b3b 		r17, r26, r1
    1168:	05491302 	neg	r10, r9
    116c:	06000011 	neg	r16, r0
    1170:	2e013f0c 	rsubic	r16, r1, 16140
    1174:	030e3a0b 		r24, r14, r7
    1178:	3b05270c 	addikc	r24, r5, 9996
    117c:	49131101 		r8, r19, r2
    1180:	12014006 		r16, r1, r8
    1184:	01130000 	add	r8, r19, r0
    1188:	12340003 		r17, r20, r0
    118c:	0e3a0b3b 		r17, r26, r1
    1190:	05491300 	neg	r10, r9
    1194:	00133400 		r0, r19, r6
    1198:	03083a0b 		r24, r8, r7
    119c:	3b054913 	addikc	r24, r5, 18707
    11a0:	02060000 	add	r16, r6, r0
    11a4:	14340003 	cmpu	r1, r20, r0
    11a8:	0e3a0b3b 		r17, r26, r1
    11ac:	0549133f 	neg	r10, r9
    11b0:	0c3c0c00 		r1, r28, r1
    11b4:	00150101 		r0, r21, r0
    11b8:	49130113 		r8, r19, r0
    11bc:	00001621 		r0, r0, r2
    11c0:	0049132f 		r2, r9, r2
    11c4:	0b000000 	addc	r24, r0, r0
    11c8:	01110125 		r8, r17, r0
    11cc:	0e130b03 		r16, r19, r1
    11d0:	0e1b0e11 		r16, r27, r1
    11d4:	01120110 		r8, r18, r0
    11d8:	06000002 	neg	r16, r0
    11dc:	1600030e 		r16, r0, r0
    11e0:	3a0b3b0b 	addikc	r16, r11, 15115
    11e4:	49130000 	idiv	r8, r19, r0
    11e8:	0324000b 		r25, r4, r0
    11ec:	0b3e0b03 		r25, r30, r1
    11f0:	0e000004 		r16, r0, r0
    11f4:	24000b0b 	rsubi	r0, r0, 2827
    11f8:	3e0b0308 	rsubikc	r16, r11, 776
    11fc:	00000513 		r0, r0, r0
    1200:	01030e0b 		r8, r3, r1
    1204:	0b3a0b3b 		r25, r26, r1
    1208:	05011300 	neg	r8, r1
    120c:	00060d00 		r0, r6, r1
    1210:	030e3a0b 		r24, r14, r7
    1214:	3b054913 	addikc	r24, r5, 18707
    1218:	380a0000 	addikc	r0, r10, 0
    121c:	070f000b 	neg	r24, r15
    1220:	0b000008 		r24, r0, r0
    1224:	01014913 		r8, r1, r9
    1228:	01130000 	add	r8, r19, r0
    122c:	09210049 		r9, r1, r0
    1230:	132f0b00 		r25, r15, r1
    1234:	000a0f00 		r0, r10, r1
    1238:	0b0b4913 		r24, r11, r9
    123c:	00000b16 		r0, r0, r1
    1240:	00030e3a 		r0, r3, r1
    1244:	0b3b0549 		r25, r27, r0
    1248:	1300000c 		r24, r0, r0
    124c:	2e01030e 	rsubic	r16, r1, 782
    1250:	3a0b3b05 	addikc	r16, r11, 15109
    1254:	270c1101 	rsubi	r24, r12, 4353
    1258:	1201400a 		r16, r1, r8
    125c:	01130000 	add	r8, r19, r0
    1260:	0d050003 		r8, r5, r0
    1264:	0e3a0b3b 		r17, r26, r1
    1268:	05491302 	neg	r10, r9
    126c:	0a00000e 		r16, r0, r0
    1270:	0500030e 	neg	r8, r0
    1274:	3a0b3b05 	addikc	r16, r11, 15109
    1278:	49130206 		r8, r19, r0
    127c:	00000f34 		r0, r0, r1
    1280:	0003083a 		r0, r3, r1
    1284:	0b3b0549 		r25, r27, r0
    1288:	13020a00 		r24, r2, r1
    128c:	00102e01 		r0, r16, r5
    1290:	3f0c030e 	rsubikc	r24, r12, 782
    1294:	3a0b3b0b 	addikc	r16, r11, 15115
    1298:	270c4913 	rsubi	r24, r12, 18707
    129c:	11011201 		r8, r1, r2
    12a0:	40060113 		r0, r6, r0
    12a4:	00001105 		r0, r0, r2
    12a8:	00030e3a 		r0, r3, r1
    12ac:	0b3b0b49 		r25, r27, r1
    12b0:	13020600 		r24, r2, r0
    12b4:	00123400 		r0, r18, r6
    12b8:	03083a0b 		r24, r8, r7
    12bc:	3b0b4913 	addikc	r24, r11, 18707
    12c0:	00001334 		r0, r0, r2
    12c4:	00030e3a 		r0, r3, r1
    12c8:	0b3b0b49 		r25, r27, r1
    12cc:	13020600 		r24, r2, r0
    12d0:	00142e01 		r0, r20, r5
    12d4:	3f0c030e 	rsubikc	r24, r12, 782
    12d8:	3a0b3b05 	addikc	r16, r11, 15109
    12dc:	270c4913 	rsubi	r24, r12, 18707
    12e0:	11011201 		r8, r1, r2
    12e4:	40060113 		r0, r6, r0
    12e8:	00001505 		r0, r0, r2
    12ec:	0003083a 		r0, r3, r1
    12f0:	0b3b0549 		r25, r27, r0
    12f4:	13020600 		r24, r2, r0
    12f8:	00163400 		r0, r22, r6
    12fc:	030e3a0b 		r24, r14, r7
    1300:	3b054913 	addikc	r24, r5, 18707
    1304:	02060000 	add	r16, r6, r0
    1308:	17340003 	cmpu	r25, r20, r0
    130c:	083a0b3b 		r1, r26, r1
    1310:	05491302 	neg	r10, r9
    1314:	06000018 	neg	r16, r0
    1318:	2e013f0c 	rsubic	r16, r1, 16140
    131c:	030e3a0b 		r24, r14, r7
    1320:	3b05270c 	addikc	r24, r5, 9996
    1324:	11011201 		r8, r1, r2
    1328:	40060113 		r0, r6, r0
    132c:	00001934 		r0, r0, r3
    1330:	00030e3a 		r0, r3, r1
    1334:	0b3b0549 		r25, r27, r0
    1338:	1300001a 		r24, r0, r0
    133c:	34000308 	rsubik	r0, r0, 776
    1340:	3a0b3b05 	addikc	r16, r11, 15109
    1344:	49130000 	idiv	r8, r19, r0
    1348:	1b340003 		r25, r20, r0
    134c:	0e3a0b3b 		r17, r26, r1
    1350:	0549133f 	neg	r10, r9
    1354:	0c3c0c00 		r1, r28, r1
    1358:	00000111 		r0, r0, r0
    135c:	01250e13 		r9, r5, r1
    1360:	0b030e1b 		r24, r3, r1
    1364:	0e110112 		r16, r17, r0
    1368:	01100600 		r8, r16, r0
    136c:	00021600 		r0, r2, r2
    1370:	030e3a0b 		r24, r14, r7
    1374:	3b0b4913 	addikc	r24, r11, 18707
    1378:	00000324 		r0, r0, r0
    137c:	000b0b3e 		r0, r11, r1
    1380:	0b030e00 		r24, r3, r1
    1384:	00042400 		r0, r4, r4
    1388:	0b0b3e0b 		r24, r11, r7
    138c:	03080000 	add	r24, r8, r0
    1390:	05130103 	neg	r8, r19
    1394:	0e0b0b3a 		r16, r11, r1
    1398:	0b3b0501 		r25, r27, r0
    139c:	13000006 		r24, r0, r0
    13a0:	0d00030e 		r8, r0, r0
    13a4:	3a0b3b05 	addikc	r16, r11, 15109
    13a8:	4913380a 		r8, r19, r7
    13ac:	0000070f 		r0, r0, r0
    13b0:	000b0b00 		r0, r11, r1
    13b4:	00080101 		r0, r8, r0
    13b8:	49130113 		r8, r19, r0
    13bc:	00000921 		r0, r0, r1
    13c0:	0049132f 		r2, r9, r2
    13c4:	0b00000a 		r24, r0, r0
    13c8:	0f000b0b 		r24, r0, r1
    13cc:	49130000 	idiv	r8, r19, r0
    13d0:	0b160003 		r24, r22, r0
    13d4:	0e3a0b3b 		r17, r26, r1
    13d8:	05491300 	neg	r10, r9
    13dc:	000c2e01 		r0, r12, r5
    13e0:	3f0c030e 	rsubikc	r24, r12, 782
    13e4:	3a0b3b0b 	addikc	r16, r11, 15115
    13e8:	270c4913 	rsubi	r24, r12, 18707
    13ec:	11011201 		r8, r1, r2
    13f0:	40060113 		r0, r6, r0
    13f4:	00000d05 		r0, r0, r1
    13f8:	00030e3a 		r0, r3, r1
    13fc:	0b3b0b49 		r25, r27, r1
    1400:	13020600 		r24, r2, r0
    1404:	000e3400 		r0, r14, r6
    1408:	030e3a0b 		r24, r14, r7
    140c:	3b0b4913 	addikc	r24, r11, 18707
    1410:	02060000 	add	r16, r6, r0
    1414:	0f340003 		r25, r20, r0
    1418:	083a0b3b 		r1, r26, r1
    141c:	0b491302 		r26, r9, r2
    1420:	06000010 	neg	r16, r0
    1424:	05000308 	neg	r8, r0
    1428:	3a0b3b0b 	addikc	r16, r11, 15115
    142c:	49130206 		r8, r19, r0
    1430:	0000112e 		r0, r0, r2
    1434:	013f0c03 		r9, r31, r1
    1438:	0e3a0b3b 		r17, r26, r1
    143c:	05270c49 	neg	r9, r7
    1440:	13110112 		r24, r17, r0
    1444:	01400601 		r10, r0, r0
    1448:	13000012 		r24, r0, r0
    144c:	0500030e 	neg	r8, r0
    1450:	3a0b3b05 	addikc	r16, r11, 15109
    1454:	49130206 		r8, r19, r0
    1458:	00001334 		r0, r0, r2
    145c:	0003083a 		r0, r3, r1
    1460:	0b3b0549 		r25, r27, r0
    1464:	13020600 		r24, r2, r0
    1468:	00143400 		r0, r20, r6
    146c:	030e3a0b 		r24, r14, r7
    1470:	3b054913 	addikc	r24, r5, 18707
    1474:	02060000 	add	r16, r6, r0
    1478:	15050003 	cmpu	r8, r5, r0
    147c:	083a0b3b 		r1, r26, r1
    1480:	05491302 	neg	r10, r9
    1484:	06000016 	neg	r16, r0
    1488:	2e013f0c 	rsubic	r16, r1, 16140
    148c:	030e3a0b 		r24, r14, r7
    1490:	3b05270c 	addikc	r24, r5, 9996
    1494:	11011201 		r8, r1, r2
    1498:	40060113 		r0, r6, r0
    149c:	00001734 		r0, r0, r2
    14a0:	0003083a 		r0, r3, r1
    14a4:	0b3b0549 		r25, r27, r0
    14a8:	13000018 		r24, r0, r0
    14ac:	3400030e 	rsubik	r0, r0, 782
    14b0:	3a0b3b05 	addikc	r16, r11, 15109
    14b4:	49133f0c 		r8, r19, r7
    14b8:	3c0c0000 	rsubikc	r0, r12, 0
    14bc:	00011101 		r0, r1, r2
    14c0:	250e130b 	rsubi	r8, r14, 4875
    14c4:	030e1b0e 		r24, r14, r3
    14c8:	11011201 		r8, r1, r2
    14cc:	10060000 	addk	r0, r6, r0
    14d0:	02160003 		r16, r22, r0
    14d4:	0e3a0b3b 		r17, r26, r1
    14d8:	0b491300 		r26, r9, r2
    14dc:	00032400 		r0, r3, r4
    14e0:	0b0b3e0b 		r24, r11, r7
    14e4:	030e0000 	add	r24, r14, r0
    14e8:	0424000b 	neg	r1, r4
    14ec:	0b3e0b03 		r25, r30, r1
    14f0:	08000005 		r0, r0, r0
    14f4:	1301030e 		r24, r1, r0
    14f8:	0b0b3a0b 		r24, r11, r7
    14fc:	3b050113 	addikc	r24, r5, 275
    1500:	0000060d 		r0, r0, r0
    1504:	00030e3a 		r0, r3, r1
    1508:	0b3b0549 		r25, r27, r0
    150c:	13380a00 		r25, r24, r1
    1510:	00070f00 		r0, r7, r1
    1514:	0b0b0000 	addc	r24, r11, r0
    1518:	08010149 		r0, r1, r0
    151c:	13011300 		r24, r1, r2
    1520:	00092100 		r0, r9, r4
    1524:	49132f0b 		r8, r19, r5
    1528:	00000a0f 		r0, r0, r1
    152c:	000b0b49 		r0, r11, r1
    1530:	1300000b 		r24, r0, r0
    1534:	1600030e 		r16, r0, r0
    1538:	3a0b3b05 	addikc	r16, r11, 15109
    153c:	49130000 	idiv	r8, r19, r0
    1540:	0c2e013f 		r1, r14, r0
    1544:	0c030e3a 		r0, r3, r1
    1548:	0b3b0b27 		r25, r27, r1
    154c:	0c491311 		r2, r9, r2
    1550:	01120140 		r8, r18, r0
    1554:	06011300 	neg	r16, r1
    1558:	000d0500 		r0, r13, r0
    155c:	030e3a0b 		r24, r14, r7
    1560:	3b0b4913 	addikc	r24, r11, 18707
    1564:	02060000 	add	r16, r6, r0
    1568:	0e340003 		r17, r20, r0
    156c:	083a0b3b 		r1, r26, r1
    1570:	0b491302 		r26, r9, r2
    1574:	0600000f 	neg	r16, r0
    1578:	3400030e 	rsubik	r0, r0, 782
    157c:	3a0b3b0b 	addikc	r16, r11, 15115
    1580:	49130206 		r8, r19, r0
    1584:	00001005 		r0, r0, r2
    1588:	0003083a 		r0, r3, r1
    158c:	0b3b0b49 		r25, r27, r1
    1590:	13020600 		r24, r2, r0
    1594:	00112e01 		r0, r17, r5
    1598:	3f0c030e 	rsubikc	r24, r12, 782
    159c:	3a0b3b05 	addikc	r16, r11, 15109
    15a0:	270c1101 	rsubi	r24, r12, 4353
    15a4:	12014006 		r16, r1, r8
    15a8:	01130000 	add	r8, r19, r0
    15ac:	12050003 		r16, r5, r0
    15b0:	0e3a0b3b 		r17, r26, r1
    15b4:	05491302 	neg	r10, r9
    15b8:	06000013 	neg	r16, r0
    15bc:	3400030e 	rsubik	r0, r0, 782
    15c0:	3a0b3b05 	addikc	r16, r11, 15109
    15c4:	49130206 		r8, r19, r0
    15c8:	0000142e 		r0, r0, r2
    15cc:	013f0c03 		r9, r31, r1
    15d0:	0e3a0b3b 		r17, r26, r1
    15d4:	05270c49 	neg	r9, r7
    15d8:	13110112 		r24, r17, r0
    15dc:	01400601 		r10, r0, r0
    15e0:	13000015 		r24, r0, r0
    15e4:	05000308 	neg	r8, r0
    15e8:	3a0b3b05 	addikc	r16, r11, 15109
    15ec:	49130206 		r8, r19, r0
    15f0:	00001634 		r0, r0, r2
    15f4:	0003083a 		r0, r3, r1
    15f8:	0b3b0549 		r25, r27, r0
    15fc:	13020600 		r24, r2, r0
    1600:	00173400 		r0, r23, r6
    1604:	030e3a0b 		r24, r14, r7
    1608:	3b054913 	addikc	r24, r5, 18707
    160c:	3f0c3c0c 	rsubikc	r24, r12, 15372
    1610:	00000001 		r0, r0, r0
    1614:	1101250e 		r8, r1, r4
    1618:	130b030e 		r24, r11, r0
    161c:	1b0e1101 		r24, r14, r2
    1620:	12011006 		r16, r1, r2
    1624:	00000216 		r0, r0, r0
    1628:	00030e3a 		r0, r3, r1
    162c:	0b3b0b49 		r25, r27, r1
    1630:	13000003 		r24, r0, r0
    1634:	24000b0b 	rsubi	r0, r0, 2827
    1638:	3e0b030e 	rsubikc	r16, r11, 782
    163c:	00000424 		r0, r0, r0
    1640:	000b0b3e 		r0, r11, r1
    1644:	0b030800 	addc	r24, r3, r1
    1648:	00051301 		r0, r5, r2
    164c:	030e0b0b 		r24, r14, r1
    1650:	3a0b3b05 	addikc	r16, r11, 15109
    1654:	01130000 	add	r8, r19, r0
    1658:	060d0003 	neg	r16, r13
    165c:	0e3a0b3b 		r17, r26, r1
    1660:	05491338 	neg	r10, r9
    1664:	0a000007 		r16, r0, r0
    1668:	0f000b0b 		r24, r0, r1
    166c:	00000801 		r0, r0, r1
    1670:	01491301 		r10, r9, r2
    1674:	13000009 		r24, r0, r0
    1678:	21004913 	addi	r8, r0, 18707
    167c:	2f0b0000 	rsubic	r24, r11, 0
    1680:	0a0f000b 		r16, r15, r0
    1684:	0b491300 		r26, r9, r2
    1688:	000b1600 		r0, r11, r2
    168c:	030e3a0b 		r24, r14, r7
    1690:	3b054913 	addikc	r24, r5, 18707
    1694:	00000c2e 		r0, r0, r1
    1698:	013f0c03 		r9, r31, r1
    169c:	0e3a0b3b 		r17, r26, r1
    16a0:	0b270c49 		r25, r7, r1
    16a4:	13110112 		r24, r17, r0
    16a8:	01400601 		r10, r0, r0
    16ac:	1300000d 		r24, r0, r0
    16b0:	0500030e 	neg	r8, r0
    16b4:	3a0b3b0b 	addikc	r16, r11, 15115
    16b8:	49130206 		r8, r19, r0
    16bc:	00000e34 		r0, r0, r1
    16c0:	00030e3a 		r0, r3, r1
    16c4:	0b3b0b49 		r25, r27, r1
    16c8:	13020600 		r24, r2, r0
    16cc:	000f3400 		r0, r15, r6
    16d0:	03083a0b 		r24, r8, r7
    16d4:	3b0b4913 	addikc	r24, r11, 18707
    16d8:	02060000 	add	r16, r6, r0
    16dc:	10150127 		r0, r21, r0
    16e0:	0c011300 		r0, r1, r2
    16e4:	00110500 		r0, r17, r0
    16e8:	49130000 	idiv	r8, r19, r0
    16ec:	122e013f 		r17, r14, r0
    16f0:	0c030e3a 		r0, r3, r1
    16f4:	0b3b0527 		r25, r27, r0
    16f8:	0c491311 		r2, r9, r2
    16fc:	01120140 		r8, r18, r0
    1700:	06011300 	neg	r16, r1
    1704:	00130500 		r0, r19, r0
    1708:	030e3a0b 		r24, r14, r7
    170c:	3b054913 	addikc	r24, r5, 18707
    1710:	02060000 	add	r16, r6, r0
    1714:	14340003 	cmpu	r1, r20, r0
    1718:	0e3a0b3b 		r17, r26, r1
    171c:	05491302 	neg	r10, r9
    1720:	06000015 	neg	r16, r0
    1724:	34000308 	rsubik	r0, r0, 776
    1728:	3a0b3b05 	addikc	r16, r11, 15109
    172c:	49130206 		r8, r19, r0
    1730:	0000162e 		r0, r0, r2
    1734:	013f0c03 		r9, r31, r1
    1738:	0e3a0b3b 		r17, r26, r1
    173c:	05270c11 	neg	r9, r7
    1740:	01120140 		r8, r18, r0
    1744:	06011300 	neg	r16, r1
    1748:	00170500 		r0, r23, r0
    174c:	03083a0b 		r24, r8, r7
    1750:	3b054913 	addikc	r24, r5, 18707
    1754:	02060000 	add	r16, r6, r0
    1758:	182e003f 		r1, r14, r0
    175c:	0c030e3a 		r0, r3, r1
    1760:	0b3b0527 		r25, r27, r0
    1764:	0c110112 		r0, r17, r0
    1768:	01400600 		r10, r0, r0
    176c:	00192e01 		r0, r25, r5
    1770:	3f0c030e 	rsubikc	r24, r12, 782
    1774:	3a0b3b05 	addikc	r16, r11, 15109
    1778:	270c1101 	rsubi	r24, r12, 4353
    177c:	1201400a 		r16, r1, r8
    1780:	01130000 	add	r8, r19, r0
    1784:	1a050003 		r16, r5, r0
    1788:	0e3a0b3b 		r17, r26, r1
    178c:	05491302 	neg	r10, r9
    1790:	0a00001b 		r16, r0, r0
    1794:	05000308 	neg	r8, r0
    1798:	3a0b3b05 	addikc	r16, r11, 15109
    179c:	4913020a 		r8, r19, r0
    17a0:	00001c34 		r0, r0, r3
    17a4:	00030e3a 		r0, r3, r1
    17a8:	0b3b0549 		r25, r27, r0
    17ac:	133f0c3c 		r25, r31, r1
    17b0:	0c000000 	rsubc	r0, r0, r0
    17b4:	01110125 		r8, r17, r0
    17b8:	0e130b03 		r16, r19, r1
    17bc:	0e1b0e11 		r16, r27, r1
    17c0:	01120110 		r8, r18, r0
    17c4:	06000002 	neg	r16, r0
    17c8:	24000b0b 	rsubi	r0, r0, 2827
    17cc:	3e0b030e 	rsubikc	r16, r11, 782
    17d0:	00000316 		r0, r0, r0
    17d4:	00030e3a 		r0, r3, r1
    17d8:	0b3b0b49 		r25, r27, r1
    17dc:	13000004 		r24, r0, r0
    17e0:	24000b0b 	rsubi	r0, r0, 2827
    17e4:	3e0b0308 	rsubikc	r16, r11, 776
    17e8:	00000513 		r0, r0, r0
    17ec:	01030e0b 		r8, r3, r1
    17f0:	0b3a0b3b 		r25, r26, r1
    17f4:	05011300 	neg	r8, r1
    17f8:	00060d00 		r0, r6, r1
    17fc:	030e3a0b 		r24, r14, r7
    1800:	3b054913 	addikc	r24, r5, 18707
    1804:	380a0000 	addikc	r0, r10, 0
    1808:	070f000b 	neg	r24, r15
    180c:	0b000008 		r24, r0, r0
    1810:	01014913 		r8, r1, r9
    1814:	01130000 	add	r8, r19, r0
    1818:	09210049 		r9, r1, r0
    181c:	132f0b00 		r25, r15, r1
    1820:	000a0f00 		r0, r10, r1
    1824:	0b0b4913 		r24, r11, r9
    1828:	00000b16 		r0, r0, r1
    182c:	00030e3a 		r0, r3, r1
    1830:	0b3b0549 		r25, r27, r0
    1834:	1300000c 		r24, r0, r0
    1838:	2e013f0c 	rsubic	r16, r1, 16140
    183c:	030e3a0b 		r24, r14, r7
    1840:	3b0b270c 	addikc	r24, r11, 9996
    1844:	11011201 		r8, r1, r2
    1848:	40060113 		r0, r6, r0
    184c:	00000d05 		r0, r0, r1
    1850:	00030e3a 		r0, r3, r1
    1854:	0b3b0b49 		r25, r27, r1
    1858:	13020600 		r24, r2, r0
    185c:	000e3400 		r0, r14, r6
    1860:	03083a0b 		r24, r8, r7
    1864:	3b0b4913 	addikc	r24, r11, 18707
    1868:	00000f34 		r0, r0, r1
    186c:	00030e3a 		r0, r3, r1
    1870:	0b3b0b49 		r25, r27, r1
    1874:	13020600 		r24, r2, r0
    1878:	00102e01 		r0, r16, r5
    187c:	3f0c030e 	rsubikc	r24, r12, 782
    1880:	3a0b3b0b 	addikc	r16, r11, 15115
    1884:	270c4913 	rsubi	r24, r12, 18707
    1888:	11011201 		r8, r1, r2
    188c:	40060113 		r0, r6, r0
    1890:	00001105 		r0, r0, r2
    1894:	0003083a 		r0, r3, r1
    1898:	0b3b0b49 		r25, r27, r1
    189c:	13020600 		r24, r2, r0
    18a0:	00123400 		r0, r18, r6
    18a4:	030e3a0b 		r24, r14, r7
    18a8:	3b054913 	addikc	r24, r5, 18707
    18ac:	3f0c3c0c 	rsubikc	r24, r12, 15372
    18b0:	00001335 		r0, r0, r2
    18b4:	00491300 		r2, r9, r2
    18b8:	00000111 		r0, r0, r0
    18bc:	01250e13 		r9, r5, r1
    18c0:	0b030e1b 		r24, r3, r1
    18c4:	0e110112 		r16, r17, r0
    18c8:	01100600 		r8, r16, r0
    18cc:	00021600 		r0, r2, r2
    18d0:	030e3a0b 		r24, r14, r7
    18d4:	3b0b4913 	addikc	r24, r11, 18707
    18d8:	00000324 		r0, r0, r0
    18dc:	000b0b3e 		r0, r11, r1
    18e0:	0b030e00 		r24, r3, r1
    18e4:	00042400 		r0, r4, r4
    18e8:	0b0b3e0b 		r24, r11, r7
    18ec:	03080000 	add	r24, r8, r0
    18f0:	05130103 	neg	r8, r19
    18f4:	0e0b0b3a 		r16, r11, r1
    18f8:	0b3b0501 		r25, r27, r0
    18fc:	13000006 		r24, r0, r0
    1900:	0d00030e 		r8, r0, r0
    1904:	3a0b3b05 	addikc	r16, r11, 15109
    1908:	4913380a 		r8, r19, r7
    190c:	0000070f 		r0, r0, r0
    1910:	000b0b00 		r0, r11, r1
    1914:	00080101 		r0, r8, r0
    1918:	49130113 		r8, r19, r0
    191c:	00000921 		r0, r0, r1
    1920:	0049132f 		r2, r9, r2
    1924:	0b00000a 		r24, r0, r0
    1928:	0f000b0b 		r24, r0, r1
    192c:	49130000 	idiv	r8, r19, r0
    1930:	0b160003 		r24, r22, r0
    1934:	0e3a0b3b 		r17, r26, r1
    1938:	05491300 	neg	r10, r9
    193c:	000c1501 		r0, r12, r2
    1940:	270c0113 	rsubi	r24, r12, 275
    1944:	00000d05 		r0, r0, r1
    1948:	00491300 		r2, r9, r2
    194c:	000e2e01 		r0, r14, r5
    1950:	030e3a0b 		r24, r14, r7
    1954:	3b05270c 	addikc	r24, r5, 9996
    1958:	4913200b 		r8, r19, r4
    195c:	01130000 	add	r8, r19, r0
    1960:	0f340003 		r25, r20, r0
    1964:	0e3a0b3b 		r17, r26, r1
    1968:	05491300 	neg	r10, r9
    196c:	00102e01 		r0, r16, r5
    1970:	030e3a0b 		r24, r14, r7
    1974:	3b05270c 	addikc	r24, r5, 9996
    1978:	200b0113 	addi	r0, r11, 275
    197c:	00001105 		r0, r0, r2
    1980:	00030e3a 		r0, r3, r1
    1984:	0b3b0549 		r25, r27, r0
    1988:	13000012 		r24, r0, r0
    198c:	34000308 	rsubik	r0, r0, 776
    1990:	3a0b3b05 	addikc	r16, r11, 15109
    1994:	49130000 	idiv	r8, r19, r0
    1998:	132e0103 		r25, r14, r0
    199c:	0e3a0b3b 		r17, r26, r1
    19a0:	05270c11 	neg	r9, r7
    19a4:	01120140 		r8, r18, r0
    19a8:	0a011300 		r16, r1, r2
    19ac:	00140500 		r0, r20, r0
    19b0:	030e3a0b 		r24, r14, r7
    19b4:	3b054913 	addikc	r24, r5, 18707
    19b8:	020a0000 	add	r16, r10, r0
    19bc:	15050003 	cmpu	r8, r5, r0
    19c0:	0e3a0b3b 		r17, r26, r1
    19c4:	05491302 	neg	r10, r9
    19c8:	06000016 	neg	r16, r0
    19cc:	3400030e 	rsubik	r0, r0, 782
    19d0:	3a0b3b05 	addikc	r16, r11, 15109
    19d4:	49130206 		r8, r19, r0
    19d8:	00001734 		r0, r0, r2
    19dc:	00030e3a 		r0, r3, r1
    19e0:	0b3b0549 		r25, r27, r0
    19e4:	13020a00 		r24, r2, r1
    19e8:	00182e01 		r0, r24, r5
    19ec:	030e3a0b 		r24, r14, r7
    19f0:	3b05270c 	addikc	r24, r5, 9996
    19f4:	11011201 		r8, r1, r2
    19f8:	40060113 		r0, r6, r0
    19fc:	00001934 		r0, r0, r3
    1a00:	0003083a 		r0, r3, r1
    1a04:	0b3b0549 		r25, r27, r0
    1a08:	13020a00 		r24, r2, r1
    1a0c:	001a2e01 		r0, r26, r5
    1a10:	3f0c030e 	rsubikc	r24, r12, 782
    1a14:	3a0b3b0b 	addikc	r16, r11, 15115
    1a18:	270c4913 	rsubi	r24, r12, 18707
    1a1c:	11011201 		r8, r1, r2
    1a20:	40060113 		r0, r6, r0
    1a24:	00001b05 		r0, r0, r3
    1a28:	0003083a 		r0, r3, r1
    1a2c:	0b3b0b49 		r25, r27, r1
    1a30:	13020600 		r24, r2, r0
    1a34:	001c0500 		r0, r28, r0
    1a38:	030e3a0b 		r24, r14, r7
    1a3c:	3b0b4913 	addikc	r24, r11, 18707
    1a40:	02060000 	add	r16, r6, r0
    1a44:	1d050003 		r8, r5, r0
    1a48:	0e3a0b3b 		r17, r26, r1
    1a4c:	0b491302 		r26, r9, r2
    1a50:	0a00001e 		r16, r0, r0
    1a54:	3400030e 	rsubik	r0, r0, 782
    1a58:	3a0b3b0b 	addikc	r16, r11, 15115
    1a5c:	4913020a 		r8, r19, r0
    1a60:	00001f1d 		r0, r0, r3
    1a64:	01311352 		r9, r17, r2
    1a68:	01550658 		r10, r21, r0
    1a6c:	0b590b00 		r26, r25, r1
    1a70:	00200b01 		r1, r0, r1
    1a74:	55060000 		r8, r6, r0
    1a78:	21340031 	addi	r9, r20, 49
    1a7c:	13020600 		r24, r2, r0
    1a80:	00221d01 		r1, r2, r3
    1a84:	31131101 	addik	r8, r19, 4353
    1a88:	1201580b 		r16, r1, r11
    1a8c:	590b0113 		r8, r11, r0
    1a90:	00002305 		r0, r0, r4
    1a94:	00311302 		r1, r17, r2
    1a98:	06000024 	neg	r16, r0
    1a9c:	1d013113 		r8, r1, r6
    1aa0:	11011201 		r8, r1, r2
    1aa4:	580b590b 		r0, r11, r11
    1aa8:	0000252e 		r0, r0, r4
    1aac:	013f0c03 		r9, r31, r1
    1ab0:	0e3a0b3b 		r17, r26, r1
    1ab4:	05270c49 	neg	r9, r7
    1ab8:	13110112 		r24, r17, r0
    1abc:	01400601 		r10, r0, r0
    1ac0:	13000026 		r24, r0, r0
    1ac4:	34000308 	rsubik	r0, r0, 776
    1ac8:	3a0b3b05 	addikc	r16, r11, 15109
    1acc:	49130206 		r8, r19, r0
    1ad0:	00002705 		r0, r0, r4
    1ad4:	0003083a 		r0, r3, r1
    1ad8:	0b3b0549 		r25, r27, r0
    1adc:	13020600 		r24, r2, r0
    1ae0:	00282e01 		r1, r8, r5
    1ae4:	3f0c030e 	rsubikc	r24, r12, 782
    1ae8:	3a0b3b05 	addikc	r16, r11, 15109
    1aec:	270c1101 	rsubi	r24, r12, 4353
    1af0:	12014006 		r16, r1, r8
    1af4:	01130000 	add	r8, r19, r0
    1af8:	291d0131 	addic	r8, r29, 305
    1afc:	13110112 		r24, r17, r0
    1b00:	01580b59 		r10, r24, r1
    1b04:	0500002a 	neg	r8, r0
    1b08:	0b011101 		r24, r1, r2
    1b0c:	12010000 	addk	r16, r1, r0
    1b10:	2b340031 	addic	r25, r20, 49
    1b14:	13020a00 		r24, r2, r1
    1b18:	002c3400 		r1, r12, r6
    1b1c:	030e3a0b 		r24, r14, r7
    1b20:	3b054913 	addikc	r24, r5, 18707
    1b24:	3f0c3c0c 	rsubikc	r24, r12, 15372
    1b28:	00000001 		r0, r0, r0
    1b2c:	1101250e 		r8, r1, r4
    1b30:	130b030e 		r24, r11, r0
    1b34:	1b0e1101 		r24, r14, r2
    1b38:	12011006 		r16, r1, r2
    1b3c:	00000224 		r0, r0, r0
    1b40:	000b0b3e 		r0, r11, r1
    1b44:	0b030e00 		r24, r3, r1
    1b48:	00031600 		r0, r3, r2
    1b4c:	030e3a0b 		r24, r14, r7
    1b50:	3b0b4913 	addikc	r24, r11, 18707
    1b54:	00000424 		r0, r0, r0
    1b58:	000b0b3e 		r0, r11, r1
    1b5c:	0b030800 	addc	r24, r3, r1
    1b60:	00051301 		r0, r5, r2
    1b64:	030e0b0b 		r24, r14, r1
    1b68:	3a0b3b05 	addikc	r16, r11, 15109
    1b6c:	01130000 	add	r8, r19, r0
    1b70:	060d0003 	neg	r16, r13
    1b74:	0e3a0b3b 		r17, r26, r1
    1b78:	05491338 	neg	r10, r9
    1b7c:	0a000007 		r16, r0, r0
    1b80:	0f000b0b 		r24, r0, r1
    1b84:	00000801 		r0, r0, r1
    1b88:	01491301 		r10, r9, r2
    1b8c:	13000009 		r24, r0, r0
    1b90:	21004913 	addi	r8, r0, 18707
    1b94:	2f0b0000 	rsubic	r24, r11, 0
    1b98:	0a0f000b 		r16, r15, r0
    1b9c:	0b491300 		r26, r9, r2
    1ba0:	000b1600 		r0, r11, r2
    1ba4:	030e3a0b 		r24, r14, r7
    1ba8:	3b054913 	addikc	r24, r5, 18707
    1bac:	00000c2e 		r0, r0, r1
    1bb0:	003f0c03 		r1, r31, r1
    1bb4:	0e3a0b3b 		r17, r26, r1
    1bb8:	0b270c11 		r25, r7, r1
    1bbc:	01120140 		r8, r18, r0
    1bc0:	0a00000d 		r16, r0, r0
    1bc4:	2e013f0c 	rsubic	r16, r1, 16140
    1bc8:	030e3a0b 		r24, r14, r7
    1bcc:	3b0b270c 	addikc	r24, r11, 9996
    1bd0:	11011201 		r8, r1, r2
    1bd4:	400a0113 		r0, r10, r0
    1bd8:	00000e05 		r0, r0, r1
    1bdc:	00030e3a 		r0, r3, r1
    1be0:	0b3b0b49 		r25, r27, r1
    1be4:	13020a00 		r24, r2, r1
    1be8:	000f0500 		r0, r15, r0
    1bec:	030e3a0b 		r24, r14, r7
    1bf0:	3b0b4913 	addikc	r24, r11, 18707
    1bf4:	0000102e 		r0, r0, r2
    1bf8:	013f0c03 		r9, r31, r1
    1bfc:	0e3a0b3b 		r17, r26, r1
    1c00:	0b270c49 		r25, r7, r1
    1c04:	13110112 		r24, r17, r0
    1c08:	01400a01 		r10, r0, r1
    1c0c:	13000011 		r24, r0, r0
    1c10:	05000308 	neg	r8, r0
    1c14:	3a0b3b0b 	addikc	r16, r11, 15115
    1c18:	49130206 		r8, r19, r0
    1c1c:	00001234 		r0, r0, r2
    1c20:	00030e3a 		r0, r3, r1
    1c24:	0b3b0b49 		r25, r27, r1
    1c28:	13020600 		r24, r2, r0
    1c2c:	00131501 		r0, r19, r2
    1c30:	270c0113 	rsubi	r24, r12, 275
    1c34:	00001405 		r0, r0, r2
    1c38:	00491300 		r2, r9, r2
    1c3c:	00152e00 		r0, r21, r5
    1c40:	3f0c030e 	rsubikc	r24, r12, 782
    1c44:	3a0b3b05 	addikc	r16, r11, 15109
    1c48:	270c1101 	rsubi	r24, r12, 4353
    1c4c:	1201400a 		r16, r1, r8
    1c50:	0000162e 		r0, r0, r2
    1c54:	013f0c03 		r9, r31, r1
    1c58:	0e3a0b3b 		r17, r26, r1
    1c5c:	05270c11 	neg	r9, r7
    1c60:	01120140 		r8, r18, r0
    1c64:	0a011300 		r16, r1, r2
    1c68:	00170500 		r0, r23, r0
    1c6c:	030e3a0b 		r24, r14, r7
    1c70:	3b054913 	addikc	r24, r5, 18707
    1c74:	00001834 		r0, r0, r3
    1c78:	00030e3a 		r0, r3, r1
    1c7c:	0b3b0b49 		r25, r27, r1
    1c80:	133f0c3c 		r25, r31, r1
    1c84:	0c000000 	rsubc	r0, r0, r0
    1c88:	01110125 		r8, r17, r0
    1c8c:	0e130b03 		r16, r19, r1
    1c90:	0e1b0e11 		r16, r27, r1
    1c94:	01120110 		r8, r18, r0
    1c98:	06000002 	neg	r16, r0
    1c9c:	1600030e 		r16, r0, r0
    1ca0:	3a0b3b0b 	addikc	r16, r11, 15115
    1ca4:	49130000 	idiv	r8, r19, r0
    1ca8:	0324000b 		r25, r4, r0
    1cac:	0b3e0b03 		r25, r30, r1
    1cb0:	0e000004 		r16, r0, r0
    1cb4:	24000b0b 	rsubi	r0, r0, 2827
    1cb8:	3e0b0308 	rsubikc	r16, r11, 776
    1cbc:	00000513 		r0, r0, r0
    1cc0:	01030e0b 		r8, r3, r1
    1cc4:	0b3a0b3b 		r25, r26, r1
    1cc8:	05011300 	neg	r8, r1
    1ccc:	00060d00 		r0, r6, r1
    1cd0:	030e3a0b 		r24, r14, r7
    1cd4:	3b054913 	addikc	r24, r5, 18707
    1cd8:	380a0000 	addikc	r0, r10, 0
    1cdc:	070f000b 	neg	r24, r15
    1ce0:	0b000008 		r24, r0, r0
    1ce4:	01014913 		r8, r1, r9
    1ce8:	01130000 	add	r8, r19, r0
    1cec:	09210049 		r9, r1, r0
    1cf0:	132f0b00 		r25, r15, r1
    1cf4:	000a0f00 		r0, r10, r1
    1cf8:	0b0b4913 		r24, r11, r9
    1cfc:	00000b16 		r0, r0, r1
    1d00:	00030e3a 		r0, r3, r1
    1d04:	0b3b0549 		r25, r27, r0
    1d08:	1300000c 		r24, r0, r0
    1d0c:	1501270c 		r8, r1, r4
    1d10:	01130000 	add	r8, r19, r0
    1d14:	0d050049 		r8, r5, r0
    1d18:	1300000e 		r24, r0, r0
    1d1c:	2e013f0c 	rsubic	r16, r1, 16140
    1d20:	030e3a0b 		r24, r14, r7
    1d24:	3b0b270c 	addikc	r24, r11, 9996
    1d28:	11011201 		r8, r1, r2
    1d2c:	400a0113 		r0, r10, r0
    1d30:	00000f34 		r0, r0, r1
    1d34:	00030e3a 		r0, r3, r1
    1d38:	0b3b0b49 		r25, r27, r1
    1d3c:	13020a00 		r24, r2, r1
    1d40:	00103400 		r0, r16, r6
    1d44:	030e3a0b 		r24, r14, r7
    1d48:	3b054913 	addikc	r24, r5, 18707
    1d4c:	3f0c3c0c 	rsubikc	r24, r12, 15372
    1d50:	00001135 		r0, r0, r2
    1d54:	00491300 		r2, r9, r2
    1d58:	00123400 		r0, r18, r6
    1d5c:	030e3a0b 		r24, r14, r7
    1d60:	3b0b4913 	addikc	r24, r11, 18707
    1d64:	3f0c3c0c 	rsubikc	r24, r12, 15372
    1d68:	00001326 		r0, r0, r2
    1d6c:	00491300 		r2, r9, r2
    1d70:	00143400 		r0, r20, r6
    1d74:	030e3a0b 		r24, r14, r7
    1d78:	3b0b4913 	addikc	r24, r11, 18707
    1d7c:	3f0c020a 	rsubikc	r24, r12, 522
    1d80:	00000001 		r0, r0, r0
    1d84:	1101250e 		r8, r1, r4
    1d88:	130b030e 		r24, r11, r0
    1d8c:	1b0e1101 		r24, r14, r2
    1d90:	12011006 		r16, r1, r2
    1d94:	00000224 		r0, r0, r0
    1d98:	000b0b3e 		r0, r11, r1
    1d9c:	0b030e00 		r24, r3, r1
    1da0:	00031600 		r0, r3, r2
    1da4:	030e3a0b 		r24, r14, r7
    1da8:	3b0b4913 	addikc	r24, r11, 18707
    1dac:	00000424 		r0, r0, r0
    1db0:	000b0b3e 		r0, r11, r1
    1db4:	0b030800 	addc	r24, r3, r1
    1db8:	00050f00 		r0, r5, r1
    1dbc:	0b0b4913 		r24, r11, r9
    1dc0:	00000615 		r0, r0, r0
    1dc4:	01270c01 		r9, r7, r1
    1dc8:	13000007 		r24, r0, r0
    1dcc:	05004913 	neg	r8, r0
    1dd0:	0000080f 		r0, r0, r1
    1dd4:	000b0b00 		r0, r11, r1
    1dd8:	00091301 		r0, r9, r2
    1ddc:	0b0b3a0b 		r24, r11, r7
    1de0:	3b0b0113 	addikc	r24, r11, 275
    1de4:	00000a0d 		r0, r0, r1
    1de8:	00030e3a 		r0, r3, r1
    1dec:	0b3b0b49 		r25, r27, r1
    1df0:	13380a00 		r25, r24, r1
    1df4:	000b2e01 		r0, r11, r5
    1df8:	030e3a0b 		r24, r14, r7
    1dfc:	3b0b270c 	addikc	r24, r11, 9996
    1e00:	200b0113 	addi	r0, r11, 275
    1e04:	00000c05 		r0, r0, r1
    1e08:	00030e3a 		r0, r3, r1
    1e0c:	0b3b0b49 		r25, r27, r1
    1e10:	1300000d 		r24, r0, r0
    1e14:	26004913 	rsubi	r16, r0, 18707
    1e18:	00000e2e 		r0, r0, r1
    1e1c:	00030e3a 		r0, r3, r1
    1e20:	0b3b0b27 		r25, r27, r1
    1e24:	0c200b00 		r1, r0, r1
    1e28:	000f2e01 		r0, r15, r5
    1e2c:	3f0c030e 	rsubikc	r24, r12, 782
    1e30:	3a0b3b0b 	addikc	r16, r11, 15115
    1e34:	270c1101 	rsubi	r24, r12, 4353
    1e38:	1201400a 		r16, r1, r8
    1e3c:	01130000 	add	r8, r19, r0
    1e40:	101d0131 		r0, r29, r0
    1e44:	13110112 		r24, r17, r0
    1e48:	01580b59 		r10, r24, r1
    1e4c:	0b011300 		r24, r1, r2
    1e50:	00110500 		r0, r17, r0
    1e54:	31131c06 	addik	r8, r19, 7174
    1e58:	0000121d 		r0, r0, r2
    1e5c:	00311311 		r1, r17, r2
    1e60:	01120158 		r8, r18, r0
    1e64:	0b590b00 		r26, r25, r1
    1e68:	00132e01 		r0, r19, r5
    1e6c:	3f0c030e 	rsubikc	r24, r12, 782
    1e70:	3a0b3b0b 	addikc	r16, r11, 15115
    1e74:	270c1101 	rsubi	r24, r12, 4353
    1e78:	12014006 		r16, r1, r8
    1e7c:	01130000 	add	r8, r19, r0
    1e80:	14050031 		r0, r5, r0
    1e84:	131c0b00 		r24, r28, r1
    1e88:	00151d01 		r0, r21, r3
    1e8c:	31131101 	addik	r8, r19, 4353
    1e90:	1201580b 		r16, r1, r11
    1e94:	590b0000 	fadd	r8, r11, r0
    1e98:	162e003f 		r17, r14, r0
    1e9c:	0c030e3a 		r0, r3, r1
    1ea0:	0b3b0b27 		r25, r27, r1
    1ea4:	0c110112 		r0, r17, r0
    1ea8:	01400600 		r10, r0, r0
    1eac:	00170101 		r0, r23, r0
    1eb0:	49130113 		r8, r19, r0
    1eb4:	00001821 		r0, r0, r3
    1eb8:	0049132f 		r2, r9, r2
    1ebc:	0b000019 		r24, r0, r0
    1ec0:	3400030e 	rsubik	r0, r0, 782
    1ec4:	3a0b3b0b 	addikc	r16, r11, 15115
    1ec8:	49130000 	idiv	r8, r19, r0
    1ecc:	1a340003 		r17, r20, r0
    1ed0:	0e3a0b3b 		r17, r26, r1
    1ed4:	0b49133f 		r26, r9, r2
    1ed8:	0c3c0c00 		r1, r28, r1
    1edc:	001b3400 		r0, r27, r6
    1ee0:	030e3a0b 		r24, r14, r7
    1ee4:	3b0b4913 	addikc	r24, r11, 18707
    1ee8:	3f0c020a 	rsubikc	r24, r12, 522
    1eec:	00000001 		r0, r0, r0
    1ef0:	1101250e 		r8, r1, r4
    1ef4:	130b030e 		r24, r11, r0
    1ef8:	1b0e1101 		r24, r14, r2
    1efc:	52015506 		r16, r1, r10
    1f00:	10060000 	addk	r0, r6, r0
    1f04:	0224000b 		r17, r4, r0
    1f08:	0b3e0b03 		r25, r30, r1
    1f0c:	0e000003 		r16, r0, r0
    1f10:	24000b0b 	rsubi	r0, r0, 2827
    1f14:	3e0b0308 	rsubikc	r16, r11, 776
    1f18:	00000416 		r0, r0, r0
    1f1c:	00030e3a 		r0, r3, r1
    1f20:	0b3b0b49 		r25, r27, r1
    1f24:	13000005 		r24, r0, r0
    1f28:	0f000b0b 		r24, r0, r1
    1f2c:	0000060f 		r0, r0, r0
    1f30:	000b0b49 		r0, r11, r1
    1f34:	13000007 		r24, r0, r0
    1f38:	1501270c 		r8, r1, r4
    1f3c:	01130000 	add	r8, r19, r0
    1f40:	08050049 		r0, r5, r0
    1f44:	13000009 		r24, r0, r0
    1f48:	13010b0b 		r24, r1, r1
    1f4c:	3a0b3b0b 	addikc	r16, r11, 15115
    1f50:	01130000 	add	r8, r19, r0
    1f54:	0a0d0003 		r16, r13, r0
    1f58:	0e3a0b3b 		r17, r26, r1
    1f5c:	0b491338 		r26, r9, r2
    1f60:	0a00000b 		r16, r0, r0
    1f64:	2e01030e 	rsubic	r16, r1, 782
    1f68:	3a0b3b0b 	addikc	r16, r11, 15115
    1f6c:	270c200b 	rsubi	r24, r12, 8203
    1f70:	01130000 	add	r8, r19, r0
    1f74:	0c050003 		r0, r5, r0
    1f78:	0e3a0b3b 		r17, r26, r1
    1f7c:	0b491300 		r26, r9, r2
    1f80:	000d2600 		r0, r13, r4
    1f84:	49130000 	idiv	r8, r19, r0
    1f88:	0e340003 		r17, r20, r0
    1f8c:	083a0b3b 		r1, r26, r1
    1f90:	0b491300 		r26, r9, r2
    1f94:	000f2e00 		r0, r15, r5
    1f98:	030e3a0b 		r24, r14, r7
    1f9c:	3b0b270c 	addikc	r24, r11, 9996
    1fa0:	200b0000 	addi	r0, r11, 0
    1fa4:	102e0103 		r1, r14, r0
    1fa8:	0e3a0b3b 		r17, r26, r1
    1fac:	0b270c11 		r25, r7, r1
    1fb0:	01120140 		r8, r18, r0
    1fb4:	06011300 	neg	r16, r1
    1fb8:	00111d01 		r0, r17, r3
    1fbc:	31131101 	addik	r8, r19, 4353
    1fc0:	1201580b 		r16, r1, r11
    1fc4:	590b0000 	fadd	r8, r11, r0
    1fc8:	120b0111 		r16, r11, r0
    1fcc:	01120100 		r8, r18, r0
    1fd0:	00133400 		r0, r19, r6
    1fd4:	3113020a 	addik	r8, r19, 522
    1fd8:	00001405 		r0, r0, r2
    1fdc:	00030e3a 		r0, r3, r1
    1fe0:	0b3b0b49 		r25, r27, r1
    1fe4:	13020600 		r24, r2, r0
    1fe8:	00152e01 		r0, r21, r5
    1fec:	3f0c030e 	rsubikc	r24, r12, 782
    1ff0:	3a0b3b0b 	addikc	r16, r11, 15115
    1ff4:	270c4913 	rsubi	r24, r12, 18707
    1ff8:	11011201 		r8, r1, r2
    1ffc:	40060113 		r0, r6, r0
    2000:	00001634 		r0, r0, r2
    2004:	0003083a 		r0, r3, r1
    2008:	0b3b0b49 		r25, r27, r1
    200c:	13020a00 		r24, r2, r1
    2010:	00170500 		r0, r23, r0
    2014:	31131c0b 	addik	r8, r19, 7179
    2018:	00001801 		r0, r0, r3
    201c:	01491301 		r10, r9, r2
    2020:	13000019 		r24, r0, r0
    2024:	21004913 	addi	r8, r0, 18707
    2028:	2f0b0000 	rsubic	r24, r11, 0
    202c:	1a340003 		r17, r20, r0
    2030:	0e3a0b3b 		r17, r26, r1
    2034:	0b491300 		r26, r9, r2
    2038:	001b3400 		r0, r27, r6
    203c:	030e3a0b 		r24, r14, r7
    2040:	3b0b4913 	addikc	r24, r11, 18707
    2044:	3f0c3c0c 	rsubikc	r24, r12, 15372
    2048:	00001c21 		r0, r0, r3
    204c:	0049132f 		r2, r9, r2
    2050:	0500001d 	neg	r8, r0
    2054:	3400030e 	rsubik	r0, r0, 782
    2058:	3a0b3b0b 	addikc	r16, r11, 15115
    205c:	4913020a 		r8, r19, r0
    2060:	00001e34 		r0, r0, r3
    2064:	00030e3a 		r0, r3, r1
    2068:	0b3b0b49 		r25, r27, r1
    206c:	133f0c02 		r25, r31, r1
    2070:	0a000000 	addc	r16, r0, r0
    2074:	01110010 		r8, r17, r0
    2078:	06110112 	neg	r16, r17
    207c:	0103081b 		r8, r3, r1
    2080:	08250813 		r1, r5, r1
    2084:	05000000 	rsub	r8, r0, r0
    2088:	01110010 		r8, r17, r0
    208c:	06110112 	neg	r16, r17
    2090:	0103081b 		r8, r3, r1
    2094:	08250813 		r1, r5, r1
    2098:	05000000 	rsub	r8, r0, r0
    209c:	01110010 		r8, r17, r0
    20a0:	06110112 	neg	r16, r17
    20a4:	0103081b 		r8, r3, r1
    20a8:	08250813 		r1, r5, r1
    20ac:	05000000 	rsub	r8, r0, r0
    20b0:	01110010 		r8, r17, r0
    20b4:	06110112 	neg	r16, r17
    20b8:	0103081b 		r8, r3, r1
    20bc:	08250813 		r1, r5, r1
    20c0:	05000000 	rsub	r8, r0, r0
    20c4:	01110010 		r8, r17, r0
    20c8:	06110112 	neg	r16, r17
    20cc:	0103081b 		r8, r3, r1
    20d0:	08250813 		r1, r5, r1
    20d4:	05000000 	rsub	r8, r0, r0
    20d8:	01110010 		r8, r17, r0
    20dc:	06110112 	neg	r16, r17
    20e0:	0103081b 		r8, r3, r1
    20e4:	08250813 		r1, r5, r1
    20e8:	05000000 	rsub	r8, r0, r0
    20ec:	01110010 		r8, r17, r0
    20f0:	06550603 	neg	r18, r21
    20f4:	081b0825 		r0, r27, r1
    20f8:	08130500 		r0, r19, r0
    20fc:	Address 0x000020fc is out of bounds.


Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000003c 		r0, r0, r0
   4:	00020000 	add	r0, r2, r0
   8:	00000400 		r0, r0, r0
   c:	
Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	ffffffff 		r31, r31, r31
   4:	
Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 		r0, r0, r0
       4:	ffffffff 		r31, r31, r31
       8:	0100017c 		r8, r0, r0
       c:	0f0c0100 		r24, r12, r0
      10:	0000000c 		r0, r0, r0
      14:	
Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	0000000c 		r0, r0, r0
       4:	00000010 		r0, r0, r0
       8:	00015300 		r0, r1, r10
       c:	00001000 	add	r0, r0, r2
      10:	00001c00 		r0, r0, r3
      14:	05730031 	neg	r11, r19
      18:	279f0000 	rsubi	r28, r31, 0
      1c:	
Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	6c6f6e67 	necaget	r3, rfsl7
       4:	206c6f6e 	addi	r3, r12, 28526
       8:	6720696e 	bsrli	r25, r0, 14
       c:	74002f68 		r0, r0, r5
      10:	6f6d652f 	necget	r27, rfsl15
      14:	6c75636b 	ncget	r3, rfsl11
      18:	79746967 		r11, r20, r13
      1c:	65722f44 		r11, r18, r5
      20:	65736b74 	bsrai	r11, r19, 20
      24:	6f702f73 	ecaget	r27, rfsl3
      28:	65637265 	bsrai	r11, r3, 5
      2c:	74626c61 		r3, r2, r13
      30:	7a655f73 		r19, r5, r11
      34:	74645f31 		r3, r4, r11
      38:	5f36382f 		r25, r22, r7
      3c:	73772f61 		r27, r23, r5
      40:	7070732f 		r3, r16, r14
      44:	75636f73 		r11, r3, r13
      48:	49495f68 		r10, r9, r11
      4c:	656c6c6f 	bslli	r11, r12, 15
      50:	5f776f72 		r27, r23, r13
      54:	6c640075 	get	r3, rfsl5
      58:	6172745f 	muli	r11, r18, 29791
      5c:	73656e64 		r27, r5, r13
      60:	00756172 		r3, r21, r12
      64:	745f7075 		r2, r31, r14
      68:	74007561 		r0, r0, r14
      6c:	72745f67 		r19, r20, r11
      70:	6574006c 	bsrli	r11, r20, 12
      74:	6f6e6720 	necget	r27, rfsl0
      78:	6c6f6e67 	necaget	r3, rfsl7
      7c:	20756e73 	addi	r3, r21, 28275
      80:	69676e65 		r11, r7, r13
      84:	6420696e 	bsrli	r1, r0, 14
      88:	7400666c 		r0, r0, r12
      8c:	6f617400 	tnecget	r27, rfsl0
      90:	75617274 		r11, r1, r14
      94:	5f726561 		r27, r18, r12
      98:	64004350 	bsrai	r0, r0, 16
      9c:	555f5645 		r10, r31, r10
      a0:	5200756e 		r16, r0, r14
      a4:	7369676e 		r27, r9, r12
      a8:	65642063 	bsrli	r11, r4, 3
      ac:	68617200 		r3, r1, r14
      b0:	75617274 		r11, r1, r14
      b4:	5f776169 		r27, r23, r12
      b8:	745f7478 		r2, r31, r14
      bc:	5f646f6e 		r27, r4, r13
      c0:	6500646f 	bslli	r8, r0, 15
      c4:	75626c65 		r11, r2, r13
      c8:	00756172 		r3, r21, r12
      cc:	745f7772 		r2, r31, r14
      d0:	69746500 		r11, r20, r12
      d4:	75617274 		r11, r1, r14
      d8:	5f776169 		r27, r23, r12
      dc:	745f7278 		r2, r31, r14
      e0:	5f726561 		r27, r18, r12
      e4:	64790073 	bsrli	r3, r25, 19
      e8:	686f7274 		r3, r15, r14
      ec:	20756e73 	addi	r3, r21, 28275
      f0:	69676e65 		r11, r7, r13
      f4:	6420696e 	bsrli	r1, r0, 14
      f8:	74007362 		r0, r0, r14
      fc:	5f75696e 		r27, r21, r13
     100:	74385f74 		r1, r24, r11
     104:	00435055 		r2, r3, r10
     108:	5f434849 		r26, r3, r9
     10c:	5000474e 		r0, r0, r8
     110:	55204320 		r9, r0, r8
     114:	342e362e 	rsubik	r1, r14, 13870
     118:	32203230 	addik	r17, r0, 12848
     11c:	31313130 	addik	r9, r17, 12592
     120:	31382028 	addik	r9, r24, 8232
     124:	58696c69 		r3, r9, r13
     128:	6e782031 	cget	r19, rfsl1
     12c:	342e3120 	rsubik	r1, r14, 12576
     130:	4275696c 		r19, r21, r13
     134:	64204544 	bslli	r1, r0, 4
     138:	4b5f502e 		r26, r31, r10
     13c:	31352032 	addik	r9, r21, 8242
     140:	32204d61 	addik	r17, r0, 19809
     144:	72203230 		r17, r0, r6
     148:	31322900 	addik	r9, r18, 10496
     14c:	73625f75 		r27, r2, r11
     150:	696e7433 		r11, r14, r14
     154:	325f7400 	addik	r18, r31, 29696
     158:	73686f72 		r27, r8, r13
     15c:	7420696e 		r1, r0, r13
     160:	74002e2e 		r0, r0, r5
     164:	2f2e2e2f 	rsubic	r25, r14, 11823
     168:	6c69622f 	ncget	r3, rfsl15
     16c:	73656372 		r27, r5, r12
     170:	6574626c 	bsrai	r11, r20, 12
     174:	617a652f 	muli	r11, r26, 25903
     178:	73625f75 		r27, r2, r11
     17c:	6172742e 	muli	r11, r18, 29742
     180:	6300666c 	muli	r24, r0, 26220
     184:	61670069 	muli	r11, r7, 105
     188:	745f7665 		r2, r31, r14
     18c:	63746f72 	muli	r27, r20, 28530
     190:	5f746162 		r27, r20, r12
     194:	6c650069 	get	r3, rfsl9
     198:	6e745f73 	tneaget	r19, rfsl3
     19c:	74617475 		r3, r1, r14
     1a0:	7300696e 		r24, r0, r13
     1a4:	74635f69 		r3, r3, r11
     1a8:	6e697400 	tnecget	r19, rfsl0
     1ac:	696e7463 		r11, r14, r14
     1b0:	5f617474 		r27, r1, r14
     1b4:	6163685f 	muli	r11, r3, 26719
     1b8:	68616e64 		r3, r1, r13
     1bc:	6c657200 	tncget	r3, rfsl0
     1c0:	7072696d 		r3, r18, r13
     1c4:	6172795f 	muli	r11, r18, 31071
     1c8:	696e745f 		r11, r14, r14
     1cc:	68616e64 		r3, r1, r13
     1d0:	6c657200 	tncget	r3, rfsl0
     1d4:	696e745f 		r11, r14, r14
     1d8:	656e7472 	bslli	r11, r14, 18
     1dc:	79006974 		r8, r0, r13
     1e0:	5f707269 		r27, r16, r14
     1e4:	6f726974 	ncaget	r27, rfsl4
     1e8:	795f7461 		r10, r31, r14
     1ec:	626c6500 	muli	r19, r12, 25856
     1f0:	63616c6c 	muli	r27, r1, 27756
     1f4:	6261636b 	muli	r19, r1, 25451
     1f8:	0069745f 		r3, r9, r14
     1fc:	68616e64 		r3, r1, r13
     200:	6c657200 	tncget	r3, rfsl0
     204:	696e7465 		r11, r14, r14
     208:	72727570 		r19, r18, r14
     20c:	745f6964 		r2, r31, r13
     210:	00696e74 		r3, r9, r13
     214:	5f6d6173 		r27, r13, r12
     218:	6b007362 		r24, r0, r14
     21c:	5f766563 		r27, r22, r12
     220:	746f725f 		r3, r15, r14
     224:	7461626c 		r3, r1, r12
     228:	655f656e 	bslli	r10, r31, 14
     22c:	74727900 		r3, r18, r15
     230:	2e2e2f2e 	rsubic	r17, r14, 12078
     234:	2e2f6c69 	rsubic	r17, r15, 27753
     238:	622f7365 	muli	r17, r15, 29541
     23c:	63726574 	muli	r27, r18, 25972
     240:	626c617a 	muli	r19, r12, 24954
     244:	652f7362 	bsrai	r9, r15, 2
     248:	5f696e74 		r27, r9, r13
     24c:	632e6300 	muli	r25, r14, 25344
     250:	696e745f 		r11, r14, r14
     254:	69640073 		r11, r4, r0
     258:	625f696e 	muli	r18, r31, 26990
     25c:	74657272 		r3, r5, r14
     260:	7570745f 		r11, r16, r14
     264:	68616e64 		r3, r1, r13
     268:	6c657200 	tncget	r3, rfsl0
     26c:	73625f69 		r27, r2, r11
     270:	6e743332 	tcget	r19, rfsl2
     274:	5f740073 		r27, r20, r0
     278:	7472696e 		r3, r18, r13
     27c:	67007072 	bsrli	r24, r0, 18
     280:	696e7469 		r11, r14, r14
     284:	00706164 		r3, r16, r12
     288:	63686172 	muli	r27, r8, 24946
     28c:	00655f70 		r3, r5, r11
     290:	72696e74 		r19, r9, r13
     294:	6600666f 		r16, r0, r12
     298:	726d6174 		r19, r13, r12
     29c:	00707269 		r3, r16, r14
     2a0:	6e745f62 	tneaget	r19, rfsl2
     2a4:	75660065 		r11, r6, r0
     2a8:	5f737072 		r27, r19, r14
     2ac:	696e7466 		r11, r14, r14
     2b0:	00707269 		r3, r16, r14
     2b4:	6e740077 	get	r19, rfsl7
     2b8:	69647468 		r11, r4, r14
     2bc:	006c6574 		r3, r12, r12
     2c0:	62617365 	muli	r19, r1, 29541
     2c4:	00707269 		r3, r16, r14
     2c8:	6e747300 	tncget	r19, rfsl0
     2cc:	6f757462 	tnecget	r27, rfsl2
     2d0:	79746500 		r11, r20, r12
     2d4:	2e2e2f2e 	rsubic	r17, r14, 12078
     2d8:	2e2f6c69 	rsubic	r17, r15, 27753
     2dc:	622f655f 	muli	r17, r15, 25951
     2e0:	6c69622f 	ncget	r3, rfsl15
     2e4:	655f7072 	bsrli	r10, r31, 18
     2e8:	696e7466 		r11, r14, r14
     2ec:	2e630076 	rsubic	r19, r3, 118
     2f0:	61726700 	muli	r11, r18, 26368
     2f4:	4350555f 		r26, r16, r10
     2f8:	4e616d65 	ecaputd	r1, r13
     2fc:	53657400 		r27, r5, r14
     300:	6370755f 	muli	r27, r16, 30047
     304:	73720043 		r27, r18, r0
     308:	50555f43 		r2, r21, r11
     30c:	48415200 		r2, r1, r10
     310:	4350555f 		r26, r16, r10
     314:	4e616d65 	ecaputd	r1, r13
     318:	436c7200 		r27, r12, r14
     31c:	4350555f 		r26, r16, r10
     320:	45525200 	bsra	r10, r18, r10
     324:	4350555f 		r26, r16, r10
     328:	44415441 	bsll	r2, r1, r10
     32c:	00435055 		r2, r3, r10
     330:	5f494e54 		r26, r9, r9
     334:	33325500 	addik	r25, r18, 21760
     338:	4350555f 		r26, r16, r10
     33c:	494e5430 		r10, r14, r10
     340:	38550043 	addikc	r2, r21, 67
     344:	50555f53 		r2, r21, r11
     348:	495a455f 		r10, r26, r8
     34c:	54006e62 		r0, r0, r13
     350:	725f6c65 		r18, r31, r13
     354:	61645f7a 	muli	r11, r4, 24442
     358:	65726f73 		r11, r18, r13
     35c:	002e2e2f 		r1, r14, r5
     360:	2e2e2f6c 	rsubic	r17, r14, 12140
     364:	69622f6f 		r11, r2, r5
     368:	732f7543 		r25, r15, r14
     36c:	5f4f532d 		r26, r15, r10
     370:	49495f76 		r10, r9, r11
     374:	325f3930 	addik	r18, r31, 14640
     378:	2f637075 	rsubic	r27, r3, 28789
     37c:	5f636f72 		r27, r3, r13
     380:	652e6300 	bsrai	r9, r14, 0
     384:	4350555f 		r26, r16, r10
     388:	4e616d65 	ecaputd	r1, r13
     38c:	00435055 		r2, r3, r10
     390:	5f436e74 		r26, r3, r13
     394:	4c656164 	ecagetd	r3, r12
     398:	5a65726f 		r19, r5, r14
     39c:	7354626c 		r26, r20, r12
     3a0:	00435055 		r2, r3, r10
     3a4:	5f494e54 		r26, r9, r9
     3a8:	31365500 	addik	r9, r22, 21760
     3ac:	4350555f 		r26, r16, r10
     3b0:	436e744c 		r27, r14, r14
     3b4:	6561645a 	bslli	r11, r1, 26
     3b8:	65726f73 		r11, r18, r13
     3bc:	00705f65 		r3, r16, r11
     3c0:	72720043 		r19, r18, r0
     3c4:	50555f4e 		r2, r21, r11
     3c8:	616d6547 	muli	r11, r13, 25927
     3cc:	65740043 	bsrli	r11, r20, 3
     3d0:	50555f41 		r2, r21, r11
     3d4:	44445200 	bsra	r2, r4, r10
     3d8:	4350555f 		r26, r16, r10
     3dc:	496e6974 		r11, r14, r13
     3e0:	00435055 		r2, r3, r10
     3e4:	5f4e616d 		r26, r14, r12
     3e8:	65496e69 		r10, r9, r13
     3ec:	7400705f 		r0, r0, r14
     3f0:	6e616d65 	necaget	r19, rfsl5
     3f4:	00415343 		r2, r1, r10
     3f8:	49495f43 		r10, r9, r11
     3fc:	6d70002e 	get	r11, rfsl14
     400:	2e2f2e2e 	rsubic	r17, r15, 11822
     404:	2f6c6962 	rsubic	r27, r12, 26978
     408:	2f6f732f 	rsubic	r27, r15, 29487
     40c:	75435f4f 		r10, r3, r11
     410:	532d4949 		r25, r13, r9
     414:	5f76325f 		r27, r22, r6
     418:	39302f6c 	addikc	r9, r16, 12140
     41c:	69625f61 		r11, r2, r11
     420:	73636969 		r27, r3, r13
     424:	2e630041 	rsubic	r19, r3, 65
     428:	53434949 		r26, r3, r9
     42c:	5f497355 		r26, r9, r14
     430:	70706572 		r3, r16, r12
     434:	00415343 		r2, r1, r10
     438:	49495f49 		r10, r9, r11
     43c:	73426c61 		r26, r2, r13
     440:	6e6b0041 	get	r19, rfsl1
     444:	53434949 		r26, r3, r9
     448:	5f49734c 		r26, r9, r14
     44c:	6f776572 	necget	r27, rfsl2
     450:	00616c70 		r3, r1, r13
     454:	68615f6e 		r3, r1, r11
     458:	756d0062 		r11, r13, r0
     45c:	6c616e6b 	necaget	r3, rfsl11
     460:	00415343 		r2, r1, r10
     464:	49495f49 		r10, r9, r11
     468:	7350756e 		r26, r16, r14
     46c:	63740070 	muli	r27, r20, 112
     470:	756e6374 		r11, r14, r12
     474:	00415343 		r2, r1, r10
     478:	49495f49 		r10, r9, r11
     47c:	73537061 		r26, r19, r14
     480:	63650043 	muli	r27, r5, 67
     484:	50555f49 		r2, r21, r11
     488:	4e543038 	egetd	r18, r6
     48c:	53004153 		r24, r0, r8
     490:	4349495f 		r26, r9, r9
     494:	49734469 		r11, r19, r8
     498:	67486578 	bslli	r26, r8, 24
     49c:	0063315f 		r3, r3, r6
     4a0:	75707065 		r11, r16, r14
     4a4:	72004153 		r16, r0, r8
     4a8:	4349495f 		r26, r9, r9
     4ac:	49734469 		r11, r19, r8
     4b0:	67004153 	bsrli	r24, r0, 19
     4b4:	4349495f 		r26, r9, r9
     4b8:	4973416c 		r11, r19, r8
     4bc:	7068614e 		r3, r8, r12
     4c0:	756d0043 		r11, r13, r0
     4c4:	50555f42 		r2, r21, r11
     4c8:	4f4f4c45 	aputd	r15, r9
     4cc:	414e0041 		r10, r14, r0
     4d0:	53434949 		r26, r3, r9
     4d4:	5f497343 		r26, r9, r14
     4d8:	74726c00 		r3, r18, r13
     4dc:	41534349 		r10, r19, r8
     4e0:	495f4973 		r10, r31, r9
     4e4:	47726170 	bsrl	r27, r18, r12
     4e8:	68006374 		r0, r0, r12
     4ec:	726c0063 		r19, r12, r0
     4f0:	325f7570 	addik	r18, r31, 30064
     4f4:	70657200 		r3, r5, r14
     4f8:	41534349 		r10, r19, r8
     4fc:	495f4973 		r10, r31, r9
     500:	4469674f 		r3, r9, r12
     504:	63740041 	muli	r27, r20, 65
     508:	53434949 		r26, r3, r9
     50c:	5f497350 		r26, r9, r14
     510:	72696e74 		r19, r9, r13
     514:	00677261 		r3, r7, r14
     518:	70680064 		r3, r8, r0
     51c:	69675f6f 		r11, r7, r11
     520:	63740064 	muli	r27, r20, 100
     524:	69675f68 		r11, r7, r11
     528:	65780041 	bsrli	r11, r24, 1
     52c:	53434949 		r26, r3, r9
     530:	5f497341 		r26, r9, r14
     534:	6c706861 	ncaget	r3, rfsl1
     538:	00415343 		r2, r1, r10
     53c:	49495f54 		r10, r9, r11
     540:	6f557070 	tncget	r26, rfsl0
     544:	65720041 	bsrli	r11, r18, 1
     548:	53434949 		r26, r3, r9
     54c:	5f546f4c 		r26, r20, r13
     550:	6f776572 	necget	r27, rfsl2
     554:	004d6174 		r2, r13, r12
     558:	685f5261 		r2, r31, r10
     55c:	6e645365 	tnget	r19, rfsl5
     560:	65640072 	bsrli	r11, r4, 18
     564:	616e645f 	muli	r11, r14, 25695
     568:	6e627200 	tncget	r19, rfsl0
     56c:	4d617468 	eaputd	r1, r14
     570:	5f52616e 		r26, r18, r12
     574:	64004d61 	bslli	r0, r0, 1
     578:	74685f52 		r3, r8, r11
     57c:	616e6453 	muli	r11, r14, 25683
     580:	65745365 	bsrai	r11, r20, 5
     584:	65640073 	bsrli	r11, r4, 19
     588:	65656400 	bslli	r11, r5, 0
     58c:	4d617468 	eaputd	r1, r14
     590:	5f496e69 		r26, r9, r13
     594:	74002e2e 		r0, r0, r5
     598:	2f2e2e2f 	rsubic	r25, r14, 11823
     59c:	6c69622f 	ncget	r3, rfsl15
     5a0:	6f732f75 	ecaget	r27, rfsl5
     5a4:	435f4f53 		r26, r31, r9
     5a8:	2d49495f 	rsubic	r10, r9, 18783
     5ac:	76325f39 		r17, r18, r11
     5b0:	302f6c69 	addik	r1, r15, 27753
     5b4:	625f6d61 	muli	r18, r31, 28001
     5b8:	74682e63 		r3, r8, r5
     5bc:	0052414e 		r2, r18, r8
     5c0:	445f4e42 		r2, r31, r9
     5c4:	52004d61 		r16, r0, r9
     5c8:	74685f52 		r3, r8, r11
     5cc:	616e6453 	muli	r11, r14, 25683
     5d0:	65656443 	bslli	r11, r5, 3
     5d4:	75720070 		r11, r18, r0
     5d8:	325f6d65 	addik	r18, r31, 28005
     5dc:	6d5f3038 	tcget	r10, rfsl8
     5e0:	00707372 		r3, r16, r14
     5e4:	63007064 	muli	r24, r0, 28772
     5e8:	65737400 	bslli	r11, r19, 0
     5ec:	64617461 	bslli	r3, r1, 1
     5f0:	5f616c69 		r27, r1, r13
     5f4:	676e0070 	bsrli	r27, r14, 16
     5f8:	325f6d65 	addik	r18, r31, 28005
     5fc:	6d5f616c 	ncget	r10, rfsl12
     600:	69676e00 		r11, r7, r13
     604:	706d656d 		r3, r13, r12
     608:	006d656d 		r3, r13, r12
     60c:	5f616c69 		r27, r1, r13
     610:	676e5f6d 		r27, r14, r11
     614:	6f64756c 	tnecget	r27, rfsl12
     618:	6f5f7372 	tncget	r26, rfsl2
     61c:	6300706d 	muli	r24, r0, 28781
     620:	656d5f61 		r11, r13, r11
     624:	6c69676e 	necget	r3, rfsl14
     628:	5f646573 		r27, r4, r12
     62c:	74006d65 		r0, r0, r13
     630:	6d5f636d 	ncget	r10, rfsl13
     634:	70004d65 		r0, r0, r9
     638:	6d5f436f 	nget	r10, rfsl15
     63c:	70790073 		r3, r25, r0
     640:	697a655f 		r11, r26, r12
     644:	72656d00 		r19, r5, r13
     648:	70315f6d 		r1, r17, r11
     64c:	656d006d 	bsrli	r11, r13, 13
     650:	656d5f61 		r11, r13, r11
     654:	6c69676e 	necget	r3, rfsl14
     658:	5f6d6f64 		r27, r13, r13
     65c:	756c6f5f 		r11, r12, r13
     660:	31004d65 	addik	r8, r0, 19813
     664:	6d5f436d 	nget	r10, rfsl13
     668:	7000706d 		r0, r0, r14
     66c:	656d5f30 		r11, r13, r11
     670:	385f6465 	addikc	r2, r31, 25701
     674:	7374004d 		r27, r20, r0
     678:	656d5f49 		r11, r13, r11
     67c:	6e697400 	tnecget	r19, rfsl0
     680:	70315f6d 		r1, r17, r11
     684:	656d5f61 		r11, r13, r11
     688:	6c69676e 	necget	r3, rfsl14
     68c:	006d656d 		r3, r13, r12
     690:	5f616c69 		r27, r1, r13
     694:	676e5f6d 		r27, r14, r11
     698:	6f64756c 	tnecget	r27, rfsl12
     69c:	6f5f3200 	tcget	r26, rfsl0
     6a0:	706d656d 		r3, r13, r12
     6a4:	5f30385f 		r25, r16, r7
     6a8:	73726300 		r27, r18, r12
     6ac:	6d656d5f 	necaget	r11, rfsl15
     6b0:	616c6967 	muli	r11, r12, 26983
     6b4:	6e5f6d6f 	necaget	r18, rfsl15
     6b8:	64756c6f 	bslli	r3, r21, 15
     6bc:	5f646573 		r27, r4, r12
     6c0:	74006461 		r0, r0, r12
     6c4:	74615f76 		r3, r1, r11
     6c8:	616c0043 	muli	r11, r12, 67
     6cc:	50555f41 		r2, r21, r11
     6d0:	4c49474e 	ncaputd	r9, r8
     6d4:	006d656d 		r3, r13, r12
     6d8:	5f616c69 		r27, r1, r13
     6dc:	676e5f6d 		r27, r14, r11
     6e0:	6f64756c 	tnecget	r27, rfsl12
     6e4:	6f00706d 	tncget	r24, rfsl13
     6e8:	656d5f61 		r11, r13, r11
     6ec:	6c69676e 	necget	r3, rfsl14
     6f0:	5f737263 		r27, r19, r14
     6f4:	004d656d 		r2, r13, r12
     6f8:	5f536574 		r26, r19, r12
     6fc:	0070315f 		r3, r16, r6
     700:	6d656d5f 	necaget	r11, rfsl15
     704:	30380070 	addik	r1, r24, 112
     708:	325f6d65 	addik	r18, r31, 28005
     70c:	6d004d65 	neaget	r8, rfsl5
     710:	6d5f436c 	nget	r10, rfsl12
     714:	7200706d 		r16, r0, r14
     718:	656d5f61 		r11, r13, r11
     71c:	6c69676e 	necget	r3, rfsl14
     720:	006d656d 		r3, r13, r12
     724:	5f616c69 		r27, r1, r13
     728:	676e6564 	bslli	r27, r14, 4
     72c:	002e2e2f 		r1, r14, r5
     730:	2e2e2f6c 	rsubic	r17, r14, 12140
     734:	69622f6f 		r11, r2, r5
     738:	732f7543 		r25, r15, r14
     73c:	5f4f532d 		r26, r15, r10
     740:	49495f76 		r10, r9, r11
     744:	325f3930 	addik	r18, r31, 14640
     748:	2f6c6962 	rsubic	r27, r12, 26978
     74c:	5f6d656d 		r27, r13, r12
     750:	2e630070 	rsubic	r19, r3, 112
     754:	6d656d5f 	necaget	r11, rfsl15
     758:	3038006e 	addik	r1, r24, 110
     75c:	62725f64 	muli	r19, r18, 24420
     760:	69670070 		r11, r7, r0
     764:	7374725f 		r27, r20, r14
     768:	6e657874 	tncaget	r19, rfsl4
     76c:	00435055 		r2, r3, r10
     770:	5f494e54 		r26, r9, r9
     774:	33325300 	addik	r25, r18, 21248
     778:	5374725f 		r27, r20, r14
     77c:	436d7000 	mul	r27, r13, r14
     780:	5374725f 		r27, r20, r14
     784:	43686172 		r27, r8, r12
     788:	5f4c6173 		r26, r12, r12
     78c:	745f4e00 		r2, r31, r9
     790:	70737472 		r3, r19, r14
     794:	5f737263 		r27, r19, r14
     798:	00636d70 		r3, r3, r13
     79c:	5f6c656e 		r27, r12, r12
     7a0:	00537472 		r2, r19, r14
     7a4:	5f436861 		r26, r3, r13
     7a8:	725f4c61 		r18, r31, r9
     7ac:	73740070 		r27, r20, r0
     7b0:	7374725f 		r27, r20, r14
     7b4:	636d705f 	muli	r27, r13, 28767
     7b8:	315f6e65 	addik	r10, r31, 28261
     7bc:	78740070 		r3, r20, r0
     7c0:	7374725f 		r27, r20, r14
     7c4:	70617273 		r3, r1, r14
     7c8:	65007073 	bsrli	r8, r0, 19
     7cc:	74725f73 		r3, r18, r11
     7d0:	7263685f 		r19, r3, r13
     7d4:	6978006e 		r11, r24, r0
     7d8:	62725f73 	muli	r19, r18, 24435
     7dc:	69676e65 		r11, r7, r13
     7e0:	64006c6f 	bslli	r0, r0, 15
     7e4:	675f666c 		r26, r31, r12
     7e8:	6f6f7200 	tncget	r27, rfsl0
     7ec:	6c6f7765 	tnecget	r3, rfsl5
     7f0:	725f6361 		r18, r31, r12
     7f4:	7365006e 		r27, r5, r0
     7f8:	62725f62 	muli	r19, r18, 24418
     7fc:	61736500 	muli	r11, r19, 25856
     800:	70737472 		r3, r19, r14
     804:	5f636174 		r27, r3, r12
     808:	5f737263 		r27, r19, r14
     80c:	00737472 		r3, r19, r14
     810:	5f6c656e 		r27, r12, r12
     814:	5f737263 		r27, r19, r14
     818:	68005374 		r0, r0, r10
     81c:	725f466d 		r18, r31, r8
     820:	744e6272 		r2, r14, r12
     824:	5f496e74 		r26, r9, r13
     828:	33320053 	addik	r25, r18, 83
     82c:	74725f50 		r3, r18, r11
     830:	61727365 	muli	r11, r18, 29541
     834:	4e62725f 	nagetd	r19, r14
     838:	496e7433 		r11, r14, r14
     83c:	32006e62 	addik	r16, r0, 28258
     840:	725f666d 		r18, r31, r12
     844:	74007073 		r0, r0, r14
     848:	74725f63 		r3, r18, r11
     84c:	6d705f32 	tneaget	r11, rfsl2
     850:	5f6e6578 		r27, r14, r12
     854:	74006368 		r0, r0, r12
     858:	61725f31 	muli	r11, r18, 24369
     85c:	00636861 		r3, r3, r13
     860:	725f3200 		r18, r31, r6
     864:	70737472 		r3, r19, r14
     868:	5f636d70 		r27, r3, r13
     86c:	5f310070 		r25, r17, r0
     870:	7374725f 		r27, r20, r14
     874:	636d705f 	muli	r27, r13, 28767
     878:	32007372 	addik	r16, r0, 29554
     87c:	63685f63 	muli	r27, r8, 24419
     880:	68617200 		r3, r1, r14
     884:	5374725f 		r27, r20, r14
     888:	4c656e5f 	naputd	r5, r13
     88c:	4e005374 	necagetd	r16, r10
     890:	725f5374 		r18, r31, r10
     894:	725f4e00 		r18, r31, r9
     898:	5374725f 		r27, r20, r14
     89c:	4c656e00 	nputd	r5, r13
     8a0:	70737472 		r3, r19, r14
     8a4:	5f737263 		r27, r19, r14
     8a8:	68007073 		r0, r0, r14
     8ac:	74725f73 		r3, r18, r11
     8b0:	7472006e 		r3, r18, r0
     8b4:	62725f68 	muli	r19, r18, 24424
     8b8:	65785f6c 		r11, r24, r11
     8bc:	6f776572 	necget	r27, rfsl2
     8c0:	00707374 		r3, r16, r14
     8c4:	725f636f 		r18, r31, r12
     8c8:	70795f73 		r3, r25, r11
     8cc:	72630073 		r19, r3, r0
     8d0:	74725f6c 		r3, r18, r11
     8d4:	656e5f6d 		r11, r14, r11
     8d8:	61780053 	muli	r11, r24, 83
     8dc:	74725f43 		r3, r18, r11
     8e0:	6d705f4e 	tneaget	r11, rfsl14
     8e4:	006e6272 		r3, r14, r12
     8e8:	5f646967 		r27, r4, r13
     8ec:	5f76616c 		r27, r22, r12
     8f0:	00537472 		r2, r19, r14
     8f4:	5f466d74 		r26, r6, r13
     8f8:	4e62725f 	nagetd	r19, r14
     8fc:	496e7433 		r11, r14, r14
     900:	32530070 	addik	r18, r19, 112
     904:	61727365 	muli	r11, r18, 29541
     908:	5f636861 		r27, r3, r13
     90c:	72005374 		r16, r0, r10
     910:	725f4361 		r18, r31, r8
     914:	74006e62 		r0, r0, r13
     918:	725f616c 		r18, r31, r12
     91c:	70686100 		r3, r8, r12
     920:	70737472 		r3, r19, r14
     924:	5f636174 		r27, r3, r12
     928:	5f646573 		r27, r4, r12
     92c:	74007073 		r0, r0, r14
     930:	74725f64 		r3, r18, r11
     934:	65737400 	bslli	r11, r19, 0
     938:	5374725f 		r27, r20, r14
     93c:	436d7049 		r27, r13, r14
     940:	676e6f72 		r27, r14, r13
     944:	65436173 	bsrli	r10, r3, 19
     948:	65007768 		r8, r0, r14
     94c:	69746573 		r11, r20, r12
     950:	70616365 		r3, r1, r12
     954:	00707374 		r3, r16, r14
     958:	725f7274 		r18, r31, r14
     95c:	6e002e2e 	ecaget	r16, rfsl14
     960:	2f2e2e2f 	rsubic	r25, r14, 11823
     964:	6c69622f 	ncget	r3, rfsl15
     968:	6f732f75 	ecaget	r27, rfsl5
     96c:	435f4f53 		r26, r31, r9
     970:	2d49495f 	rsubic	r10, r9, 18783
     974:	76325f39 		r17, r18, r11
     978:	302f6c69 	addik	r1, r15, 27753
     97c:	625f7374 	muli	r18, r31, 29556
     980:	722e6300 		r17, r14, r12
     984:	5374725f 		r27, r20, r14
     988:	436f7079 		r27, r15, r14
     98c:	006c656e 		r3, r12, r12
     990:	5f636f70 		r27, r3, r13
     994:	79007372 		r8, r0, r14
     998:	63685f64 	muli	r27, r8, 24420
     99c:	6f6e6500 	necget	r27, rfsl0
     9a0:	70617273 		r3, r1, r14
     9a4:	655f6469 	bslli	r10, r31, 9
     9a8:	67007073 	bsrli	r24, r0, 19
     9ac:	74725f70 		r3, r18, r11
     9b0:	61727365 	muli	r11, r18, 29541
     9b4:	5f6e6272 		r27, r14, r12
     9b8:	00707374 		r3, r16, r14
     9bc:	725f6c65 		r18, r31, r13
     9c0:	6e006e62 	necaget	r16, rfsl2
     9c4:	725f6162 		r18, r31, r12
     9c8:	73007073 		r24, r0, r14
     9cc:	74725f63 		r3, r18, r11
     9d0:	68617200 		r3, r1, r14
     9d4:	5374725f 		r27, r20, r14
     9d8:	53747200 		r27, r20, r14
     9dc:	706e6272 		r3, r14, r12
     9e0:	5f6e6567 		r27, r14, r12
     9e4:	006c6561 		r3, r12, r12
     9e8:	645f6368 	bsrai	r2, r31, 8
     9ec:	61720053 	muli	r11, r18, 83
     9f0:	74725f43 		r3, r18, r11
     9f4:	6861725f 		r3, r1, r14
     9f8:	4e00636d 	necagetd	r16, r12
     9fc:	705f7661 		r2, r31, r14
     a00:	6c007372 	tncget	r0, rfsl2
     a04:	63685f6c 	muli	r27, r8, 24428
     a08:	656e0070 	bsrli	r11, r14, 16
     a0c:	7374725f 		r27, r20, r14
     a10:	63617400 	muli	r27, r1, 29696
     a14:	6c656e5f 	necaget	r3, rfsl15
     a18:	6d61785f 	tncaget	r11, rfsl15
     a1c:	73726368 		r27, r18, r12
     a20:	00537472 		r2, r19, r14
     a24:	5f436d70 		r26, r3, r13
     a28:	49676e6f 		r11, r7, r13
     a2c:	72654361 		r19, r5, r8
     a30:	73655f4e 		r27, r5, r11
     a34:	00707374 		r3, r16, r14
     a38:	725f666d 		r18, r31, r12
     a3c:	74006e62 		r0, r0, r13
     a40:	725f6865 		r18, r31, r13
     a44:	78007372 		r0, r0, r14
     a48:	63685f63 	muli	r27, r8, 24419
     a4c:	6d700053 	get	r11, rfsl3
     a50:	74725f43 		r3, r18, r11
     a54:	68617200 		r3, r1, r14
     a58:	5374725f 		r27, r20, r14
     a5c:	466d744e 	bsll	r19, r13, r14
     a60:	62725f49 	muli	r19, r18, 24393
     a64:	6e743332 	tcget	r19, rfsl2
     a68:	55006e62 		r8, r0, r13
     a6c:	725f6578 		r18, r31, r12
     a70:	70005374 		r0, r0, r10
     a74:	725f5061 		r18, r31, r10
     a78:	7273654e 		r19, r19, r12
     a7c:	62725f49 	muli	r19, r18, 24393
     a80:	6e743332 	tcget	r19, rfsl2
     a84:	55007073 		r8, r0, r14
     a88:	74725f31 		r3, r18, r11
     a8c:	00707374 		r3, r16, r14
     a90:	725f3200 		r18, r31, r6
     a94:	7072696e 		r3, r18, r13
     a98:	745f6368 		r2, r31, r12
     a9c:	61720053 	muli	r11, r18, 83
     aa0:	74725f50 		r3, r18, r11
     aa4:	61727365 	muli	r11, r18, 29541
     aa8:	4e62725f 	nagetd	r19, r14
     aac:	496e7433 		r11, r14, r14
     ab0:	32530070 	addik	r18, r19, 112
     ab4:	73747200 		r27, r20, r14
     ab8:	70737472 		r3, r19, r14
     abc:	5f636f70 		r27, r3, r13
     ac0:	795f6465 		r10, r31, r12
     ac4:	73740053 		r27, r20, r0
     ac8:	74725f4d 		r3, r18, r11
     acc:	756c744f 		r11, r12, r14
     ad0:	76665468 		r19, r6, r10
     ad4:	54626c5f 		r3, r2, r13
     ad8:	496e7433 		r11, r14, r14
     adc:	32550053 	addik	r18, r21, 83
     ae0:	74725f43 		r3, r18, r11
     ae4:	6f70795f 	tncaget	r27, rfsl15
     ae8:	4e004350 	ncagetd	r16, r8
     aec:	555f494e 		r10, r31, r9
     af0:	54313653 		r1, r17, r6
     af4:	006c656e 		r3, r12, r12
     af8:	5f636174 		r27, r3, r12
     afc:	00537472 		r2, r19, r14
     b00:	5f436174 		r26, r3, r12
     b04:	5f4e004f 		r26, r14, r0
     b08:	53466c61 		r26, r6, r13
     b0c:	674e6f64 		r26, r14, r13
     b10:	65544342 	bsrai	r10, r20, 2
     b14:	004f535f 		r2, r15, r10
     b18:	5461736b 		r3, r1, r14
     b1c:	53746174 		r27, r20, r12
     b20:	004f5351 		r2, r15, r10
     b24:	53697a65 		r27, r9, r15
     b28:	0070746f 		r3, r16, r14
     b2c:	73004f53 		r24, r0, r9
     b30:	5f53544b 		r26, r19, r10
     b34:	5f444154 		r26, r4, r8
     b38:	4100706d 		r8, r0, r14
     b3c:	7367735f 		r27, r7, r14
     b40:	72647900 		r19, r4, r15
     b44:	4f535374 	necagetd	r26, r10
     b48:	6174496e 	muli	r11, r20, 18798
     b4c:	69740070 		r11, r20, r0
     b50:	72647974 		r19, r4, r15
     b54:	626c004f 	muli	r19, r12, 79
     b58:	535f464c 		r26, r31, r8
     b5c:	41475f4e 		r10, r7, r11
     b60:	4f444500 	cputd	r4, r8
     b64:	4f535f45 	ncaputd	r19, r11
     b68:	76656e74 		r19, r5, r13
     b6c:	5461736b 		r3, r1, r14
     b70:	52656d6f 		r19, r5, r13
     b74:	76654d75 		r19, r5, r9
     b78:	6c746900 	ncaget	r3, rfsl0
     b7c:	4f535146 	cagetd	r26, r10
     b80:	7265654c 		r19, r5, r12
     b84:	69737400 		r11, r19, r14
     b88:	4f534576 	ecaputd	r19, r8
     b8c:	656e7454 	bslli	r11, r14, 20
     b90:	626c004f 	muli	r19, r12, 79
     b94:	53546d72 		r26, r20, r13
     b98:	4e657874 	eagetd	r19, r15
     b9c:	00705f61 		r3, r16, r11
     ba0:	72670070 		r19, r7, r0
     ba4:	6576656e 	bslli	r11, r22, 14
     ba8:	74735f72 		r3, r19, r11
     bac:	64790070 	bsrli	r3, r25, 16
     bb0:	6576656e 	bslli	r11, r22, 14
     bb4:	74735f6d 		r3, r19, r11
     bb8:	756c7469 		r11, r12, r14
     bbc:	004f5354 		r2, r15, r10
     bc0:	43424379 		r26, r2, r8
     bc4:	636c6573 	muli	r27, r12, 25971
     bc8:	53746172 		r27, r20, r12
     bcc:	74004f53 		r0, r0, r9
     bd0:	4576656e 	bsll	r11, r22, r12
     bd4:	744e616d 		r2, r14, r12
     bd8:	6500494e 	bsrli	r8, r0, 14
     bdc:	54385500 		r1, r24, r10
     be0:	70657665 		r3, r5, r14
     be4:	6e743100 	tcget	r19, rfsl0
     be8:	70657665 		r3, r5, r14
     bec:	6e743200 	tcget	r19, rfsl0
     bf0:	4f535f54 	ncaputd	r19, r11
     bf4:	4d52006f 	eagetd	r10, r0
     bf8:	735f7374 		r26, r31, r14
     bfc:	6b5f6461 		r26, r31, r12
     c00:	7461004f 		r3, r1, r0
     c04:	53544342 		r26, r20, r8
     c08:	5461736b 		r3, r1, r14
     c0c:	4e616d65 	ecaputd	r1, r13
     c10:	004f535f 		r2, r15, r10
     c14:	496e6974 		r11, r14, r13
     c18:	5461736b 		r3, r1, r14
     c1c:	49646c65 		r11, r4, r13
     c20:	004f5354 		r2, r15, r10
     c24:	6d725462 	tneget	r11, rfsl2
     c28:	6c004f53 	neaget	r0, rfsl3
     c2c:	5f496e69 		r26, r9, r13
     c30:	74544342 		r2, r20, r8
     c34:	4c697374 	necagetd	r3, r14
     c38:	00706572 		r3, r16, r12
     c3c:	72004f53 		r16, r0, r9
     c40:	5072696f 		r3, r18, r13
     c44:	48696768 		r3, r9, r12
     c48:	52647900 		r19, r4, r15
     c4c:	4f534964 	ecagetd	r26, r9
     c50:	6c654374 	nget	r3, rfsl4
     c54:	7252756e 		r18, r18, r14
     c58:	004f5351 		r2, r15, r10
     c5c:	496e004f 		r11, r14, r0
     c60:	53546173 		r26, r20, r12
     c64:	6b49646c 		r26, r9, r12
     c68:	6553746b 	bslli	r10, r19, 11
     c6c:	004f5345 		r2, r15, r10
     c70:	76656e74 		r19, r5, r13
     c74:	50747200 		r3, r20, r14
     c78:	4f535f46 	ncaputd	r19, r11
     c7c:	4c414753 	ncaputd	r1, r8
     c80:	004f535f 		r2, r15, r10
     c84:	4576656e 	bsll	r11, r22, r12
     c88:	74546173 		r2, r20, r12
     c8c:	6b576169 		r26, r23, r12
     c90:	744d756c 		r2, r13, r14
     c94:	74690065 		r3, r9, r0
     c98:	76656e74 		r19, r5, r13
     c9c:	735f7374 		r26, r31, r14
     ca0:	6174004f 	muli	r11, r20, 79
     ca4:	53466c61 		r26, r6, r13
     ca8:	674e6f64 		r26, r14, r13
     cac:	65466c61 	bslli	r10, r6, 1
     cb0:	67477270 	bsrai	r26, r7, 16
     cb4:	004f535f 		r2, r15, r10
     cb8:	5461736b 		r3, r1, r14
     cbc:	53746174 		r27, r20, r12
     cc0:	53746b43 		r27, r20, r13
     cc4:	686b004f 		r3, r11, r0
     cc8:	534d656d 		r26, r13, r12
     ccc:	54626c00 		r3, r2, r13
     cd0:	4f53546d 	eaputd	r19, r10
     cd4:	724e616d 		r18, r14, r12
     cd8:	65007074 	bsrli	r8, r0, 20
     cdc:	63623200 	muli	r27, r2, 12800
     ce0:	4f53546d 	eaputd	r19, r10
     ce4:	7253656d 		r18, r19, r12
     ce8:	5369676e 		r27, r9, r12
     cec:	616c004f 	muli	r11, r12, 79
     cf0:	53537461 		r26, r19, r14
     cf4:	7274004f 		r19, r20, r0
     cf8:	535f5354 		r26, r31, r10
     cfc:	4b004f53 		r24, r0, r9
     d00:	5154626c 		r10, r20, r12
     d04:	006f735f 		r3, r15, r14
     d08:	71004f53 		r8, r0, r9
     d0c:	51456e74 		r10, r5, r13
     d10:	72696573 		r19, r9, r12
     d14:	004f5354 		r2, r15, r10
     d18:	6d724672 	neget	r11, rfsl2
     d1c:	6565004f 	bsrli	r11, r5, 15
     d20:	535f5443 		r26, r31, r10
     d24:	42496e69 		r18, r9, r13
     d28:	74004f53 		r0, r0, r9
     d2c:	5f44756d 		r26, r4, r14
     d30:	6d79004f 	get	r11, rfsl15
     d34:	53536368 		r26, r19, r12
     d38:	65644c6f 	bslli	r11, r4, 15
     d3c:	636b006f 	muli	r27, r11, 111
     d40:	735f746d 		r26, r31, r14
     d44:	725f7768 		r18, r31, r14
     d48:	65656c00 	bslli	r11, r5, 0
     d4c:	4f53546d 	eaputd	r19, r10
     d50:	72557365 		r18, r21, r14
     d54:	64004f53 		r0, r0, r9
     d58:	54434244 		r2, r3, r8
     d5c:	6c79004f 	get	r3, rfsl15
     d60:	53544342 		r26, r20, r8
     d64:	44656c52 	bsll	r3, r5, r13
     d68:	65710070 	bsrli	r11, r17, 16
     d6c:	6576656e 	bslli	r11, r22, 14
     d70:	74730065 		r3, r19, r0
     d74:	76656e74 		r19, r5, r13
     d78:	735f7264 		r26, r31, r14
     d7c:	795f6e62 		r10, r31, r13
     d80:	72004f53 		r16, r0, r9
     d84:	546d7254 		r3, r13, r14
     d88:	696d6500 		r11, r13, r12
     d8c:	4f535443 	aputd	r19, r10
     d90:	42537461 		r18, r19, r14
     d94:	74004f53 		r0, r0, r9
     d98:	5f457665 		r26, r5, r14
     d9c:	6e745461 	tneget	r19, rfsl1
     da0:	736b5265 		r27, r11, r10
     da4:	6d6f7665 	tnecget	r11, rfsl5
     da8:	006f735f 		r3, r15, r14
     dac:	666c6167 	bsrli	r19, r12, 7
     db0:	5f6e6f64 		r27, r14, r13
     db4:	65004f53 		r8, r0, r9
     db8:	54434249 		r2, r3, r8
     dbc:	64004f53 		r0, r0, r9
     dc0:	496e7445 		r11, r14, r14
     dc4:	6e746572 	necget	r19, rfsl2
     dc8:	004f534d 		r2, r15, r10
     dcc:	656d426c 	bsrai	r11, r13, 12
     dd0:	6b53697a 		r26, r19, r13
     dd4:	65007062 	bsrli	r8, r0, 2
     dd8:	6f730070 	get	r27, rfsl0
     ddc:	6576656e 	bslli	r11, r22, 14
     de0:	7400706d 		r0, r0, r14
     de4:	7367004f 		r27, r7, r0
     de8:	535f496e 		r26, r31, r9
     dec:	69745264 		r11, r20, r10
     df0:	794c6973 		r10, r12, r13
     df4:	74006f73 		r0, r0, r13
     df8:	5f746362 		r27, r20, r12
     dfc:	00707462 		r3, r16, r14
     e00:	6c004f53 	neaget	r0, rfsl3
     e04:	4d656d46 	caputd	r5, r13
     e08:	7265654c 		r19, r5, r12
     e0c:	69737400 		r11, r19, r14
     e10:	4f535f4d 	ncaputd	r19, r11
     e14:	454d006f 	bsrl	r10, r13, r0
     e18:	735f6576 		r26, r31, r12
     e1c:	656e7400 	bslli	r11, r14, 0
     e20:	4f535443 	aputd	r19, r10
     e24:	4253746b 		r18, r19, r14
     e28:	53697a65 		r27, r9, r15
     e2c:	004f5354 		r2, r15, r10
     e30:	43425374 		r26, r2, r10
     e34:	61745065 	muli	r11, r20, 20581
     e38:	6e640070 	get	r19, rfsl0
     e3c:	6576656e 	bslli	r11, r22, 14
     e40:	74735f70 		r3, r19, r11
     e44:	656e6400 	bslli	r11, r14, 0
     e48:	4f53546d 	eaputd	r19, r10
     e4c:	72446c79 		r18, r4, r13
     e50:	004f5349 		r2, r15, r10
     e54:	6e744578 	neget	r19, rfsl8
     e58:	6974004f 		r11, r20, r0
     e5c:	534d656d 		r26, r13, r12
     e60:	4e467265 	neagetd	r18, r14
     e64:	65004f53 		r8, r0, r9
     e68:	5072696f 		r3, r18, r13
     e6c:	43757200 		r27, r21, r14
     e70:	62697478 	muli	r19, r9, 29816
     e74:	004f5346 		r2, r15, r10
     e78:	6c61674e 	necget	r3, rfsl14
     e7c:	616d6500 	muli	r11, r13, 25856
     e80:	62697479 	muli	r19, r9, 29817
     e84:	004f535f 		r2, r15, r10
     e88:	544d525f 		r2, r13, r10
     e8c:	43414c4c 		r26, r1, r9
     e90:	4241434b 		r18, r1, r8
     e94:	004f5346 		r2, r15, r10
     e98:	6c61674e 	necget	r3, rfsl14
     e9c:	6f646550 	necget	r27, rfsl0
     ea0:	72657600 		r19, r5, r14
     ea4:	4f53546d 	eaputd	r19, r10
     ea8:	72576865 		r18, r23, r13
     eac:	656c5462 	bslli	r11, r12, 2
     eb0:	6c007074 	tncget	r0, rfsl4
     eb4:	6362004f 	muli	r27, r2, 79
     eb8:	53544342 		r26, r20, r8
     ebc:	43747853 		r27, r20, r15
     ec0:	77437472 		r26, r3, r14
     ec4:	004f5345 		r2, r15, r10
     ec8:	76656e74 		r19, r5, r13
     ecc:	4e616d65 	ecaputd	r1, r13
     ed0:	47657400 	bsll	r27, r5, r14
     ed4:	4f535f54 	ncaputd	r19, r11
     ed8:	61736b49 	muli	r11, r19, 27465
     edc:	646c6500 	bslli	r3, r12, 0
     ee0:	4f535f53 	ncaputd	r19, r11
     ee4:	74724c65 		r3, r18, r9
     ee8:	6e004f53 	neaget	r16, rfsl3
     eec:	546d7243 		r3, r13, r14
     ef0:	616c6c62 	muli	r11, r12, 27746
     ef4:	61636b00 	muli	r11, r3, 27392
     ef8:	4f535f51 	ncaputd	r19, r11
     efc:	004f5352 		r2, r15, r10
     f00:	64795462 	bslli	r3, r25, 2
     f04:	6c004f53 	neaget	r0, rfsl3
     f08:	54434253 		r2, r3, r8
     f0c:	746b5074 		r3, r11, r10
     f10:	72006f73 		r16, r0, r13
     f14:	5f666c61 		r27, r6, r13
     f18:	675f6772 		r26, r31, r12
     f1c:	70004f53 		r0, r0, r9
     f20:	466c6167 	bsrl	r19, r12, r12
     f24:	4e6f6465 	eaputd	r15, r12
     f28:	4e657874 	eagetd	r19, r15
     f2c:	004f5354 		r2, r15, r10
     f30:	43425072 		r26, r2, r10
     f34:	6576004f 	bsrli	r11, r22, 15
     f38:	53457665 		r26, r5, r14
     f3c:	6e745065 	tnget	r19, rfsl5
     f40:	6e644d75 	neaget	r19, rfsl5
     f44:	6c746900 	ncaget	r3, rfsl0
     f48:	4f53466c 	neaputd	r19, r8
     f4c:	6167466c 	muli	r11, r7, 18028
     f50:	61677300 	muli	r11, r7, 29440
     f54:	4f535f53 	ncaputd	r19, r11
     f58:	63686564 	muli	r27, r8, 25956
     f5c:	004f5354 		r2, r15, r10
     f60:	43424d73 		r26, r2, r9
     f64:	67004f53 		r24, r0, r9
     f68:	4576656e 	bsll	r11, r22, r12
     f6c:	74547970 		r2, r20, r15
     f70:	65004f53 		r8, r0, r9
     f74:	54434243 		r2, r3, r8
     f78:	79636c65 		r11, r3, r13
     f7c:	73546f74 		r26, r20, r13
     f80:	004f5352 		r2, r15, r10
     f84:	756e6e69 		r11, r14, r13
     f88:	6e67004f 	get	r19, rfsl15
     f8c:	53457665 		r26, r5, r14
     f90:	6e744772 	neget	r19, rfsl2
     f94:	70004f53 		r0, r0, r9
     f98:	56657273 		r19, r5, r14
     f9c:	696f6e00 		r11, r15, r13
     fa0:	4f535f49 	ncaputd	r19, r11
     fa4:	6e69744d 	tnecget	r19, rfsl13
     fa8:	69736300 		r11, r19, r12
     fac:	4f535443 	aputd	r19, r10
     fb0:	424e6578 		r18, r14, r12
     fb4:	74004f53 		r0, r0, r9
     fb8:	54434253 		r2, r3, r8
     fbc:	746b5573 		r3, r11, r10
     fc0:	6564004f 	bsrli	r11, r4, 15
     fc4:	5354696d 		r26, r20, r13
     fc8:	65004f53 		r8, r0, r9
     fcc:	54434242 		r2, r3, r8
     fd0:	69745800 		r11, r20, r11
     fd4:	4f535443 	aputd	r19, r10
     fd8:	42426974 		r18, r2, r13
     fdc:	59004f53 		r8, r0, r9
     fe0:	466c6167 	bsrl	r19, r12, r12
     fe4:	46726565 	bsll	r19, r18, r12
     fe8:	4c697374 	necagetd	r3, r14
     fec:	004f5354 		r2, r15, r10
     ff0:	43425072 		r26, r2, r10
     ff4:	696f5462 		r11, r15, r10
     ff8:	6c004f53 	neaget	r0, rfsl3
     ffc:	5f536368 		r26, r19, r12
    1000:	65644e65 		r11, r4, r9
    1004:	77002e2e 		r24, r0, r5
    1008:	2f2e2e2f 	rsubic	r25, r14, 11823
    100c:	6c69622f 	ncget	r3, rfsl15
    1010:	6f732f75 	ecaget	r27, rfsl5
    1014:	435f4f53 		r26, r31, r9
    1018:	2d49495f 	rsubic	r10, r9, 18783
    101c:	76325f39 		r17, r18, r11
    1020:	302f6f73 	addik	r1, r15, 28531
    1024:	5f636f72 		r27, r3, r13
    1028:	652e6300 	bsrai	r9, r14, 0
    102c:	4f53546d 	eaputd	r19, r10
    1030:	72456e74 		r18, r5, r13
    1034:	72696573 		r19, r9, r12
    1038:	004f5351 		r2, r15, r10
    103c:	50747200 		r3, r20, r14
    1040:	4f534d65 	ecaputd	r19, r9
    1044:	6d4e616d 	ncget	r10, rfsl13
    1048:	65007469 	bslli	r8, r0, 9
    104c:	6d656f75 	necaget	r11, rfsl5
    1050:	74004f53 		r0, r0, r9
    1054:	496e6974 		r11, r14, r13
    1058:	004f5354 		r2, r15, r10
    105c:	61736b43 	muli	r11, r19, 27459
    1060:	7472004f 		r3, r18, r0
    1064:	53544342 		r26, r20, r8
    1068:	48696768 		r3, r9, r12
    106c:	52647900 		r19, r4, r15
    1070:	706e616d 		r3, r14, r12
    1074:	65004f53 		r8, r0, r9
    1078:	5f496e69 		r26, r9, r13
    107c:	74457665 		r2, r5, r14
    1080:	6e744c69 	neaget	r19, rfsl9
    1084:	7374004f 		r27, r20, r0
    1088:	53437478 		r26, r3, r14
    108c:	53774374 		r27, r23, r8
    1090:	72004f53 		r16, r0, r9
    1094:	5f496e69 		r26, r9, r13
    1098:	74546173 		r2, r20, r12
    109c:	6b537461 		r26, r19, r14
    10a0:	74004f53 		r0, r0, r9
    10a4:	556e4d61 		r11, r14, r9
    10a8:	7054626c 		r2, r20, r12
    10ac:	004f5346 		r2, r15, r10
    10b0:	72656500 		r19, r5, r12
    10b4:	4f535f45 	ncaputd	r19, r11
    10b8:	56454e54 		r18, r5, r9
    10bc:	006f735f 		r3, r15, r14
    10c0:	746d7200 		r3, r13, r14
    10c4:	4f53546d 	eaputd	r19, r10
    10c8:	7243616c 		r18, r3, r12
    10cc:	6c626163 	ncget	r3, rfsl3
    10d0:	6b417267 		r26, r1, r14
    10d4:	004f5354 		r2, r15, r10
    10d8:	6d725365 	tnget	r11, rfsl5
    10dc:	6d004f53 	neaget	r8, rfsl3
    10e0:	51537461 		r10, r19, r14
    10e4:	7274004f 		r19, r20, r0
    10e8:	53546d72 		r26, r20, r13
    10ec:	4d617463 	eaputd	r1, r14
    10f0:	68004f53 		r0, r0, r9
    10f4:	53636865 		r27, r3, r13
    10f8:	64556e6c 		r2, r21, r13
    10fc:	6f636b00 	ncaget	r27, rfsl0
    1100:	73746570 		r27, r20, r12
    1104:	004f535f 		r2, r15, r10
    1108:	4350555f 		r26, r16, r10
    110c:	5352004f 		r26, r18, r0
    1110:	53466c61 		r26, r6, r13
    1114:	674e6f64 		r26, r14, r13
    1118:	65466c61 	bslli	r10, r6, 1
    111c:	6773004f 	bsrli	r27, r19, 15
    1120:	5349646c 		r26, r9, r12
    1124:	65437472 	bslli	r10, r3, 18
    1128:	4d617800 	getd	r11, r15
    112c:	4f535443 	aputd	r19, r10
    1130:	42466c61 		r18, r6, r13
    1134:	67735264 	bsrai	r27, r19, 4
    1138:	79007374 		r8, r0, r14
    113c:	6b5f7369 		r26, r31, r14
    1140:	7a65004f 		r19, r5, r0
    1144:	53546d72 		r26, r20, r13
    1148:	54797065 		r3, r25, r14
    114c:	004f534d 		r2, r15, r10
    1150:	656d4e42 		r11, r13, r9
    1154:	6c6b7300 	tncget	r3, rfsl0
    1158:	4f535f45 	ncaputd	r19, r11
    115c:	76656e74 		r19, r5, r13
    1160:	5461736b 		r3, r1, r14
    1164:	57616974 		r27, r1, r13
    1168:	004f5345 		r2, r15, r10
    116c:	76656e74 		r19, r5, r13
    1170:	436e7400 		r27, r14, r14
    1174:	4f535443 	aputd	r19, r10
    1178:	4253746b 		r18, r19, r14
    117c:	42617365 		r19, r1, r14
    1180:	004f5345 		r2, r15, r10
    1184:	76656e74 		r19, r5, r13
    1188:	4e616d65 	ecaputd	r1, r13
    118c:	53657400 		r27, r5, r14
    1190:	4f535145 	cagetd	r26, r10
    1194:	6e64004f 	get	r19, rfsl15
    1198:	535f464c 		r26, r31, r8
    119c:	41475f47 		r10, r7, r11
    11a0:	5250004f 		r18, r16, r0
    11a4:	53544342 		r26, r20, r8
    11a8:	4c697374 	necagetd	r3, r14
    11ac:	004f5354 		r2, r15, r10
    11b0:	43424578 		r26, r2, r8
    11b4:	74507472 		r2, r16, r14
    11b8:	004f5354 		r2, r15, r10
    11bc:	43424f70 		r26, r2, r9
    11c0:	74004f53 		r0, r0, r9
    11c4:	5f544342 		r26, r20, r8
    11c8:	004f5354 		r2, r15, r10
    11cc:	43424375 		r26, r2, r8
    11d0:	72004f53 		r16, r0, r9
    11d4:	466c6167 	bsrl	r19, r12, r12
    11d8:	54797065 		r3, r25, r14
    11dc:	004f535f 		r2, r15, r10
    11e0:	4d656d43 	caputd	r5, r13
    11e4:	6c72004f 	get	r3, rfsl15
    11e8:	53466c61 		r26, r6, r13
    11ec:	6754626c 	bsrai	r26, r20, 12
    11f0:	004f5354 		r2, r15, r10
    11f4:	4342466c 		r26, r2, r8
    11f8:	61674e6f 	muli	r11, r7, 20079
    11fc:	6465004f 	bsrli	r3, r5, 15
    1200:	53546d72 		r26, r20, r13
    1204:	50657269 		r3, r5, r14
    1208:	6f64004f 	get	r27, rfsl15
    120c:	53557365 		r26, r21, r14
    1210:	64004f53 		r0, r0, r9
    1214:	54434246 		r2, r3, r8
    1218:	7265654c 		r19, r5, r12
    121c:	69737400 		r11, r19, r14
    1220:	4f535f54 	ncaputd	r19, r11
    1224:	4d525f57 	ncaputd	r18, r11
    1228:	4845454c 		r2, r5, r8
    122c:	004f5345 		r2, r15, r10
    1230:	76656e74 		r19, r5, r13
    1234:	46726565 	bsll	r19, r18, r12
    1238:	4c697374 	necagetd	r3, r14
    123c:	004f5354 		r2, r15, r10
    1240:	6d724672 	neget	r11, rfsl2
    1244:	65654c69 	bslli	r11, r5, 9
    1248:	73740070 		r27, r20, r0
    124c:	656e645f 	bslli	r11, r14, 31
    1250:	73746174 		r27, r20, r12
    1254:	004f534d 		r2, r15, r10
    1258:	656d4164 	bsrli	r11, r13, 4
    125c:	6472004f 	bsrli	r3, r18, 15
    1260:	535f4d65 		r26, r31, r9
    1264:	6d436f70 	necaget	r10, rfsl0
    1268:	79004f53 		r8, r0, r9
    126c:	5f457665 		r26, r5, r14
    1270:	6e745761 	tneget	r19, rfsl1
    1274:	69744c69 		r11, r20, r9
    1278:	7374496e 		r27, r20, r9
    127c:	6974004f 		r11, r20, r0
    1280:	53466c61 		r26, r6, r13
    1284:	674e6f64 		r26, r14, r13
    1288:	65576169 	bsrli	r10, r23, 9
    128c:	74547970 		r2, r20, r15
    1290:	65006f73 		r8, r0, r13
    1294:	5f6d656d 		r27, r13, r12
    1298:	004f5354 		r2, r15, r10
    129c:	43425374 		r26, r2, r10
    12a0:	6b426f74 		r26, r2, r13
    12a4:	746f6d00 		r3, r15, r13
    12a8:	70657665 		r3, r5, r14
    12ac:	6e74735f 	tncget	r19, rfsl15
    12b0:	77616974 		r27, r1, r13
    12b4:	004f5343 		r2, r15, r10
    12b8:	50555573 		r2, r21, r10
    12bc:	61676500 	muli	r11, r7, 25856
    12c0:	4f53546d 	eaputd	r19, r10
    12c4:	72546173 		r18, r20, r12
    12c8:	6b53746b 		r26, r19, r14
    12cc:	00707463 		r3, r16, r14
    12d0:	6231004f 	muli	r17, r17, 79
    12d4:	53546d72 		r26, r20, r13
    12d8:	46697273 	bsra	r19, r9, r14
    12dc:	74004f53 		r0, r0, r9
    12e0:	546d724f 		r3, r13, r14
    12e4:	7074004f 		r3, r20, r0
    12e8:	53514f75 		r26, r17, r9
    12ec:	74004f53 		r0, r0, r9
    12f0:	5469636b 		r3, r9, r12
    12f4:	53746570 		r27, r20, r12
    12f8:	53746174 		r27, r20, r12
    12fc:	65004f53 		r8, r0, r9
    1300:	496e744e 		r11, r14, r14
    1304:	65737469 	bslli	r11, r19, 9
    1308:	6e67004f 	get	r19, rfsl15
    130c:	5349646c 		r26, r9, r12
    1310:	65437472 	bslli	r10, r3, 18
    1314:	004f5354 		r2, r15, r10
    1318:	696d6554 		r11, r13, r12
    131c:	69636b00 		r11, r3, r13
    1320:	4f535264 	neagetd	r26, r10
    1324:	79477270 		r10, r7, r14
    1328:	00706578 		r3, r16, r12
    132c:	74004f53 		r0, r0, r9
    1330:	5461736b 		r3, r1, r14
    1334:	53746174 		r27, r20, r12
    1338:	53746b00 		r27, r20, r13
    133c:	4f535443 	aputd	r19, r10
    1340:	42526567 		r18, r18, r12
    1344:	54626c00 		r3, r2, r13
    1348:	4f535f45 	ncaputd	r19, r11
    134c:	76656e74 		r19, r5, r13
    1350:	5461736b 		r3, r1, r14
    1354:	52647900 		r19, r4, r15
    1358:	4f535374 	necagetd	r26, r10
    135c:	61745264 	muli	r11, r20, 21092
    1360:	79004f53 		r8, r0, r9
    1364:	54434258 		r2, r3, r8
    1368:	004f5354 		r2, r15, r10
    136c:	43425900 		r26, r2, r11
    1370:	4f535443 	aputd	r19, r10
    1374:	42457665 		r18, r5, r14
    1378:	6e745074 	tnget	r19, rfsl4
    137c:	72004f53 		r16, r0, r9
    1380:	54434250 		r2, r3, r8
    1384:	72696f00 		r19, r9, r13
    1388:	4f535443 	aputd	r19, r10
    138c:	42457665 		r18, r5, r14
    1390:	6e744d75 	neaget	r19, rfsl5
    1394:	6c746950 	ncaget	r3, rfsl0
    1398:	7472004f 		r3, r18, r0
    139c:	53546d72 		r26, r20, r13
    13a0:	50726576 		r3, r18, r12
    13a4:	004f5354 		r2, r15, r10
    13a8:	43425462 		r26, r2, r10
    13ac:	6c004f53 	neaget	r0, rfsl3
    13b0:	4c6f636b 	necagetd	r3, r12
    13b4:	4e657374 	necagetd	r19, r14
    13b8:	696e6700 		r11, r14, r12
    13bc:	4f53546d 	eaputd	r19, r10
    13c0:	72537461 		r18, r19, r14
    13c4:	7465004f 		r3, r5, r0
    13c8:	53466c61 		r26, r6, r13
    13cc:	67576169 	bsrli	r26, r23, 9
    13d0:	744c6973 		r2, r12, r13
    13d4:	74007265 		r0, r0, r14
    13d8:	73756c74 		r27, r21, r13
    13dc:	00706e6f 		r3, r16, r13
    13e0:	6465004f 	bsrli	r3, r5, 15
    13e4:	535f466c 		r26, r31, r8
    13e8:	6167556e 	muli	r11, r7, 21870
    13ec:	6c696e6b 	necaget	r3, rfsl11
    13f0:	004f535f 		r2, r15, r10
    13f4:	466c6167 	bsrl	r19, r12, r12
    13f8:	496e6974 		r11, r14, r13
    13fc:	00666c61 		r3, r6, r13
    1400:	67735f72 		r27, r19, r11
    1404:	6479004f 	bsrli	r3, r25, 15
    1408:	53466c61 		r26, r6, r13
    140c:	674e616d 	bsrli	r26, r14, 13
    1410:	65476574 	bslli	r10, r7, 20
    1414:	00636f6e 		r3, r3, r13
    1418:	73756d65 		r27, r21, r13
    141c:	004f535f 		r2, r15, r10
    1420:	466c6167 	bsrl	r19, r12, r12
    1424:	426c6f63 		r19, r12, r13
    1428:	6b007067 		r24, r0, r14
    142c:	72705f72 		r19, r16, r11
    1430:	65747572 	bslli	r11, r20, 18
    1434:	6e002e2e 	ecaget	r16, rfsl14
    1438:	2f2e2e2f 	rsubic	r25, r14, 11823
    143c:	6c69622f 	ncget	r3, rfsl15
    1440:	6f732f75 	ecaget	r27, rfsl5
    1444:	435f4f53 		r26, r31, r9
    1448:	2d49495f 	rsubic	r10, r9, 18783
    144c:	76325f39 		r17, r18, r11
    1450:	302f6f73 	addik	r1, r15, 28531
    1454:	5f666c61 		r27, r6, r13
    1458:	672e6300 	bsrai	r25, r14, 0
    145c:	666c6167 	bsrli	r19, r12, 7
    1460:	7300706e 		r24, r0, r14
    1464:	6f64655f 	necget	r27, rfsl15
    1468:	70726576 		r3, r18, r12
    146c:	00666c61 		r3, r6, r13
    1470:	67735f63 		r27, r19, r11
    1474:	75720070 		r11, r18, r0
    1478:	6e6f6465 	necget	r19, rfsl5
    147c:	5f6e6578 		r27, r14, r12
    1480:	74004f53 		r0, r0, r9
    1484:	466c6167 	bsrl	r19, r12, r12
    1488:	43726561 		r27, r18, r12
    148c:	7465004f 		r3, r5, r0
    1490:	53466c61 		r26, r6, r13
    1494:	67506f73 		r26, r16, r13
    1498:	74004f53 		r0, r0, r9
    149c:	5f466c61 		r26, r6, r13
    14a0:	67546173 	bsrli	r26, r20, 19
    14a4:	6b526479 		r26, r18, r12
    14a8:	00706772 		r3, r16, r12
    14ac:	70004f53 		r0, r0, r9
    14b0:	466c6167 	bsrl	r19, r12, r12
    14b4:	41636365 		r11, r3, r12
    14b8:	70740077 		r3, r20, r0
    14bc:	6169745f 	muli	r11, r9, 29791
    14c0:	74797065 		r3, r25, r14
    14c4:	00736368 		r3, r19, r12
    14c8:	6564004f 	bsrli	r11, r4, 15
    14cc:	53466c61 		r26, r6, r13
    14d0:	6750656e 	bslli	r26, r16, 14
    14d4:	64007067 	bsrli	r0, r0, 7
    14d8:	72703100 		r19, r16, r6
    14dc:	70677270 		r3, r7, r14
    14e0:	32004f53 	addik	r16, r0, 20307
    14e4:	466c6167 	bsrl	r19, r12, r12
    14e8:	4e616d65 	ecaputd	r1, r13
    14ec:	53657400 		r27, r5, r14
    14f0:	4f53466c 	neaputd	r19, r8
    14f4:	61675175 	muli	r11, r7, 20853
    14f8:	65727900 	bsrli	r11, r18, 0
    14fc:	7461736b 		r3, r1, r14
    1500:	735f7761 		r26, r31, r14
    1504:	6974696e 		r11, r20, r13
    1508:	67004f53 		r24, r0, r9
    150c:	466c6167 	bsrl	r19, r12, r12
    1510:	44656c00 	bsll	r3, r5, r13
    1514:	4f53466c 	neaputd	r19, r8
    1518:	61675065 	muli	r11, r7, 20581
    151c:	6e644765 	neget	r19, rfsl5
    1520:	74466c61 		r2, r6, r13
    1524:	67735264 	bsrai	r27, r19, 4
    1528:	79004f53 		r8, r0, r9
    152c:	4d626f78 	necaputd	r2, r13
    1530:	43726561 		r27, r18, r12
    1534:	74650070 		r3, r5, r0
    1538:	6576656e 	bslli	r11, r22, 14
    153c:	745f7265 		r2, r31, r14
    1540:	7475726e 		r3, r21, r14
    1544:	004f534d 		r2, r15, r10
    1548:	626f7850 	muli	r19, r15, 30800
    154c:	656e6400 	bslli	r11, r14, 0
    1550:	4f534d62 	ecaputd	r19, r9
    1554:	6f78506f 	tnget	r27, rfsl15
    1558:	73744f70 		r27, r20, r9
    155c:	7400705f 		r0, r0, r14
    1560:	6d626f78 	necaget	r11, rfsl8
    1564:	5f646174 		r27, r4, r12
    1568:	61004f53 	muli	r8, r0, 20307
    156c:	5f4d424f 		r26, r13, r8
    1570:	585f4441 		r2, r31, r8
    1574:	5441004f 		r2, r1, r0
    1578:	534d7367 		r26, r13, r14
    157c:	006f735f 		r3, r15, r14
    1580:	6d626f78 	necaget	r11, rfsl8
    1584:	5f646174 		r27, r4, r12
    1588:	61004f53 	muli	r8, r0, 20307
    158c:	4d626f78 	necaputd	r2, r13
    1590:	50656e64 		r3, r5, r13
    1594:	41626f72 		r11, r2, r13
    1598:	74004f53 		r0, r0, r9
    159c:	4d626f78 	necaputd	r2, r13
    15a0:	41636365 		r11, r3, r12
    15a4:	7074004f 		r3, r20, r0
    15a8:	534d626f 		r26, r13, r12
    15ac:	78517565 		r2, r17, r14
    15b0:	7279004f 		r19, r25, r0
    15b4:	534d626f 		r26, r13, r12
    15b8:	7844656c 		r2, r4, r12
    15bc:	006e6272 		r3, r14, r12
    15c0:	5f746173 		r27, r20, r12
    15c4:	6b73004f 		r27, r19, r0
    15c8:	534d626f 		r26, r13, r12
    15cc:	78506f73 		r2, r16, r13
    15d0:	74002e2e 		r0, r0, r5
    15d4:	2f2e2e2f 	rsubic	r25, r14, 11823
    15d8:	6c69622f 	ncget	r3, rfsl15
    15dc:	6f732f75 	ecaget	r27, rfsl5
    15e0:	435f4f53 		r26, r31, r9
    15e4:	2d49495f 	rsubic	r10, r9, 18783
    15e8:	76325f39 		r17, r18, r11
    15ec:	302f6f73 	addik	r1, r15, 28531
    15f0:	5f6d626f 		r27, r13, r12
    15f4:	782e6300 		r1, r14, r12
    15f8:	4f535f4d 	ncaputd	r19, r11
    15fc:	656d496e 	bsrli	r11, r13, 14
    1600:	6974004f 		r11, r20, r0
    1604:	534d656d 		r26, r13, r12
    1608:	4e616d65 	ecaputd	r1, r13
    160c:	47657400 	bsll	r27, r5, r14
    1610:	4f534e42 	naputd	r19, r9
    1614:	6c6b7300 	tncget	r3, rfsl0
    1618:	61646472 	muli	r11, r4, 25714
    161c:	006f735f 		r3, r15, r14
    1620:	6d656d5f 	necaget	r11, rfsl15
    1624:	64617461 	bslli	r3, r1, 1
    1628:	004f5342 		r2, r15, r10
    162c:	6c6b5369 	tnget	r3, rfsl9
    1630:	7a650070 		r19, r5, r0
    1634:	5f6d656d 		r27, r13, r12
    1638:	5f646174 		r27, r4, r12
    163c:	61004f53 	muli	r8, r0, 20307
    1640:	4d656d47 	caputd	r5, r13
    1644:	6574006e 	bsrli	r11, r20, 14
    1648:	626c6b73 	muli	r19, r12, 27507
    164c:	002e2e2f 		r1, r14, r5
    1650:	2e2e2f6c 	rsubic	r17, r14, 12140
    1654:	69622f6f 		r11, r2, r5
    1658:	732f7543 		r25, r15, r14
    165c:	5f4f532d 		r26, r15, r10
    1660:	49495f76 		r10, r9, r11
    1664:	325f3930 	addik	r18, r31, 14640
    1668:	2f6f735f 	rsubic	r27, r15, 29535
    166c:	6d656d2e 	necaget	r11, rfsl14
    1670:	6300626c 	muli	r24, r0, 25196
    1674:	6b73697a 		r27, r19, r13
    1678:	65007062 	bsrli	r8, r0, 2
    167c:	6c6b004f 	get	r3, rfsl15
    1680:	53467265 		r26, r6, r14
    1684:	654c6973 	bsrli	r10, r12, 19
    1688:	74004f53 		r0, r0, r9
    168c:	4d656d43 	caputd	r5, r13
    1690:	72656174 		r19, r5, r12
    1694:	65004f53 		r8, r0, r9
    1698:	5f4d454d 		r26, r13, r8
    169c:	5f444154 		r26, r4, r8
    16a0:	41004f53 		r8, r0, r9
    16a4:	4e557365 	necagetd	r18, r14
    16a8:	64004f53 		r0, r0, r9
    16ac:	41646472 		r11, r4, r12
    16b0:	004f534d 		r2, r15, r10
    16b4:	656d4e61 		r11, r13, r9
    16b8:	6d655365 	tnget	r11, rfsl5
    16bc:	74004f53 		r0, r0, r9
    16c0:	4d656d51 	caputd	r5, r13
    16c4:	75657279 		r11, r5, r14
    16c8:	004f534d 		r2, r15, r10
    16cc:	656d5075 	bsrli	r11, r13, 21
    16d0:	7400706c 		r0, r0, r14
    16d4:	696e6b00 		r11, r14, r13
    16d8:	4f534e46 	naputd	r19, r9
    16dc:	72656500 		r19, r5, r12
    16e0:	4f534f77 	necaputd	r19, r9
    16e4:	6e657250 	tncget	r19, rfsl0
    16e8:	72696f00 		r19, r9, r13
    16ec:	705f6d75 		r2, r31, r13
    16f0:	7465785f 		r3, r5, r15
    16f4:	64617461 	bslli	r3, r1, 1
    16f8:	004f535f 		r2, r15, r10
    16fc:	4d555445 	aputd	r21, r10
    1700:	585f4441 		r2, r31, r8
    1704:	5441004f 		r2, r1, r0
    1708:	534d7574 		r26, r13, r14
    170c:	65785175 	bsrli	r11, r24, 21
    1710:	65727900 	bsrli	r11, r18, 0
    1714:	4f534d75 	ecaputd	r19, r9
    1718:	74657850 		r3, r5, r15
    171c:	6f737400 	tnecget	r27, rfsl0
    1720:	4f534d75 	ecaputd	r19, r9
    1724:	74657843 		r3, r5, r15
    1728:	72656174 		r19, r5, r12
    172c:	65002e2e 		r8, r0, r5
    1730:	2f2e2e2f 	rsubic	r25, r14, 11823
    1734:	6c69622f 	ncget	r3, rfsl15
    1738:	6f732f75 	ecaget	r27, rfsl5
    173c:	435f4f53 		r26, r31, r9
    1740:	2d49495f 	rsubic	r10, r9, 18783
    1744:	76325f39 		r17, r18, r11
    1748:	302f6f73 	addik	r1, r15, 28531
    174c:	5f6d7574 		r27, r13, r14
    1750:	65782e63 		r11, r24, r5
    1754:	004f534d 		r2, r15, r10
    1758:	75746578 		r11, r20, r12
    175c:	50656e64 		r3, r5, r13
    1760:	006d7072 		r3, r13, r14
    1764:	696f006f 		r11, r15, r0
    1768:	735f6d75 		r26, r31, r13
    176c:	7465785f 		r3, r5, r15
    1770:	64617461 	bslli	r3, r1, 1
    1774:	004f534d 		r2, r15, r10
    1778:	75746578 		r11, r20, r12
    177c:	50495000 		r2, r9, r10
    1780:	4f534d75 	ecaputd	r19, r9
    1784:	74657844 		r3, r5, r15
    1788:	656c004f 	bsrli	r11, r12, 15
    178c:	534d7574 		r26, r13, r14
    1790:	65784163 	bsrli	r11, r24, 3
    1794:	63657074 	muli	r27, r5, 28788
    1798:	004f5356 		r2, r15, r10
    179c:	616c7565 	muli	r11, r12, 30053
    17a0:	004f534d 		r2, r15, r10
    17a4:	75746578 		r11, r20, r12
    17a8:	5f526479 		r26, r18, r12
    17ac:	41745072 		r11, r20, r10
    17b0:	696f004f 		r11, r15, r0
    17b4:	53515065 		r26, r17, r10
    17b8:	6e64004f 	get	r19, rfsl15
    17bc:	5351506f 		r26, r17, r10
    17c0:	73744672 		r27, r20, r8
    17c4:	6f6e7400 	tnecget	r27, rfsl0
    17c8:	4f535f51 	ncaputd	r19, r11
    17cc:	5f444154 		r26, r4, r8
    17d0:	41004f53 		r8, r0, r9
    17d4:	5f51496e 		r26, r17, r9
    17d8:	6974004f 		r11, r20, r0
    17dc:	53515175 		r26, r17, r10
    17e0:	65727900 	bsrli	r11, r18, 0
    17e4:	6f735f71 	tneaget	r27, rfsl1
    17e8:	5f646174 		r27, r4, r12
    17ec:	61004f53 	muli	r8, r0, 20307
    17f0:	51437265 		r10, r3, r14
    17f4:	61746500 	muli	r11, r20, 25856
    17f8:	4f534e4d 	naputd	r19, r9
    17fc:	73677300 		r27, r7, r14
    1800:	4f535150 	cagetd	r26, r10
    1804:	656e6441 	bslli	r11, r14, 1
    1808:	626f7274 	muli	r19, r15, 29300
    180c:	004f5351 		r2, r15, r10
    1810:	506f7374 		r3, r15, r14
    1814:	4f707400 	putd	r16, r14
    1818:	4f535146 	cagetd	r26, r10
    181c:	6c757368 	tncget	r3, rfsl8
    1820:	004f5351 		r2, r15, r10
    1824:	41636365 		r11, r3, r12
    1828:	70740073 		r3, r20, r0
    182c:	74617274 		r3, r1, r14
    1830:	004f5351 		r2, r15, r10
    1834:	506f7374 		r3, r15, r14
    1838:	00705f71 		r3, r16, r11
    183c:	5f646174 		r27, r4, r12
    1840:	61002e2e 	muli	r8, r0, 11822
    1844:	2f2e2e2f 	rsubic	r25, r14, 11823
    1848:	6c69622f 	ncget	r3, rfsl15
    184c:	6f732f75 	ecaget	r27, rfsl5
    1850:	435f4f53 		r26, r31, r9
    1854:	2d49495f 	rsubic	r10, r9, 18783
    1858:	76325f39 		r17, r18, r11
    185c:	302f6f73 	addik	r1, r15, 28531
    1860:	5f712e63 		r27, r17, r5
    1864:	004f5351 		r2, r15, r10
    1868:	44656c00 	bsll	r3, r5, r13
    186c:	4f535365 	necagetd	r26, r10
    1870:	6d506f73 	necaget	r10, rfsl3
    1874:	74004f53 		r0, r0, r9
    1878:	53656d53 		r27, r5, r13
    187c:	6574004f 	bsrli	r11, r20, 15
    1880:	5353656d 		r26, r19, r12
    1884:	41636365 		r11, r3, r12
    1888:	7074004f 		r3, r20, r0
    188c:	535f5345 		r26, r31, r10
    1890:	4d5f4441 	aputd	r31, r8
    1894:	5441004f 		r2, r1, r0
    1898:	53436e74 		r26, r3, r13
    189c:	004f5353 		r2, r15, r10
    18a0:	656d4372 	bsrai	r11, r13, 18
    18a4:	65617465 	bslli	r11, r1, 5
    18a8:	004f5353 		r2, r15, r10
    18ac:	656d5175 	bsrli	r11, r13, 21
    18b0:	65727900 	bsrli	r11, r18, 0
    18b4:	4f535365 	necagetd	r26, r10
    18b8:	6d44656c 	necget	r10, rfsl12
    18bc:	004f5353 		r2, r15, r10
    18c0:	656d5065 	bsrli	r11, r13, 5
    18c4:	6e644162 	nget	r19, rfsl2
    18c8:	6f727400 	tnecget	r27, rfsl0
    18cc:	2e2e2f2e 	rsubic	r17, r14, 12078
    18d0:	2e2f6c69 	rsubic	r17, r15, 27753
    18d4:	622f6f73 	muli	r17, r15, 28531
    18d8:	2f75435f 	rsubic	r27, r21, 17247
    18dc:	4f532d49 	caputd	r19, r5
    18e0:	495f7632 		r10, r31, r14
    18e4:	5f39302f 		r25, r25, r6
    18e8:	6f735f73 	tneaget	r27, rfsl3
    18ec:	656d2e63 		r11, r13, r5
    18f0:	004f5353 		r2, r15, r10
    18f4:	656d5065 	bsrli	r11, r13, 5
    18f8:	6e64006f 	get	r19, rfsl15
    18fc:	735f7365 		r26, r31, r14
    1900:	6d5f6461 	necget	r10, rfsl1
    1904:	74610070 		r3, r1, r0
    1908:	5f73656d 		r27, r19, r12
    190c:	5f646174 		r27, r4, r12
    1910:	61004f53 	muli	r8, r0, 20307
    1914:	5461736b 		r3, r1, r14
    1918:	43726561 		r27, r18, r12
    191c:	7465004f 		r3, r5, r0
    1920:	535f5461 		r26, r31, r10
    1924:	736b5265 		r27, r11, r10
    1928:	7475726e 		r3, r21, r14
    192c:	004f5354 		r2, r15, r10
    1930:	61736b52 	muli	r11, r19, 27474
    1934:	6573756d 	bslli	r11, r19, 13
    1938:	65002e2e 		r8, r0, r5
    193c:	2f2e2e2f 	rsubic	r25, r14, 11823
    1940:	6c69622f 	ncget	r3, rfsl15
    1944:	6f732f75 	ecaget	r27, rfsl5
    1948:	435f4f53 		r26, r31, r9
    194c:	2d49495f 	rsubic	r10, r9, 18783
    1950:	76325f39 		r17, r18, r11
    1954:	302f6f73 	addik	r1, r15, 28531
    1958:	5f746173 		r27, r20, r12
    195c:	6b2e6300 		r25, r14, r12
    1960:	4f535f54 	ncaputd	r19, r11
    1964:	61736b53 	muli	r11, r19, 27475
    1968:	746b436c 		r3, r11, r8
    196c:	72006269 		r16, r0, r12
    1970:	74795f6e 		r3, r25, r11
    1974:	6577006e 	bsrli	r11, r23, 14
    1978:	66726565 	bslli	r19, r18, 5
    197c:	004f5354 		r2, r15, r10
    1980:	61736b44 	muli	r11, r19, 27460
    1984:	656c0073 	bsrli	r11, r12, 19
    1988:	656c6600 		r11, r12, r12
    198c:	705f7374 		r2, r31, r14
    1990:	6b5f6461 		r26, r31, r12
    1994:	7461004f 		r3, r1, r0
    1998:	53546173 		r26, r20, r12
    199c:	6b437265 		r26, r3, r14
    19a0:	61746545 	muli	r11, r20, 25925
    19a4:	7874004f 		r3, r20, r0
    19a8:	53546173 		r26, r20, r12
    19ac:	6b436861 		r26, r3, r13
    19b0:	6e676550 	necget	r19, rfsl0
    19b4:	72696f00 		r19, r9, r13
    19b8:	76616c75 		r19, r1, r13
    19bc:	6500705f 	bsrli	r8, r0, 31
    19c0:	7461736b 		r3, r1, r14
    19c4:	5f646174 		r27, r4, r12
    19c8:	61006e65 	muli	r8, r0, 28261
    19cc:	77707269 		r27, r16, r14
    19d0:	6f006f6c 	necaget	r24, rfsl12
    19d4:	64707269 	bsrai	r3, r16, 9
    19d8:	6f004f53 	neaget	r24, rfsl3
    19dc:	5461736b 		r3, r1, r14
    19e0:	44656c52 	bsll	r3, r5, r13
    19e4:	65710062 	bsrli	r11, r17, 2
    19e8:	6974785f 		r11, r20, r15
    19ec:	6e657700 	tnecget	r19, rfsl0
    19f0:	4f535461 	eaputd	r19, r10
    19f4:	736b5265 		r27, r11, r10
    19f8:	67536574 	bslli	r26, r19, 20
    19fc:	004f5354 		r2, r15, r10
    1a00:	61736b51 	muli	r11, r19, 27473
    1a04:	75657279 		r11, r5, r14
    1a08:	00626974 		r3, r2, r13
    1a0c:	785f6f6c 		r2, r31, r13
    1a10:	64007063 	bsrli	r0, r0, 3
    1a14:	686b004f 		r3, r11, r0
    1a18:	53546173 		r26, r20, r12
    1a1c:	6b526567 		r26, r18, r12
    1a20:	47657400 	bsll	r27, r5, r14
    1a24:	4f535461 	eaputd	r19, r10
    1a28:	736b4e61 		r27, r11, r9
    1a2c:	6d655365 	tnget	r11, rfsl5
    1a30:	74004f53 		r0, r0, r9
    1a34:	5461736b 		r3, r1, r14
    1a38:	53757370 		r27, r21, r14
    1a3c:	656e6400 	bslli	r11, r14, 0
    1a40:	7461736b 		r3, r1, r14
    1a44:	00626974 		r3, r2, r13
    1a48:	795f6f6c 		r10, r31, r13
    1a4c:	64004f53 		r0, r0, r9
    1a50:	5461736b 		r3, r1, r14
    1a54:	4e616d65 	ecaputd	r1, r13
    1a58:	47657400 	bsll	r27, r5, r14
    1a5c:	4f535461 	eaputd	r19, r10
    1a60:	736b5374 		r27, r11, r10
    1a64:	6b43686b 		r26, r3, r13
    1a68:	00746963 		r3, r20, r13
    1a6c:	6b73004f 		r27, r19, r0
    1a70:	5354696d 		r26, r20, r13
    1a74:	65446c79 	bslli	r10, r4, 25
    1a78:	004f5354 		r2, r15, r10
    1a7c:	696d6544 		r11, r13, r12
    1a80:	6c795265 	tnget	r3, rfsl5
    1a84:	73756d65 		r27, r21, r13
    1a88:	004f5354 		r2, r15, r10
    1a8c:	696d6544 		r11, r13, r12
    1a90:	6c79484d 	naget	r3, rfsl13
    1a94:	534d002e 		r26, r13, r0
    1a98:	2e2f2e2e 	rsubic	r17, r15, 11822
    1a9c:	2f6c6962 	rsubic	r27, r12, 26978
    1aa0:	2f6f732f 	rsubic	r27, r15, 29487
    1aa4:	75435f4f 		r10, r3, r11
    1aa8:	532d4949 		r25, r13, r9
    1aac:	5f76325f 		r27, r22, r6
    1ab0:	39302f6f 	addikc	r9, r16, 12143
    1ab4:	735f7469 		r26, r31, r14
    1ab8:	6d652e63 	ecaget	r11, rfsl3
    1abc:	00736563 		r3, r19, r12
    1ac0:	6f6e6473 	necget	r27, rfsl3
    1ac4:	00686f75 		r3, r8, r13
    1ac8:	7273006d 		r19, r19, r0
    1acc:	696e7574 		r11, r14, r14
    1ad0:	6573004f 	bsrli	r11, r19, 15
    1ad4:	5354696d 		r26, r20, r13
    1ad8:	65476574 	bslli	r10, r7, 20
    1adc:	004f5354 		r2, r15, r10
    1ae0:	696d6553 		r11, r13, r12
    1ae4:	6574004f 	bsrli	r11, r20, 15
    1ae8:	53546d72 		r26, r20, r13
    1aec:	43726561 		r27, r18, r12
    1af0:	7465004f 		r3, r5, r0
    1af4:	53546d72 		r26, r20, r13
    1af8:	53746174 		r27, r20, r12
    1afc:	65476574 	bslli	r10, r7, 20
    1b00:	004f5354 		r2, r15, r10
    1b04:	6d725f49 	tneaget	r11, rfsl9
    1b08:	6e697454 	tnecget	r19, rfsl4
    1b0c:	61736b00 	muli	r11, r19, 27392
    1b10:	4f53546d 	eaputd	r19, r10
    1b14:	72536967 		r18, r19, r13
    1b18:	6e616c00 	necaget	r19, rfsl0
    1b1c:	4f53546d 	eaputd	r19, r10
    1b20:	7252656d 		r18, r18, r12
    1b24:	61696e47 	muli	r11, r9, 28231
    1b28:	65740070 	bsrli	r11, r20, 16
    1b2c:	73706f6b 		r27, r16, r13
    1b30:	65004f53 		r8, r0, r9
    1b34:	546d725f 		r3, r13, r14
    1b38:	46726565 	bsll	r19, r18, r12
    1b3c:	004f5354 		r2, r15, r10
    1b40:	6d725f4c 	tneaget	r11, rfsl12
    1b44:	696e6b00 		r11, r14, r13
    1b48:	4f53546d 	eaputd	r19, r10
    1b4c:	7244656c 		r18, r4, r12
    1b50:	0070746d 		r3, r16, r14
    1b54:	72310070 		r17, r17, r0
    1b58:	746d7232 		r3, r13, r14
    1b5c:	0070746d 		r3, r16, r14
    1b60:	725f6e65 		r18, r31, r13
    1b64:	7874004f 		r3, r20, r0
    1b68:	53546d72 		r26, r20, r13
    1b6c:	53746172 		r27, r20, r12
    1b70:	74002e2e 		r0, r0, r5
    1b74:	2f2e2e2f 	rsubic	r25, r14, 11823
    1b78:	6c69622f 	ncget	r3, rfsl15
    1b7c:	6f732f75 	ecaget	r27, rfsl5
    1b80:	435f4f53 		r26, r31, r9
    1b84:	2d49495f 	rsubic	r10, r9, 18783
    1b88:	76325f39 		r17, r18, r11
    1b8c:	302f6f73 	addik	r1, r15, 28531
    1b90:	5f746d72 		r27, r20, r13
    1b94:	2e630070 	rsubic	r19, r3, 112
    1b98:	6572696f 	bsrli	r11, r18, 15
    1b9c:	64004f53 		r0, r0, r9
    1ba0:	546d724e 		r3, r13, r14
    1ba4:	616d6547 	muli	r11, r13, 25927
    1ba8:	6574004f 	bsrli	r11, r20, 15
    1bac:	53546d72 		r26, r20, r13
    1bb0:	5f556e6c 		r26, r21, r13
    1bb4:	696e6b00 		r11, r14, r13
    1bb8:	4f53546d 	eaputd	r19, r10
    1bbc:	725f5461 		r18, r31, r10
    1bc0:	736b004f 		r27, r11, r0
    1bc4:	53546d72 		r26, r20, r13
    1bc8:	5f496e69 		r26, r9, r13
    1bcc:	74004f53 		r0, r0, r9
    1bd0:	546d725f 		r3, r13, r14
    1bd4:	416c6c6f 		r11, r12, r13
    1bd8:	63007374 	muli	r24, r0, 29556
    1bdc:	61746500 	muli	r11, r20, 25856
    1be0:	70746d72 		r3, r20, r13
    1be4:	0070666e 		r3, r16, r12
    1be8:	63740072 	muli	r27, r20, 114
    1bec:	656d6169 	bsrli	r11, r13, 9
    1bf0:	6e006361 	ncget	r16, rfsl1
    1bf4:	6c6c6261 	ncget	r3, rfsl1
    1bf8:	636b5f61 	muli	r27, r11, 24417
    1bfc:	7267004f 		r19, r7, r0
    1c00:	53546d72 		r26, r20, r13
    1c04:	53746f70 		r27, r20, r13
    1c08:	004f5354 		r2, r15, r10
    1c0c:	61736b49 	muli	r11, r19, 27465
    1c10:	646c6548 	bslli	r3, r12, 8
    1c14:	6f6f6b00 	ncaget	r27, rfsl0
    1c18:	4f535461 	eaputd	r19, r10
    1c1c:	736b5265 		r27, r11, r10
    1c20:	7475726e 		r3, r21, r14
    1c24:	486f6f6b 		r3, r15, r13
    1c28:	004f5354 		r2, r15, r10
    1c2c:	61736b53 	muli	r11, r19, 27475
    1c30:	77486f6f 		r26, r8, r13
    1c34:	6b004f53 		r24, r0, r9
    1c38:	5461736b 		r3, r1, r14
    1c3c:	53746b49 		r27, r20, r13
    1c40:	6e697400 	tnecget	r19, rfsl0
    1c44:	5f534441 		r26, r19, r8
    1c48:	5f424153 		r26, r2, r8
    1c4c:	455f004f 	bsrl	r10, r31, r0
    1c50:	53496e69 		r26, r9, r13
    1c54:	74486f6f 		r2, r8, r13
    1c58:	6b426567 		r26, r2, r12
    1c5c:	696e006d 		r11, r14, r0
    1c60:	73725f76 		r27, r18, r11
    1c64:	616c005f 	muli	r11, r12, 95
    1c68:	53444132 		r26, r4, r8
    1c6c:	5f424153 		r26, r2, r8
    1c70:	455f002e 	bsrl	r10, r31, r0
    1c74:	2e2f2e2e 	rsubic	r17, r15, 11822
    1c78:	2f6c6962 	rsubic	r27, r12, 26978
    1c7c:	2f6f732f 	rsubic	r27, r15, 29487
    1c80:	75435f4f 		r10, r3, r11
    1c84:	532d4949 		r25, r13, r9
    1c88:	5f76325f 		r27, r22, r6
    1c8c:	39302f4d 	addikc	r9, r16, 12109
    1c90:	6963726f 		r11, r3, r14
    1c94:	426c617a 		r19, r12, r12
    1c98:	652f6f73 		r9, r15, r13
    1c9c:	5f637075 		r27, r3, r14
    1ca0:	5f632e63 		r27, r3, r5
    1ca4:	004f5354 		r2, r15, r10
    1ca8:	4342496e 		r26, r2, r9
    1cac:	6974486f 		r11, r20, r9
    1cb0:	6f6b004f 	get	r27, rfsl15
    1cb4:	53546173 		r26, r20, r12
    1cb8:	6b44656c 		r26, r4, r12
    1cbc:	486f6f6b 		r3, r15, r13
    1cc0:	004f5354 		r2, r15, r10
    1cc4:	61736b53 	muli	r11, r19, 27475
    1cc8:	74617448 		r3, r1, r14
    1ccc:	6f6f6b00 	ncaget	r27, rfsl0
    1cd0:	4f535469 	eaputd	r19, r10
    1cd4:	6d655469 	tneget	r11, rfsl9
    1cd8:	636b486f 	muli	r27, r11, 18543
    1cdc:	6f6b004f 	get	r27, rfsl15
    1ce0:	53546173 		r26, r20, r12
    1ce4:	6b437265 		r26, r3, r14
    1ce8:	61746548 	muli	r11, r20, 25928
    1cec:	6f6f6b00 	ncaget	r27, rfsl0
    1cf0:	7073746b 		r3, r19, r14
    1cf4:	004f5349 		r2, r15, r10
    1cf8:	6e697448 	tnecget	r19, rfsl8
    1cfc:	6f6f6b45 	ncaget	r27, rfsl5
    1d00:	6e64002e 	get	r19, rfsl14
    1d04:	2e2f2e2e 	rsubic	r17, r15, 11822
    1d08:	2f6c6962 	rsubic	r27, r12, 26978
    1d0c:	2f6f732f 	rsubic	r27, r15, 29487
    1d10:	75435f4f 		r10, r3, r11
    1d14:	532d4949 		r25, r13, r9
    1d18:	5f76325f 		r27, r22, r6
    1d1c:	39302f4d 	addikc	r9, r16, 12109
    1d20:	6963726f 		r11, r3, r14
    1d24:	426c617a 		r19, r12, r12
    1d28:	652f6f73 		r9, r15, r13
    1d2c:	5f646267 		r27, r4, r12
    1d30:	2e63004f 	rsubic	r19, r3, 79
    1d34:	53546d72 		r26, r20, r13
    1d38:	54626c53 		r3, r2, r13
    1d3c:	697a6500 		r11, r26, r12
    1d40:	4f534461 	eaputd	r19, r8
    1d44:	74615369 		r3, r1, r10
    1d48:	7a65004f 		r19, r5, r0
    1d4c:	53446562 		r26, r4, r12
    1d50:	7567456e 		r11, r7, r8
    1d54:	004f5354 		r2, r15, r10
    1d58:	61736b53 	muli	r11, r19, 27475
    1d5c:	74617453 		r3, r1, r14
    1d60:	746b5369 		r3, r11, r10
    1d64:	7a65004f 		r19, r5, r0
    1d68:	53546173 		r26, r20, r12
    1d6c:	6b526567 		r26, r18, r12
    1d70:	54626c53 		r3, r2, r13
    1d74:	697a6500 		r11, r26, r12
    1d78:	4f534d65 	ecaputd	r19, r9
    1d7c:	6d456e00 	necaget	r10, rfsl0
    1d80:	4f535461 	eaputd	r19, r10
    1d84:	736b4372 		r27, r11, r8
    1d88:	65617465 	bslli	r11, r1, 5
    1d8c:	456e004f 	bsrl	r11, r14, r0
    1d90:	53546d72 		r26, r20, r13
    1d94:	43666757 		r27, r6, r12
    1d98:	6865656c 		r3, r5, r12
    1d9c:	53697a65 		r27, r9, r15
    1da0:	004f5354 		r2, r15, r10
    1da4:	61736b53 	muli	r11, r19, 27475
    1da8:	74617453 		r3, r1, r14
    1dac:	746b4368 		r3, r11, r8
    1db0:	6b456e00 		r26, r5, r13
    1db4:	4f53466c 	neaputd	r19, r8
    1db8:	61675769 	muli	r11, r7, 22377
    1dbc:	64746800 	bsrli	r3, r20, 0
    1dc0:	4f53546d 	eaputd	r19, r10
    1dc4:	72436667 		r18, r3, r12
    1dc8:	4e616d65 	ecaputd	r1, r13
    1dcc:	456e004f 	bsrl	r11, r14, r0
    1dd0:	53546d72 		r26, r20, r13
    1dd4:	4366674d 		r27, r6, r12
    1dd8:	6178004f 	muli	r11, r24, 79
    1ddc:	53466c61 		r26, r6, r13
    1de0:	674d6178 	bsrli	r26, r13, 24
    1de4:	004f534d 		r2, r15, r10
    1de8:	656d5462 	bslli	r11, r13, 2
    1dec:	6c53697a 	ncaget	r2, rfsl10
    1df0:	65004f53 		r8, r0, r9
    1df4:	546d7245 		r3, r13, r14
    1df8:	6e004f53 	neaget	r16, rfsl3
    1dfc:	456e6469 	bsll	r11, r14, r12
    1e00:	616e6e65 	muli	r11, r14, 28261
    1e04:	73735465 		r27, r19, r10
    1e08:	7374004f 		r27, r20, r0
    1e0c:	534d656d 		r26, r13, r12
    1e10:	4e616d65 	ecaputd	r1, r13
    1e14:	456e004f 	bsrl	r11, r14, r0
    1e18:	5354696d 		r26, r20, r13
    1e1c:	65546963 	bsrli	r10, r20, 3
    1e20:	6b486f6f 		r26, r8, r13
    1e24:	6b456e00 		r26, r5, r13
    1e28:	4f534d65 	ecaputd	r19, r9
    1e2c:	6d53697a 	ncaget	r10, rfsl10
    1e30:	65007074 	bsrli	r8, r0, 20
    1e34:	656d7000 	bsrli	r11, r13, 0
    1e38:	4f534d65 	ecaputd	r19, r9
    1e3c:	6d4d6178 	ncget	r10, rfsl8
    1e40:	004f5354 		r2, r15, r10
    1e44:	61736b50 	muli	r11, r19, 27472
    1e48:	726f6669 		r19, r15, r12
    1e4c:	6c65456e 	neget	r3, rfsl14
    1e50:	004f5350 		r2, r15, r10
    1e54:	74725369 		r3, r18, r10
    1e58:	7a65004f 		r19, r5, r0
    1e5c:	53466c61 		r26, r6, r13
    1e60:	674e6f64 		r26, r14, r13
    1e64:	6553697a 	bsrli	r10, r19, 26
    1e68:	65004f53 		r8, r0, r9
    1e6c:	5461736b 		r3, r1, r14
    1e70:	5377486f 		r27, r23, r9
    1e74:	6f6b456e 	neget	r27, rfsl14
    1e78:	004f5346 		r2, r15, r10
    1e7c:	6c61674e 	necget	r3, rfsl14
    1e80:	616d6545 	muli	r11, r13, 25925
    1e84:	6e004f53 	neaget	r16, rfsl3
    1e88:	54434253 		r2, r3, r8
    1e8c:	697a6500 		r11, r26, r12
    1e90:	4f535461 	eaputd	r19, r10
    1e94:	736b4372 		r27, r11, r8
    1e98:	65617465 	bslli	r11, r1, 5
    1e9c:	45787445 	bsll	r11, r24, r14
    1ea0:	6e004f53 	neaget	r16, rfsl3
    1ea4:	5461736b 		r3, r1, r14
    1ea8:	4d617800 	getd	r11, r15
    1eac:	4f535665 	neaputd	r19, r10
    1eb0:	7273696f 		r19, r19, r13
    1eb4:	6e4e6272 	ncget	r18, rfsl2
    1eb8:	004f534c 		r2, r15, r10
    1ebc:	6f776573 	necget	r27, rfsl3
    1ec0:	74507269 		r2, r16, r14
    1ec4:	6f004f53 	neaget	r24, rfsl3
    1ec8:	466c6167 	bsrl	r19, r12, r12
    1ecc:	47727053 	bsrl	r27, r18, r14
    1ed0:	697a6500 		r11, r26, r12
    1ed4:	4f53546d 	eaputd	r19, r10
    1ed8:	7253697a 		r18, r19, r13
    1edc:	65004f53 		r8, r0, r9
    1ee0:	5461736b 		r3, r1, r14
    1ee4:	4e616d65 	ecaputd	r1, r13
    1ee8:	456e004f 	bsrl	r11, r14, r0
    1eec:	534d7574 		r26, r13, r14
    1ef0:	6578456e 	bslli	r11, r24, 14
    1ef4:	004f5353 		r2, r15, r10
    1ef8:	656d456e 	bslli	r11, r13, 14
    1efc:	004f5351 		r2, r15, r10
    1f00:	4d617800 	getd	r11, r15
    1f04:	4f535145 	cagetd	r26, r10
    1f08:	6e004f53 	neaget	r16, rfsl3
    1f0c:	546d7257 		r3, r13, r14
    1f10:	6865656c 		r3, r5, r12
    1f14:	54626c53 		r3, r2, r13
    1f18:	697a6500 		r11, r26, r12
    1f1c:	4f535469 	eaputd	r19, r10
    1f20:	636b7350 	muli	r27, r11, 29520
    1f24:	65725365 	bsrai	r11, r18, 5
    1f28:	63004f53 	muli	r24, r0, 20307
    1f2c:	53746b57 		r27, r20, r13
    1f30:	69647468 		r11, r4, r14
    1f34:	004f5345 		r2, r15, r10
    1f38:	76656e74 		r19, r5, r13
    1f3c:	4e616d65 	ecaputd	r1, r13
    1f40:	456e004f 	bsrl	r11, r14, r0
    1f44:	53457665 		r26, r5, r14
    1f48:	6e744d61 	neaget	r19, rfsl1
    1f4c:	78004f53 		r0, r0, r9
    1f50:	546d7257 		r3, r13, r14
    1f54:	6865656c 		r3, r5, r12
    1f58:	53697a65 		r27, r9, r15
    1f5c:	004f5345 		r2, r15, r10
    1f60:	76656e74 		r19, r5, r13
    1f64:	4d756c74 	eaputd	r21, r13
    1f68:	69456e00 		r10, r5, r13
    1f6c:	4f534576 	ecaputd	r19, r8
    1f70:	656e7453 	bslli	r11, r14, 19
    1f74:	697a6500 		r11, r26, r12
    1f78:	4f534d62 	ecaputd	r19, r9
    1f7c:	6f78456e 	neget	r27, rfsl14
    1f80:	004f5354 		r2, r15, r10
    1f84:	43425072 		r26, r2, r10
    1f88:	696f5462 		r11, r15, r10
    1f8c:	6c4d6178 	ncget	r2, rfsl8
    1f90:	004f5354 		r2, r15, r10
    1f94:	61736b53 	muli	r11, r19, 27475
    1f98:	74617445 		r3, r1, r14
    1f9c:	6e004f53 	neaget	r16, rfsl3
    1fa0:	546d7243 		r3, r13, r14
    1fa4:	66675469 	bslli	r19, r7, 9
    1fa8:	636b7350 	muli	r27, r11, 29520
    1fac:	65725365 	bsrai	r11, r18, 5
    1fb0:	63004f53 	muli	r24, r0, 20307
    1fb4:	52647954 		r19, r4, r15
    1fb8:	626c5369 	muli	r19, r12, 21353
    1fbc:	7a65004f 		r19, r5, r0
    1fc0:	53457665 		r26, r5, r14
    1fc4:	6e745462 	tneget	r19, rfsl2
    1fc8:	6c53697a 	ncaget	r2, rfsl10
    1fcc:	65004f53 		r8, r0, r9
    1fd0:	466c6167 	bsrl	r19, r12, r12
    1fd4:	456e004f 	bsrl	r11, r14, r0
    1fd8:	53457665 		r26, r5, r14
    1fdc:	6e74456e 	neget	r19, rfsl14
    1fe0:	004f5354 		r2, r15, r10
    1fe4:	61736b49 	muli	r11, r19, 27465
    1fe8:	646c6553 	bslli	r3, r12, 19
    1fec:	746b5369 		r3, r11, r10
    1ff0:	7a65004f 		r19, r5, r0
    1ff4:	53446562 		r26, r4, r12
    1ff8:	7567496e 		r11, r7, r9
    1ffc:	6974004f 		r11, r20, r0
    2000:	53546173 		r26, r20, r12
    2004:	6b44656c 		r26, r4, r12
    2008:	456e006d 	bsrl	r11, r14, r0
    200c:	61736b5f 	muli	r11, r19, 27487
    2010:	69740074 		r11, r20, r0
    2014:	696d6572 		r11, r13, r12
    2018:	5f315f72 		r25, r17, r11
    201c:	65736574 	bslli	r11, r19, 20
    2020:	0074696d 		r3, r20, r13
    2024:	65725f31 		r11, r18, r11
    2028:	5f656e61 		r27, r5, r13
    202c:	626c6500 	muli	r19, r12, 25856
    2030:	696e7463 		r11, r14, r14
    2034:	5f736574 		r27, r19, r12
    2038:	5f61726d 		r27, r1, r14
    203c:	00746872 		r3, r20, r13
    2040:	6573686f 	bsrli	r11, r19, 15
    2044:	6c640061 	get	r3, rfsl1
    2048:	726d5f69 		r19, r13, r11
    204c:	74007469 		r0, r0, r14
    2050:	6d65725f 	tncget	r11, rfsl15
    2054:	315f696e 	addik	r10, r31, 26990
    2058:	69740042 		r11, r20, r0
    205c:	53505f54 		r26, r16, r11
    2060:	6d72496e 	naget	r11, rfsl14
    2064:	69740042 		r11, r20, r0
    2068:	53505f49 		r26, r16, r11
    206c:	6e697449 	tnecget	r19, rfsl9
    2070:	6e744374 	nget	r19, rfsl4
    2074:	726c0069 		r19, r12, r0
    2078:	6e74635f 	ncget	r19, rfsl15
    207c:	7365745f 		r27, r5, r14
    2080:	6d61736b 	tncget	r11, rfsl11
    2084:	00627370 		r3, r2, r14
    2088:	2e630042 	rsubic	r19, r3, 66
    208c:	53505f49 		r26, r16, r11
    2090:	6e697449 	tnecget	r19, rfsl9
    2094:	4f004170 	ecagetd	r24, r8
    2098:	70546173 		r2, r20, r12
    209c:	6b437265 		r26, r3, r14
    20a0:	61746500 	muli	r11, r20, 25856
    20a4:	5365636f 		r27, r5, r12
    20a8:	6e645461 	tneget	r19, rfsl1
    20ac:	736b0046 		r27, r11, r0
    20b0:	69727374 		r11, r18, r14
    20b4:	5461736b 		r3, r1, r14
    20b8:	53746b00 		r27, r20, r13
    20bc:	46697273 	bsra	r19, r9, r14
    20c0:	74546173 		r2, r20, r12
    20c4:	6b004253 		r24, r0, r8
    20c8:	505f496e 		r2, r31, r9
    20cc:	74446973 		r2, r4, r13
    20d0:	416c6c00 		r11, r12, r13
    20d4:	68656c6c 		r3, r5, r13
    20d8:	6f776f72 	necaget	r27, rfsl2
    20dc:	6c642e63 	ecaget	r3, rfsl3
    20e0:	00536563 		r2, r19, r12
    20e4:	6f6e6454 	necget	r27, rfsl4
    20e8:	61736b53 	muli	r11, r19, 27475
    20ec:	Address 0x000020ec is out of bounds.

